<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜雨闻曦</title>
  
  <subtitle>躲进小楼成一统，管他冬夏与春秋。</subtitle>
  <link href="http://yeyuwenxi.github.io/atom.xml" rel="self"/>
  
  <link href="http://yeyuwenxi.github.io/"/>
  <updated>2021-12-24T07:06:38.837Z</updated>
  <id>http://yeyuwenxi.github.io/</id>
  
  <author>
    <name>pcl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《被讨厌的勇气》</title>
    <link href="http://yeyuwenxi.github.io/2021/12/24/bei-tao-yan-de-yong-qi/"/>
    <id>http://yeyuwenxi.github.io/2021/12/24/bei-tao-yan-de-yong-qi/</id>
    <published>2021-12-24T07:06:14.000Z</published>
    <updated>2021-12-24T07:06:38.837Z</updated>
    
    
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>linux信号机制</title>
    <link href="http://yeyuwenxi.github.io/2021/09/13/linux-xin-hao-ji-zhi/"/>
    <id>http://yeyuwenxi.github.io/2021/09/13/linux-xin-hao-ji-zhi/</id>
    <published>2021-09-13T13:32:22.000Z</published>
    <updated>2021-09-13T13:32:54.579Z</updated>
    
    <content type="html"><![CDATA[<p>信号机制主要包括信号的发送和处理。<br>可以类比于单片机中的中断和中断服务函数，也可以类比于Qt中的信号与槽。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>signal函数用来处理接受到的信号</p><p><code>sighandler_t signal(int signum, sighandler_t handler);</code><br>第一个参数signum：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 　<br>第二个参数handler：描述了与信号关联的动作，它可以取以下三种值：</p><ul><li>SIG_IGN 　<br>忽略此信号</li><li>SIG_DFL 　<br>执行系统默认操作</li><li>sighandler_t类型的函数指针<br>执行函数指针所指向的函数<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3>kill函数用来发送信号</li></ul><p><code>int kill(pid_t pid, int signo);</code><br>pid参数存在四种情况</p><ul><li> pid大于零时，将该信号发送给进程ID为pid的进程</li><li> pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。</li><li> pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。</li><li> pid小于-1时，信号将送往以-pid为组标识的进程。</li></ul><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行。</p><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>kill函数将信号发送给进程和进程组，raise函数则允许进程向自身发送信号。<br>调用raise(signo)<br>等价于调用<br>kill(getpid(),signo)</p><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>send.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span>pid<span class="token operator">=</span><span class="token number">18411</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SIGUSR1是系统保留给用户使用的信号</span><span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>recv.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span> hello<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先运行recv程序，使用ps -a命令查寻得pid<br>再运行send程序向该pid的进程发送信号<br>可以看到recv程序以一秒为周期向屏幕打印hello world</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>《UNIX环境高级编程》<br><a href="https://blog.csdn.net/yockie/article/details/51729774?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162969933616780255238561%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162969933616780255238561&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51729774.first_rank_v2_pc_rank_v29&utm_term=linux%20signal%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">【Linux函数】Signal ()函数详细介绍</a><br><a href="https://blog.csdn.net/sweetfather/article/details/79462559?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162969932716780269892963%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162969932716780269892963&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79462559.first_rank_v2_pc_rank_v29&utm_term=linux%20kill%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">Linux 下的KILL函数的用法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;信号机制主要包括信号的发送和处理。&lt;br&gt;可以类比于单片机中的中断和中断服务函数，也可以类比于Qt中的信号与槽。&lt;/p&gt;
&lt;h3 id=&quot;signal&quot;&gt;&lt;a href=&quot;#signal&quot; class=&quot;headerlink&quot; title=&quot;signal&quot;&gt;&lt;/a&gt;sign</summary>
      
    
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux多线程编程</title>
    <link href="http://yeyuwenxi.github.io/2021/09/13/linux-duo-xian-cheng-bian-cheng/"/>
    <id>http://yeyuwenxi.github.io/2021/09/13/linux-duo-xian-cheng-bian-cheng/</id>
    <published>2021-09-13T13:31:15.000Z</published>
    <updated>2021-09-13T13:31:48.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux多线程编程"><a href="#linux多线程编程" class="headerlink" title="linux多线程编程"></a>linux多线程编程</h1><p>这个帖子是一边改代码一边写的，可能会有点乱，有空再好好整理一下</p><p>linux多线程编程使用的接口主要包含在头文件&lt;pthread.h&gt;中</p><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h3 id="多线程入门"><a href="#多线程入门" class="headerlink" title="多线程入门"></a>多线程入门</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;多线程#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void* print1()&#123;while(1)&#123;sleep(1);printf(&quot;This is thread1\n&quot;);&#125;&#125;void* print2()&#123;while(1)&#123;sleep(1);printf(&quot;This is thread2\n&quot;);&#125;&#125;int main()&#123;pthread_t th1;pthread_t th2;pthread_create(&amp;th1,NULL,print1,NULL);pthread_create(&amp;th2,NULL,print2,NULL);while(1)&#123;sleep(1);printf(&quot;This is function main\n&quot;);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">This is thread2This is thread1This is function mainThis is thread2This is thread1This is function mainThis is thread2This is thread1This is function mainThis is thread1This is thread2This is function mainThis is thread1This is thread2This is function mainThis is thread2This is function mainThis is thread1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个问题一直没有想明白，sleep和printf如果交换顺序的话，代码就不能正常执行了</p><h3 id="给创建的线程传递参数"><a href="#给创建的线程传递参数" class="headerlink" title="给创建的线程传递参数"></a>给创建的线程传递参数</h3><p>这里要注意的是，我们传递的参数一定要是void *类型的指针<br>下面通过修改一下上面的例程，通过参数化的方法来判断线程1和线程2</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多线程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is thread%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>print<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>print<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is function main\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行效果与之前是一致的</p><h3 id="线程的互斥问题"><a href="#线程的互斥问题" class="headerlink" title="线程的互斥问题"></a>线程的互斥问题</h3><p>先来看一个经典的卖票问题</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n=%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n<span class="token operator">=</span><span class="token number">10</span>n<span class="token operator">=</span><span class="token number">9</span>n<span class="token operator">=</span><span class="token number">8</span>n<span class="token operator">=</span><span class="token number">7</span>n<span class="token operator">=</span><span class="token number">6</span>n<span class="token operator">=</span><span class="token number">5</span>n<span class="token operator">=</span><span class="token number">4</span>n<span class="token operator">=</span><span class="token number">3</span>n<span class="token operator">=</span><span class="token number">2</span>n<span class="token operator">=</span><span class="token number">1</span>n<span class="token operator">=</span><span class="token number">0</span>n<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>什么？居然出现了-1的情况<br>这时候就需要考虑线程的互斥问题了</p><p>添加互斥锁之后</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多线程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> p_mutex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>p_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n=%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>p_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_mutex_t</span> m_mutex<span class="token punctuation">;</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时查看运行效果，发现到0之后正常停止了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n<span class="token operator">=</span><span class="token number">10</span>n<span class="token operator">=</span><span class="token number">9</span>n<span class="token operator">=</span><span class="token number">8</span>n<span class="token operator">=</span><span class="token number">7</span>n<span class="token operator">=</span><span class="token number">6</span>n<span class="token operator">=</span><span class="token number">5</span>n<span class="token operator">=</span><span class="token number">4</span>n<span class="token operator">=</span><span class="token number">3</span>n<span class="token operator">=</span><span class="token number">2</span>n<span class="token operator">=</span><span class="token number">1</span>n<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>三个线程按顺序输出ABC</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;多线程&#x2F;&#x2F;多线程#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;pthread_mutex_t m_mutex;pthread_cond_t condA;pthread_cond_t condB;pthread_cond_t condC;void* printA()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condA,&amp;m_mutex);printf(&quot;A&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condB);&#125;&#125;void* printB()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condB,&amp;m_mutex);printf(&quot;B&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condC);&#125;&#125;void* printC()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condC,&amp;m_mutex);printf(&quot;C&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condA);&#125;&#125;int main()&#123;pthread_cond_init(&amp;condA, NULL);pthread_cond_init(&amp;condB, NULL);pthread_cond_init(&amp;condC, NULL);pthread_mutex_init(&amp;m_mutex, NULL);pthread_t th1;pthread_t th2;pthread_t th3;pthread_create(&amp;th1,NULL,printA,NULL);pthread_create(&amp;th2,NULL,printB,NULL);pthread_create(&amp;th3,NULL,printC,NULL);pthread_cond_signal(&amp;condA);while(1);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以上代码，可以看到程序按顺序输出ABC<br>这里存在一个问题，程序有时候会莫名卡死，暂时没有想明白是为什么</p><h3 id="生产者消费者问题-一对一"><a href="#生产者消费者问题-一对一" class="headerlink" title="生产者消费者问题 一对一"></a>生产者消费者问题 一对一</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token class-name">pthread_mutex_t</span> m_mutex<span class="token punctuation">;</span><span class="token class-name">sem_t</span> sem<span class="token punctuation">;</span><span class="token keyword">int</span> product_num<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">producter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>product_num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is producter. product a product. product_num=%d\n"</span><span class="token punctuation">,</span>product_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>product_num<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is consumer. consume a product. product_num=%d\n"</span><span class="token punctuation">,</span>product_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>producter<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>consumer<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">9</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">8</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">7</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">6</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">5</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">4</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">3</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">2</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux多线程编程&quot;&gt;&lt;a href=&quot;#linux多线程编程&quot; class=&quot;headerlink&quot; title=&quot;linux多线程编程&quot;&gt;&lt;/a&gt;linux多线程编程&lt;/h1&gt;&lt;p&gt;这个帖子是一边改代码一边写的，可能会有点乱，有空再好好整理一下&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>c语言错误信息</title>
    <link href="http://yeyuwenxi.github.io/2021/09/12/c-yu-yan-cuo-wu-xin-xi/"/>
    <id>http://yeyuwenxi.github.io/2021/09/12/c-yu-yan-cuo-wu-xin-xi/</id>
    <published>2021-09-12T06:00:55.000Z</published>
    <updated>2021-09-12T06:03:24.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>c语言中存在一个error，用来保存最后的错误代码.<br>errno定义在&lt;errno.h&gt;中，是一个宏定义，用来储存错误代码。<br>当程序发生错误时，就会将错误代码写入errno.<br>程序启动时，errno为0，当发生错误时，程序就会将错误代码写入errno,注意，errno是不会自动清零的，而且错误代码的写入是可覆盖的。<br>所以我们必须在错误发生后立即读取errno的值，进行相关处理。</p><p>错误代码只是一个数字，想要获得具体的错误提示信息有两种办法，一是使用perror直接输出错误信息，二是使用strerror 将错误代码转换成对应的文本信息。</p><h3 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h3><p><code>void perror(const char *s)</code></p><ul><li>函数说明<br>perror ( )用 来 将 上 一 个 函 数 发 生 错 误 的 原 因 输 出 到 标 准 设备 (stderr) 。参数 s 所指的字符串会先打印出,后面再加上错误原因字符串。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"D:/demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Congratulations, the file opens successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"file error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>运行结果：file error: No such file or directory</p><h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h3><p><code>char *strerror(int errno);</code></p><ul><li>函数说明<br>strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//将 errno 设置回 0 值</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"D:/demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Congratulations, the file opens successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error no.%d: %s\n"</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为<br>Error no.2: No such file or directory</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://c.biancheng.net/ref/errno.html">errno 记录最后的错误代码</a><br><a href="https://blog.csdn.net/wucz122140729/article/details/98437350">C语言系统错误信息</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;errno&quot;&gt;&lt;a href=&quot;#errno&quot; class=&quot;headerlink&quot; title=&quot;errno&quot;&gt;&lt;/a&gt;errno&lt;/h3&gt;&lt;p&gt;c语言中存在一个error，用来保存最后的错误代码.&lt;br&gt;errno定义在&amp;lt;errno.h&amp;gt;中，是一个</summary>
      
    
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>linux多进程</title>
    <link href="http://yeyuwenxi.github.io/2021/09/12/linux-duo-jin-cheng/"/>
    <id>http://yeyuwenxi.github.io/2021/09/12/linux-duo-jin-cheng/</id>
    <published>2021-09-12T05:57:36.000Z</published>
    <updated>2021-09-12T06:00:12.473Z</updated>
    
    <content type="html"><![CDATA[<p>使用fork创建子进程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is the child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is the father process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">this is the father processthis is the child processthis is the father processthis is the child processthis is the father processthis is the child processthis is the father processthis is the child process<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新进程。<br>vfork与fork都创建一个子进程，但是它并不会将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit,于是也就不会引用该地址空间。不过在子进程中调用exec或exit之前，它在父进程的空间中运行。<br>vfork与fork的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才开始运行。</p><h3 id="wait和waitpid"><a href="#wait和waitpid" class="headerlink" title="wait和waitpid"></a>wait和waitpid</h3><ul><li><p>wait函数等待子进程的结束信号。<br>它是阻塞函数,只有任意一个子进程结束,它才能继续往下执行,否则卡住那里等。</p></li><li><p>waitpid等待指定pid对应的进程结束，可以选择阻塞或者不阻塞的方式。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec系列的函数有很多个，主要用来执行一个新的程序，即用一个全新的程序来替换子进程的内容。</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_40519315/article/details/104156838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162976969216780255264774%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162976969216780255264774&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104156838.first_rank_v2_pc_rank_v29&utm_term=linux%E5%A4%9A%E8%BF%9B%E7%A8%8B&spm=1018.2226.3001.4187">Linux多进程编程(典藏、含代码)</a><br>《UNIX环境高级编程》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用fork创建子进程&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c&quot; data-language=&quot;c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token macro property&quot;&gt;&lt;span </summary>
      
    
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>堆栈应用之表达式优先级</title>
    <link href="http://yeyuwenxi.github.io/2021/08/09/dui-zhan-ying-yong-zhi-biao-da-shi-you-xian-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/08/09/dui-zhan-ying-yong-zhi-biao-da-shi-you-xian-ji/</id>
    <published>2021-08-09T12:30:04.000Z</published>
    <updated>2021-09-13T13:00:38.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="带优先级的计算器实现"><a href="#带优先级的计算器实现" class="headerlink" title="带优先级的计算器实现"></a>带优先级的计算器实现</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#define size 100typedef struct Char&#x2F;&#x2F;运算符栈结构&#123;char data[size];int top;&#125;CHAR;typedef struct Num&#x2F;&#x2F;操作数栈结构&#123;double data[size];int top;&#125;NUM;void InitC(CHAR* C)&#x2F;&#x2F;初始化运算符栈&#123;C-&gt;top &#x3D; -1;&#125;void InitN(NUM* N)&#x2F;&#x2F;初始化操作数栈&#123;N-&gt;top &#x3D; -1;&#125;void PushC(CHAR* C, char e)&#x2F;&#x2F;运算符压栈&#123;C-&gt;data[++C-&gt;top] &#x3D; e;&#125;void PushN(NUM* N, double e)&#x2F;&#x2F;操作数压栈&#123;N-&gt;data[++N-&gt;top] &#x3D; e;&#125;char PopC(CHAR* C)&#x2F;&#x2F;运算符出栈&#123;return C-&gt;data[C-&gt;top--];&#125;double PopN(NUM* N)&#x2F;&#x2F;操作数出栈&#123;return N-&gt;data[N-&gt;top--];&#125;double GetTopN(NUM* N)&#x2F;&#x2F;取操作数栈顶元素&#123;return N-&gt;data[N-&gt;top];&#125;char GetTopC(CHAR* C)&#x2F;&#x2F;取运算符栈顶元素&#123;return C-&gt;data[C-&gt;top];&#125;&#x2F;&#x2F;判断输入的字符串是否正确bool fun(char* str)&#123;int x &#x3D; 0, i &#x3D; 0;while (*str) &#123;if ((*str &lt; &#39;0&#39; || *str &gt; &#39;9&#39;) &amp;&amp; *str !&#x3D; &#39;+&#39; &amp;&amp; *str !&#x3D; &#39;-&#39; &#x2F;&#x2F;不是数字+-*&#x2F;（）则false&amp;&amp; *str !&#x3D; &#39;*&#39; &amp;&amp; *str !&#x3D; &#39;&#x2F;&#39; &amp;&amp; *str !&#x3D; &#39;(&#39; &amp;&amp; *str !&#x3D; &#39;)&#39;) &#123;return false;&#125;if ((i &#x3D;&#x3D; 0) &amp;&amp; (*str &lt; &#39;0&#39; || *str &gt; &#39;9&#39;) &amp;&amp; *str !&#x3D; &#39;(&#39;) &#123; &#x2F;&#x2F;开头不为（ 或数字 则falsereturn false;&#125;if (((*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39;) || *str &#x3D;&#x3D; &#39;)&#39;) &amp;&amp; (*(str + 1) &#x3D;&#x3D; &#39;(&#39;)) &#123;return false; &#x2F;&#x2F;如果是数字和 ），后面是 （ 则false&#125;if (*str &#x3D;&#x3D; &#39;)&#39;) &#123; &#x2F;&#x2F;如果是 ） ，x--;if (x &lt; 0) &#123;return false;&#125;&#125;if ((*str &#x3D;&#x3D; &#39;+&#39; || *str &#x3D;&#x3D; &#39;-&#39; || *str &#x3D;&#x3D; &#39;*&#39; || *str &#x3D;&#x3D; &#39;&#x2F;&#39; || *str &#x3D;&#x3D; &#39;(&#39;) &amp;&amp;(*(str + 1) &#x3D;&#x3D; 0 || *(str + 1) &#x3D;&#x3D; &#39;+&#39; || *(str + 1) &#x3D;&#x3D; &#39;-&#39; || *(str + 1) &#x3D;&#x3D; &#39;*&#39; || *(str + 1) &#x3D;&#x3D; &#39;&#x2F;&#39; || *(str + 1) &#x3D;&#x3D; &#39;)&#39;)) &#123;return false; &#x2F;&#x2F;如果是运算符号 ，后面不能是运算符号和 ）&#125;if (*str &#x3D;&#x3D; &#39;(&#39;) &#123; &#x2F;&#x2F;如果是 （x++;&#125;str++; i++;&#125;if (x &gt; 0) &#123; &#x2F;&#x2F;如果括号不匹配return false;&#125;return true;&#125;int op(char ch)&#x2F;&#x2F;判断字符是否为运算符&#123;char a[8] &#x3D; &#123; &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#x3D;&#39;,&#39;#&#39; &#125;;int i;for (i &#x3D; 0; i &lt; 8; i++)&#123;if (ch &#x3D;&#x3D; a[i])return 1;&#125;return 0;&#125;double operate(double a, char op, double b)&#x2F;&#x2F;执行运算&#123;switch (op)&#123;case &#39;+&#39;:return a + b; break;case &#39;-&#39;:return a - b; break;case &#39;*&#39;:return a * b; break;case &#39;&#x2F;&#39;:return a &#x2F; b; break;default:return 0; break;&#125;&#125;char compare(char a, char b)&#x2F;&#x2F;比较运算符优先级&#123;int i, j;char Table[8][8] &#x3D;&#123;&#123; &#39; &#39;, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;&#125;,&#123; &#39;+&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;-&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;*&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;&#x2F;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;(&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&#x3D;&#39;, &#39; &#39;&#125;,&#123; &#39;)&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39; &#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;#&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39; &#39;, &#39;&#x3D;&#39;&#125;,&#125;;  &#x2F;&#x2F;优先级对照表for (i &#x3D; 0; i &lt; 8; i++)if (Table[i][0] &#x3D;&#x3D; a)  &#x2F;&#x2F;寻找a的位置break;for (j &#x3D; 0; j &lt; 8; j++)  &#x2F;&#x2F;寻找b的位置if (Table[0][j] &#x3D;&#x3D; b)break;return Table[i][j];&#125;int main() &#123;char ch[100];cout &lt;&lt; &quot;请输入要计算的表达式：&quot;;cin &gt;&gt; ch;&#x2F;&#x2F;输入字符串int len &#x3D; 0;&#x2F;&#x2F;获取表达式长度len &#x3D; strlen(ch);&#x2F;&#x2F;表达式末尾加一个‘#’if (fun(ch) &#x3D;&#x3D; 1) &#123; cout &lt;&lt; &quot;输入的表达式正确&quot;&lt;&lt;endl; &#125;else&#123; cout &lt;&lt; &quot;输入的表达式错误&quot; &lt;&lt; endl; &#125;ch[len] &#x3D; &#39;#&#39;;double a, b;char theta;&#x2F;&#x2F;运算符&#x2F;&#x2F;初始化操作数栈和运算符栈NUM OPND;CHAR OPTR;InitC(&amp;OPTR);InitN(&amp;OPND);PushC(&amp;OPTR, &#39;#&#39;);int i &#x3D; 0;while (ch[i] !&#x3D; &#39;#&#39; || GetTopC(&amp;OPTR) !&#x3D; &#39;#&#39;)&#123;if (!op(ch[i])) &#123;double num &#x3D; 0;int j &#x3D; 0;while (ch[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; ch[i] &lt;&#x3D; &#39;9&#39; || ch[i] &#x3D;&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F;把字符串换算成实际数值if (ch[i] !&#x3D; &#39;.&#39;)num &#x3D; num * 10 + ch[i] - &#39;0&#39;;if (ch[i] &#x3D;&#x3D; &#39;.&#39; || j &gt; 0) j++;i++;&#125;&#x2F;&#x2F;对小数进行额外处理if (j &gt; 0) num &#x3D; num &#x2F; pow(10, j - 1);PushN(&amp;OPND, num);&#125;if (op(ch[i]))&#123;switch (compare(GetTopC(&amp;OPTR), ch[i]))&#123;case&#39;&lt;&#39;:PushC(&amp;OPTR, ch[i]);i++;break;case&#39;&#x3D;&#39;:PopC(&amp;OPTR);i++;break;case&#39;&gt;&#39;:theta &#x3D; PopC(&amp;OPTR);b &#x3D; PopN(&amp;OPND); a &#x3D; PopN(&amp;OPND);PushN(&amp;OPND, operate(a, theta, b));   break;&#125;&#125;&#125;cout &lt;&lt; &quot;运算结果为：&quot;&lt;&lt;GetTopN(&amp;OPND);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;带优先级的计算器实现&quot;&gt;&lt;a href=&quot;#带优先级的计算器实现&quot; class=&quot;headerlink&quot; title=&quot;带优先级的计算器实现&quot;&gt;&lt;/a&gt;带优先级的计算器实现&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>linux进程通信之socket通信</title>
    <link href="http://yeyuwenxi.github.io/2021/08/09/linux-jin-cheng-tong-xin-zhi-socket-tong-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/08/09/linux-jin-cheng-tong-xin-zhi-socket-tong-xin/</id>
    <published>2021-08-09T12:27:06.000Z</published>
    <updated>2021-09-12T05:56:15.862Z</updated>
    
    <content type="html"><![CDATA[<p>实现基于命令行的linux交互式通信</p><h3 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取客户端传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> sock<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message form server: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//创建套接字</span>    <span class="token keyword">int</span> sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//向服务器（特定的IP和端口）发起请求</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//每个字节都用0填充</span>    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>  <span class="token comment">//使用IPv4地址</span>    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//具体的IP地址</span>    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//端口</span>    <span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//读取服务器传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> readThread<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readThread<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>read_data<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>       <span class="token comment">//关闭套接字</span>    <span class="token function">close</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器端的实现"><a href="#服务器端的实现" class="headerlink" title="服务器端的实现"></a>服务器端的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取客户端传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> sock<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message form client: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//创建套接字</span>    <span class="token keyword">int</span> serv_sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将套接字和IP、端口绑定</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//每个字节都用0填充</span>    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>  <span class="token comment">//使用IPv4地址</span>    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//具体的IP地址</span>    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//端口</span>    <span class="token function">bind</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入监听状态，等待用户发起请求</span>    <span class="token function">listen</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//接收客户端请求</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> clnt_addr<span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> clnt_addr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clnt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> clnt_sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clnt_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clnt_addr_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//向客户端发送数据</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> readThread<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readThread<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>read_data<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//关闭套接字</span>    <span class="token function">close</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现基于命令行的linux交互式通信&lt;/p&gt;
&lt;h3 id=&quot;客户端的实现&quot;&gt;&lt;a href=&quot;#客户端的实现&quot; class=&quot;headerlink&quot; title=&quot;客户端的实现&quot;&gt;&lt;/a&gt;客户端的实现&lt;/h3&gt;&lt;pre class=&quot;line-numbers langua</summary>
      
    
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://yeyuwenxi.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Android数据库应用之单词本</title>
    <link href="http://yeyuwenxi.github.io/2021/06/28/android-shu-ju-ku-ying-yong-zhi-dan-ci-ben/"/>
    <id>http://yeyuwenxi.github.io/2021/06/28/android-shu-ju-ku-ying-yong-zhi-dan-ci-ben/</id>
    <published>2021-06-28T09:38:56.000Z</published>
    <updated>2021-06-28T10:14:40.263Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下以前做过的一个小应用，主要是基于SQLite实现了一个简单的记录单词的app.</p><h3 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h3><pre class="line-numbers language-none"><code class="language-none">public class DatabaseHelper extends SQLiteOpenHelper &#123;    private static final int VERSION &#x3D; 1;    &#x2F;&#x2F; private static final String SWORD&#x3D;&quot;SWORD&quot;;    &#x2F;&#x2F;三个不同参数的构造函数    &#x2F;&#x2F;带全部参数的构造函数，此构造函数必不可少    public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,                          int version) &#123;        super(context, name, factory, version);    &#125;    public DatabaseHelper(Context context,String name,int version)&#123;        this(context, name,null,version);    &#125;    &#x2F;&#x2F;创建数据库    public void onCreate(SQLiteDatabase db) &#123;        &#x2F;&#x2F;创建数据库sql语句        String sql &#x3D; &quot;create table danciben(id int,danci text,zhushi text,xiangqing text,xingbiao int,beihui int)&quot;;        &#x2F;&#x2F;执行创建数据库操作        db.execSQL(sql);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        &#x2F;&#x2F;创建成功，日志输出提示    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre class="line-numbers language-none"><code class="language-none">db &#x3D; new DatabaseHelper(tianjia.this,&quot;danciben&quot;, null, 1); &#x2F;&#x2F;数据库实际上是没有被创建或者打开的，直到getWritableDatabase() 或者 getReadableDatabase() 方法中的一个被调用时才会进行创建或者打开  db.getWritableDatabase();  insertData(db.getReadableDatabase(),ciyu,zhushi,xiangqing);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre class="line-numbers language-none"><code class="language-none">db.getWritableDatabase().delete(&quot;danciben&quot;,&quot;danci&#x3D;?&quot;, new String[]&#123;danci&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用游标进行查找<br>like关键词可支持模糊查找</p><pre class="line-numbers language-none"><code class="language-none">Cursor cursor&#x3D;db.getReadableDatabase().query(&quot;danciben&quot;,null,&quot;danci like?&quot;, new String[]&#123;key+&quot;%&quot;&#125;,null,null,null);  while(cursor.moveToNext())&#123;   String danci&#x3D;cursor.getString(cursor.getColumnIndex(&quot;danci&quot;));    String zhushi&#x3D;cursor.getString(cursor.getColumnIndex(&quot;zhushi&quot;));    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="部分功能测试结果"><a href="#部分功能测试结果" class="headerlink" title="部分功能测试结果"></a>部分功能测试结果</h3><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_3.png" ><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_4.png" ><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_5.png" ><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><p><a href="https://github.com/yeyuwenxi/toolcase/blob/main/datalibrary2.zip">github下载链接</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/midnight_time/article/details/80834198?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160522951719725222401033%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160522951719725222401033&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-6-80834198.first_rank_ecpm_v3_pc_rank_v2&utm_term=androidSQLite&spm=1018.2118.3001.4449">【Android】SQLite数据库基本用法详解（极简洁）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整理一下以前做过的一个小应用，主要是基于SQLite实现了一个简单的记录单词的app.&lt;/p&gt;
&lt;h3 id=&quot;数据库的创建&quot;&gt;&lt;a href=&quot;#数据库的创建&quot; class=&quot;headerlink&quot; title=&quot;数据库的创建&quot;&gt;&lt;/a&gt;数据库的创建&lt;/h3&gt;&lt;pre c</summary>
      
    
    
    
    <category term="Android" scheme="http://yeyuwenxi.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yeyuwenxi.github.io/tags/Android/"/>
    
    <category term="数据库" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQLite" scheme="http://yeyuwenxi.github.io/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>qt入门之简易计算器</title>
    <link href="http://yeyuwenxi.github.io/2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/"/>
    <id>http://yeyuwenxi.github.io/2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/</id>
    <published>2021-06-28T06:54:32.000Z</published>
    <updated>2021-06-28T07:13:35.904Z</updated>
    
    <content type="html"><![CDATA[<p>最近考完试比较闲了，简单学了一下qt,做了个最基本的计算器。</p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>通过可视化的方法，拖动实现界面<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_1.png" ></p><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><p>在头文件中实现类的定义和类内成员的声明</p><pre class="line-numbers language-none"><code class="language-none">class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent &#x3D; 0);    ~MainWindow();    int num1;    int num2;    double result;    int op;private slots:    void on_button_1_clicked();    void on_button_2_clicked();    void on_button_3_clicked();    void on_button_add_clicked();    void on_button_4_clicked();    void on_button_5_clicked();    void on_button_6_clicked();    void on_button_sub_clicked();    void on_button_7_clicked();    void on_button_8_clicked();    void on_button_9_clicked();    void on_button_mult_clicked();    void on_button_clear_clicked();    void on_button_0_clicked();    void on_button_equal_clicked();    void on_button_div_clicked();private:    Ui::MainWindow *ui;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在cpp文件中实现类内成员的定义</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;iostream&gt;using namespace std;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    this-&gt;setWindowTitle(&quot;计算器1.0&quot;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::on_button_1_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;1&quot;);&#125;void MainWindow::on_button_2_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;2&quot;);&#125;void MainWindow::on_button_3_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;3&quot;);&#125;void MainWindow::on_button_add_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;+&quot;);&#125;void MainWindow::on_button_4_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;4&quot;);&#125;void MainWindow::on_button_5_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;5&quot;);&#125;void MainWindow::on_button_6_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;6&quot;);&#125;void MainWindow::on_button_sub_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;-&quot;);&#125;void MainWindow::on_button_7_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;7&quot;);&#125;void MainWindow::on_button_8_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;8&quot;);&#125;void MainWindow::on_button_9_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;9&quot;);&#125;void MainWindow::on_button_mult_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;*&quot;);&#125;void MainWindow::on_button_clear_clicked()&#123; ui-&gt;textEdit-&gt;setText(&quot;&quot;);&#125;void MainWindow::on_button_0_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;0&quot;);&#125;void MainWindow::on_button_equal_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x3D;&quot;);       QString text &#x3D; ui-&gt;textEdit-&gt;toPlainText();       string text1&#x3D;text.toStdString();       &#x2F;&#x2F;cout&lt;&lt;text1&lt;&lt;endl;       &#x2F;&#x2F;cout&lt;&lt;text1[1]&lt;&lt;endl;       int len&#x3D;text1.size();       const char * text2&#x3D;text1.c_str();       cout&lt;&lt;text2;       int flag&#x3D;0;       num1&#x3D;0;       num2&#x3D;0;       op&#x3D;0;       result&#x3D;0;       for(int i&#x3D;0;i&lt;len;i++)&#123;       if(text2[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;text2[i]&lt;&#x3D;&#39;9&#39;)&#123;       if(flag&#x3D;&#x3D;0)&#123;           num1&#x3D;num1*10+text2[i]-&#39;0&#39;;       &#125;       if(flag&#x3D;&#x3D;1)&#123;           num2&#x3D;num2*10+text2[i]-&#39;0&#39;;       &#125;       &#125;else if(text2[i]&#x3D;&#x3D;&#39;+&#39;)&#123;           flag&#x3D;1;           op&#x3D;1;           cout&lt;&lt;&quot;+++&quot;&lt;&lt;endl;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;-&#39;)&#123;           flag&#x3D;1;           op&#x3D;2;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;*&#39;)&#123;           flag&#x3D;1;           op&#x3D;3;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)&#123;           flag&#x3D;1;           op&#x3D;4;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;           if(op&#x3D;&#x3D;1)&#123;               result&#x3D;num1+num2;               cout&lt;&lt;num1&lt;&lt;endl;               cout&lt;&lt;num2&lt;&lt;endl;           &#125;           if(op&#x3D;&#x3D;2)&#123;               result&#x3D;num1-num2;           &#125;           if(op&#x3D;&#x3D;3)&#123;               result&#x3D;num1*num2;           &#125;           if(op&#x3D;&#x3D;4)&#123;               result&#x3D;(num1*1.00)&#x2F;num2;           &#125;              ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);              ui-&gt;textEdit-&gt;insertPlainText(QString::number(result));       &#125;       &#125;&#125;void MainWindow::on_button_div_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x2F;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>qt整体的架构还是比较清晰的，界面和逻辑部分互相分离，又通过信号与槽进行必要的通信。<br>头文件中完成了类的定义，而对类的成员函数仅作声明，具体实现在cpp文件中完成，整个过程实现了类内声明，类外定义。<br>计算器的基本原理也比较简单，按下按钮时，字符附加到编辑框对应的字符串后，最后按下等号时读取整个字符串，分离两个操作数和一个运算符，进行计算，并将最后的计算结果显示到编辑框中。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>生成exe文件并通过命令行配置好注册表文件后，点击exe文件就可以正常运行了，运行结果如图所示。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_2.png" ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近考完试比较闲了，简单学了一下qt,做了个最基本的计算器。&lt;/p&gt;
&lt;h3 id=&quot;界面设计&quot;&gt;&lt;a href=&quot;#界面设计&quot; class=&quot;headerlink&quot; title=&quot;界面设计&quot;&gt;&lt;/a&gt;界面设计&lt;/h3&gt;&lt;p&gt;通过可视化的方法，拖动实现界面&lt;br&gt;&lt;img </summary>
      
    
    
    
    <category term="qt" scheme="http://yeyuwenxi.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="http://yeyuwenxi.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>51单片机最小系统pcb板</title>
    <link href="http://yeyuwenxi.github.io/2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/"/>
    <id>http://yeyuwenxi.github.io/2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/</id>
    <published>2021-06-03T05:34:47.000Z</published>
    <updated>2021-06-04T13:30:33.205Z</updated>
    
    <content type="html"><![CDATA[<p>最近画了块51单片机的最小系统，然后到捷配上把他打了出来。<br>下面直接放图</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_1.png" ></li><li>PCB正面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li><li>PCB背面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_3.jpg" width="60%" height="60%" style="transform:rotate(270deg)">总的来说，板子打的还可以，当然仍然避免不了某些小问题，系统库自己提供的电容封装不是很好，孔距有点大，焊盘有点小，另外布线也不是特别好。### 做个总结PCB画板还是一个比较靠经验的活，各种常见的封装，常见的库，这些都是要靠经验来一步步熟悉的。自己技术方向也不是做硬件，这方面估计也就浅尝辄止了，各种线宽，电磁兼容，信号完整性的东西应该也不会去学，画画板子，更多的还是拓展一下视野，平时有精力，还是应该多学一些软件方面的东西。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近画了块51单片机的最小系统，然后到捷配上把他打了出来。&lt;br&gt;下面直接放图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理图&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_1.png&quot; </summary>
      
    
    
    
    <category term="51单片机" scheme="http://yeyuwenxi.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
  </entry>
  
  <entry>
    <title>STM32实现矩阵键盘</title>
    <link href="http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/"/>
    <id>http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/</id>
    <published>2021-05-30T10:45:21.000Z</published>
    <updated>2021-05-30T10:58:45.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。<br>虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。<br>相比于51单片机，32的io口是要考虑io方向和io模式的。<br>自己参考网上的一个例子写的代码，没想到被误导了，将4个io口设为上拉输入，另外4个io口设为下拉输入，按键按下的时候先检测行，再检测列，没想到遇到了点莫名奇妙的问题，不管怎么接线，总有两行按键检测不到。<br>于是我怀疑是不是io模式的问题，上拉输入和下拉输入接在一起，产生的情况可能是无法预测的。<br>我修改io模式为4个下拉输入，另外4个推挽输出高电平之后，果然解决了这一问题。<br>对于某些细节方面的东西，有时候还是不能想当然地认为会怎么样啊。</p><h3 id="下附代码"><a href="#下附代码" class="headerlink" title="下附代码"></a>下附代码</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;低四位输出高，高四位下拉输入void KEY_Init1(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1;GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);   GPIO_SetBits(GPIOA,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);&#125; &#x2F;&#x2F;低四位下拉输入，高四位输出高void KEY_Init2(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1; GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);GPIO_SetBits(GPIOA,GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);&#125; &#x2F;&#x2F;函数名：扫描函数&#x2F;&#x2F;返回值：有效键值或-1&#x2F;&#x2F;功能：矩阵按键扫描，返回一个值short KeyPad_Scan(void)&#123;short num &#x3D; -1; &#x2F;&#x2F;保持按键值返回u16 readvalue &#x3D; 0;u16 re&#x3D;0;u16 re1&#x3D;0;u16 re2&#x3D;0;KEY_Init1();&#x2F;&#x2F;低4位引脚输出高，高4位引脚下拉输入readvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;&#x2F;&#x2F;保留低8位的值（PA7-PA0）if(readvalue !&#x3D; 0x000f) &#x2F;&#x2F;高4位引脚有一个被按下&#123;delay_ms(10);&#x2F;&#x2F;消抖10msreadvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;if(readvalue !&#x3D; 0x000f)&#123;re1 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re1 &amp;&#x3D; 0x00f0;  &#x2F;&#x2F;保留PA4-PA7的值KEY_Init2();  &#x2F;&#x2F;低4位引脚下拉输入，高4位输出高delay_ms(10);re2 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re2 &amp;&#x3D; 0x000f;&#x2F;&#x2F;保留PA0-PA3的值while((GPIO_ReadInputData(GPIOA)&amp;0x00ff)!&#x3D;0x00f0);&#x2F;&#x2F;等待按键松开re&#x3D;re1|re2;&#x2F;&#x2F;取或，就知道哪一行哪一列被按下啦switch(re)&#123;case 0x0011: num &#x3D; 12;break;  case 0x0012: num &#x3D; 8;break;  case 0x0014: num &#x3D; 4;break; case 0x0018: num &#x3D; 0;break;  case 0x0021: num &#x3D; 13;break;  case 0x0022: num &#x3D; 9;break; case 0x0024: num &#x3D; 5;break;  case 0x0028: num &#x3D; 1;break;  case 0x0041: num &#x3D; 14;break;  case 0x0042: num &#x3D; 10;break;  case 0x0044: num &#x3D; 6;break;  case 0x0048: num &#x3D; 2;break;  case 0x0081: num &#x3D; 15;break;  case 0x0082: num &#x3D; 11;break;  case 0x0084: num &#x3D; 7;break;  case 0x0088: num &#x3D; 3;break;  &#125;return num;&#125;&#125;return -1;&#125;int main()&#123;  delay_init();     &#x2F;&#x2F;延时函数初始化  NVIC_Configuration();  &#x2F;&#x2F;设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init();     &#x2F;&#x2F;LED端口初始化  &#x2F;&#x2F;OLED_Init();&#x2F;&#x2F;初始化OLED  &#x2F;&#x2F;OLED_Clear()  ;  uart_init(115200); &#x2F;&#x2F;串口初始化为115200while(1)&#123;short key&#x3D;0;key&#x3D;KeyPad_Scan();if(key!&#x3D;-1)&#123;printf(&quot;key&#x3D;&quot;);printf(&quot;%d\n&quot;,key);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/Daniel__Lai/article/details/108916185?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162237210816780271566581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162237210816780271566581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-8-108916185.first_rank_v2_pc_rank_v29&utm_term=STM32%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE&spm=1018.2226.3001.4187">STM32的矩阵键盘扫描及处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。&lt;br&gt;虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。&lt;br&gt;相比于51单片机，32的io口是要考虑io方向和io模式的</summary>
      
    
    
    
    <category term="STM32单片机" scheme="http://yeyuwenxi.github.io/categories/STM32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>第一次PCB打板</title>
    <link href="http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/"/>
    <id>http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/</id>
    <published>2021-05-28T08:41:34.000Z</published>
    <updated>2021-05-28T09:08:28.609Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下第一次打PCB板。<br>虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。<br>第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。<br>这次板子主要就是一个简单的流水灯和4x4的矩阵键盘，自己手动画了画四角按键的封装。<br>画完之后就向捷配上传了工程文件和生产文件，几天后收到了板子，没想到的是居然发了六块。<br>下面直接放图</p><ul><li>PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_1.jpg" width="60%" height="60%" style="transform:rotate(270deg)"   ></li><li>焊接成品<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li></ul><p>总的来说，这次打板还是比较成功的，当然也有一些小细节做的不是很好</p><ul><li>流水灯和矩阵按键的接口排针放在了两侧，相对来说还是放在一侧比较好。</li><li>矩阵键盘行与行之间间隙略大</li><li>布线不是特别好看</li><li>流水灯其实可以放8个的，比6个更好写程序</li></ul><p>另外本次打板没有铺铜，主要是没有确定的地，也没有哪个网络比其他网络要大很多。问了一些专业人士，简单的二层板不铺铜的话，也没有特别大的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下第一次打PCB板。&lt;br&gt;虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。&lt;br&gt;第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。&lt;br&gt;这次板</summary>
      
    
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/categories/PCB/"/>
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>esp32入门</title>
    <link href="http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/"/>
    <id>http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/</id>
    <published>2021-05-24T08:13:02.000Z</published>
    <updated>2021-06-04T14:18:42.115Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算做一个物联网的应用，买了块ESP32的开发板。</p><h3 id="ESP32的简单介绍"><a href="#ESP32的简单介绍" class="headerlink" title="ESP32的简单介绍"></a>ESP32的简单介绍</h3><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><p>ESP32支持使用arduino,espif等进行开发，可供使用的开发编辑器也有很多。<br>我们由简到难，先从最简单的开始，这里使用arduino IDE加上ESP32的arduino包进行开发。<br>开发环境搭建详见下文<br><a href="https://blog.csdn.net/dpjcn1990/article/details/94414983">ESP32 开发之旅① 走进ESP32的世界 安装开发环境</a></p><h3 id="烧录遇到的问题"><a href="#烧录遇到的问题" class="headerlink" title="烧录遇到的问题"></a>烧录遇到的问题</h3><p>安装完CP2102的驱动后，连到电脑上居然无法下载，串口时断时续的，后来采用自己的USB转TTL的烧录器成功地烧录了程序。<br>跟客服聊了聊，认为是CP2102的芯片坏了，客服直接发了块新的给我，而且说旧的不用退了。<br>这里强推一波优信电子！物美价廉，客服也很周到！</p><h3 id="arduino开发环境介绍"><a href="#arduino开发环境介绍" class="headerlink" title="arduino开发环境介绍"></a>arduino开发环境介绍</h3><p>arduino既有自己的硬件平台，又有一个基于arduino IDE的软件框架，arduino IDE属实不好用，连个最基本的函数查找都做不到，但arduino本身的框架封装了很多简单易用的函数，而且网上基于这一框架有很多有趣的开发实例，这里我们主要使用arduino的框架进行开发。</p><h3 id="开发板原理图"><a href="#开发板原理图" class="headerlink" title="开发板原理图"></a>开发板原理图</h3><p>最离谱的是，淘宝商家居然没有提供原理图，自己在网上搜索才找到了一张跟手上开发板一样的原理图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210604_1.png" ></p><h3 id="helloworld程序"><a href="#helloworld程序" class="headerlink" title="helloworld程序"></a>helloworld程序</h3><p>编写程序如下，编译完成后点击上传烧录到单片机中。<br><strong>注意:</strong> 烧录时屏幕下方出现connecting时按住boot按钮不放，直到烧录完成后松开boot按钮，此时，按一下复位按钮，程序就可以在单片机上正常运行了。<br>打开arduino IDE中的串口监视器，可以看到每秒都会收到一次单片机发送的helloworld.<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210524_1.png" ></p><h3 id="点灯程序"><a href="#点灯程序" class="headerlink" title="点灯程序"></a>点灯程序</h3><p>这块开发板上自带两个LED，其中红色的应该时电源指示灯，不受我们控制。<br>网上查询发现蓝色的LED，应该时接在GPIO2上，下面我们写一个驱动程序控制蓝色LED闪烁。<br>编写程序如下，并烧录到单片机中，可以看到LED正常闪烁。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;WiFi.h&gt;#define LED       2void setup() &#123;   pinMode(LED, OUTPUT);  &#125;void loop() &#123;  digitalWrite(LED, LOW);  delay(1000);  digitalWrite(LED, HIGH);  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算做一个物联网的应用，买了块ESP32的开发板。&lt;/p&gt;
&lt;h3 id=&quot;ESP32的简单介绍&quot;&gt;&lt;a href=&quot;#ESP32的简单介绍&quot; class=&quot;headerlink&quot; title=&quot;ESP32的简单介绍&quot;&gt;&lt;/a&gt;ESP32的简单介绍&lt;/h3&gt;&lt;h3 id</summary>
      
    
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="esp32" scheme="http://yeyuwenxi.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>开博客的初心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/</id>
    <published>2021-05-22T16:07:12.000Z</published>
    <updated>2021-05-22T16:18:27.528Z</updated>
    
    <content type="html"><![CDATA[<p>好多天没写博客了，今天开个新篇，反省一下。<br>做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。<br>这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。<br>动态的框架也尝试过typecho和wordpress。<br>折腾了一大堆，文章倒是好久没写了，不知不觉方向就走的有点偏了。<br>博客的框架，样式，音乐，其实并没有那么重要，只适合刚开始学框架图个新鲜罢了，内容才是博客的本质。<br>这么多框架，如果不是为了更好的写文章，而是沉迷于各种框架的细节，那就真的偏离自己的方向了。<br>所以接下来，还是明确一点，认真学技术，积极写文章。<br>平时少看各种无意义的东西，静下心来沉淀自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好多天没写博客了，今天开个新篇，反省一下。&lt;br&gt;做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。&lt;br&gt;这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。&lt;br&gt;动态的框架也尝试过typ</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云何降伏其心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/</id>
    <published>2021-05-17T15:30:54.000Z</published>
    <updated>2021-05-17T16:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p>人的欲望不满足就痛苦，满足了就无聊。<br>我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。<br>渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。<br>等到不渴的时候，再多的水放在自己面前也觉得乏味无比。<br>曾有一段时间，眼睛特别肿，眨下眼都难受，做什么事情都会想着眼睛，那时候才想起平时健康的时候生活有多么的快乐。<br>可等到眼睛好了，无所事事的时候又是枯燥和无聊，丝毫不记得曾经满心期待的快乐生活。<br>或许遗忘是人类的本能吧，总是不太长记性，痛苦的时候渴望平淡的生活，等生活平淡了又空虚无比，亟待刺激。<br>我们的心似乎总是躁动无比，安定不下来，总是需要寻求刺激来掩盖空虚，像是音乐，游戏，又或是需要痛苦来压制欲望，抽烟，喝酒，莫不是如此。</p><p>孔子云，食色性也。<br>生而为人，某些东西是刻在基因里的，谁也不可能做到无欲，所以一个很重要的问题就是如何面对自己的欲望。<br>吃好吃的，喝好喝的，玩好玩的，这都是我们的欲望，有欲也无可厚非，只要做到适度即可。</p><p>欲望可以适当满足，痛苦也可以合理规避，但还有一个问题确实很难解决的？<br>我们那什么来面对平凡的生活？那什么了面对内心的空虚和无聊？<br>金刚经有问，云何降伏其心？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人的欲望不满足就痛苦，满足了就无聊。&lt;br&gt;我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。&lt;br&gt;渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。&lt;br&gt;等到不渴的时候，再多的水放在自己面前也觉得乏味无比。&lt;br&gt;曾有一段时间</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈专题</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/</id>
    <published>2021-04-27T13:32:40.000Z</published>
    <updated>2021-05-03T09:21:33.612Z</updated>
    
    <content type="html"><![CDATA[<p>写篇文章，总结一下栈和队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。<br>主要包括压栈，出栈，查看栈顶元素三种操作。</p><h4 id="C语言数组实现顺序栈"><a href="#C语言数组实现顺序栈" class="headerlink" title="C语言数组实现顺序栈"></a>C语言数组实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;数组实现顺序栈typedef struct zhan &#123;char data[100];int top;&#125;zhan;void initzhan(zhan *a)&#123;a-&gt;top &#x3D; -1;&#125;void push(zhan* a, char b) &#123;a-&gt;data[++a-&gt;top] &#x3D; b;&#125;char pop(zhan* a) &#123;return a-&gt;data[a-&gt;top--];&#125;char gettop(zhan* a) &#123;return a-&gt;data[a-&gt;top];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言指针实现顺序栈"><a href="#C语言指针实现顺序栈" class="headerlink" title="C语言指针实现顺序栈"></a>C语言指针实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;指针实现顺序栈typedef struct stack &#123;int* top;int* base;&#125;stack;void initstack(stack* a) &#123;a-&gt;base &#x3D; (int*)malloc(sizeof(int)*100);&#x2F;&#x2F;最大空间为100a-&gt;top &#x3D; a-&gt;base;&#125;void pushstack(stack* a, int b)&#123;*a-&gt;top &#x3D; b;a-&gt;top++;&#125;int popstack(stack* a) &#123;a-&gt;top--;return *a-&gt;top;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言实现链栈"><a href="#C语言实现链栈" class="headerlink" title="C语言实现链栈"></a>C语言实现链栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;链栈的实现typedef struct stack &#123;int data;struct stack *next;&#125;stack;void initstack(stack*a) &#123;&#x2F;&#x2F;stack* p;&#x2F;&#x2F;a &#x3D; p &#x3D; (stack*)malloc(sizeof(stack));&#x2F;&#x2F;a-&gt;next &#x3D; NULL;&#125;void pushstack(stack* a,int b) &#123;stack* p;p &#x3D; (stack*)malloc(sizeof(stack));p-&gt;data &#x3D; b;p-&gt;next &#x3D; a-&gt;next;a-&gt;next &#x3D; p;&#125;int popstack(stack * a)&#123;stack* p;int b;p &#x3D; a-&gt;next;b&#x3D; p-&gt;data;a-&gt;next &#x3D; p-&gt;next;free(p);return b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-的栈"><a href="#C-的栈" class="headerlink" title="C++的栈"></a>C++的栈</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;stack&gt;初始化出栈压栈取栈顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="C-的队列"><a href="#C-的队列" class="headerlink" title="C++的队列"></a>C++的队列</h4><h3 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h3><p>来自leetcode的一道题目。<br>挺有启发性的，如何用两个队列实现一个栈。</p><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    queue&lt;int&gt; queue1;    queue&lt;int&gt; queue2;    MyStack() &#123;         &#125;        &#x2F;** Push element x onto stack. *&#x2F;    void push(int x) &#123;       &#x2F;&#x2F;queue2做辅助队列，用来翻转queue1,同理，一个队列也可以实现       while(!queue1.empty())&#123;        int a&#x3D;queue1.front();        queue1.pop();        queue2.push(a);      &#125;      queue1.push(x);      while(!queue2.empty())&#123;        int a&#x3D;queue2.front();        queue2.pop();        queue1.push(a);      &#125;    &#125;        &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;    int pop() &#123;     int a&#x3D; queue1.front();     queue1.pop();     return a;    &#125;        &#x2F;** Get the top element. *&#x2F;    int top() &#123;     return queue1.front();    &#125;        &#x2F;** Returns whether the stack is empty. *&#x2F;    bool empty() &#123;   return queue1.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>来自leetcode的另一个题目，用两个栈实现一个队列。</p><pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    stack&lt;int&gt; a;    stack&lt;int&gt; b;    MyQueue() &#123;    &#125;        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) &#123;     while(!a.empty())&#123;         int c&#x3D;a.top();         a.pop();         b.push(c);     &#125;     a.push(x);     while(!b.empty())&#123;         int c&#x3D;b.top();         b.pop();         a.push(c);     &#125;    &#125;        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() &#123;        int c&#x3D;a.top();        a.pop();          return c ;    &#125;        &#x2F;** Get the front element. *&#x2F;    int peek() &#123;                 return a.top();    &#125;        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() &#123;      return a.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写篇文章，总结一下栈和队列&lt;/p&gt;
&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。&lt;br&gt;主要包括压栈，出栈，查看栈顶元</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="队列" scheme="http://yeyuwenxi.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://yeyuwenxi.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/</id>
    <published>2021-04-27T13:29:49.000Z</published>
    <updated>2021-05-17T07:19:26.471Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些常用的排序算法。</p><p>先定义一个数组用来进行接下来的排序</p><pre class="line-numbers language-none"><code class="language-none">int num[] &#x3D; &#123; 4,9,7,15,67,89,97,123,468,12,34,76,8,9,4,1,80,100 &#125;;&#x2F;&#x2F;获取数组长度int length;length &#x3D; sizeof(num) &#x2F; sizeof(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下皆为从小到大的排序</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length - 1; i++) &#123;for (int j &#x3D; 0; j &lt; length - 1-i; j++) &#123;if (num[j] &gt; num[j + 1]) &#123;int t &#x3D; num[j];num[j] &#x3D; num[j + 1];num[j + 1] &#x3D; t;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length; i++) &#123;int min &#x3D; num[i];for (int j &#x3D; i; j &lt; length; j++) &#123;if (min &gt; num[j]) &#123;int t &#x3D; min;min &#x3D; num[j];num[j] &#x3D; t;&#125;&#125;num[i] &#x3D; min;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;先定义一个交换函数void exchange(int* p, int* q) &#123;int temp &#x3D; *p;*p &#x3D; *q;*q &#x3D; temp;&#125;int quaipai(int left, int right) &#123;&#x2F;&#x2F;双指针相遇，排序结束if (left &gt;&#x3D; right) &#123;return 0;&#125;int i,j, t;&#x2F;&#x2F;左右指针及基准i &#x3D; left;j &#x3D; right;t &#x3D; num[left];&#x2F;&#x2F;移动函数while (i !&#x3D; j) &#123;while (i &lt; j &amp;&amp; num[j] &gt;&#x3D; t) &#123;j--;&#125;exchange(&amp;num[i], &amp;num[j]);        while (i &lt; j &amp;&amp; num[i] &lt;&#x3D; t) &#123;i++;                                     &#125;exchange(&amp;num[i], &amp;num[j]);&#125;&#x2F;&#x2F;递归此过程quaipai(i + 1, right);quaipai(left, i - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一些常用的排序算法。&lt;/p&gt;
&lt;p&gt;先定义一个数组用来进行接下来的排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;int num[] &amp;#x3D; &amp;#123; 4,9</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ STL学习笔记</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/</id>
    <published>2021-04-27T13:02:25.000Z</published>
    <updated>2021-05-03T09:20:56.216Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。<br>Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。<br>写个帖子，做一些记录。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>见得最多的容器，还是数vector.<br>vector可以看做是一个动态的数组。</p><ul><li>常见用法<br>初始化<br>vector<int> a;<br>a.size();<br>a.empty();</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue<int> a;<br>a.pop();<br>a.push(x);<br>a.front();<br>a.empty();<br>a.size();</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack<int> a;<br>a.pop();<br>a.push(x);<br>a.top();<br>a.empty();<br>a.size();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。&lt;br&gt;Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。&lt;br&gt;写个帖子，做一些记录。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://yeyuwenxi.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>esp8266通过串口发送http请求</title>
    <link href="http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/"/>
    <id>http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/</id>
    <published>2021-04-26T01:31:57.000Z</published>
    <updated>2021-05-03T09:18:14.755Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。<br>仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。<br>不得不说，计算机网络的一些知识好久不用都忘的差不多了，有些东西果然还是要在实践中加强认识。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><h4 id="http请求头"><a href="#http请求头" class="headerlink" title="http请求头"></a>http请求头</h4><p>请求头包括四个部分：<br>请求行<br>请求首部<br>空行<br>请求正文</p><h4 id="http返回头"><a href="#http返回头" class="headerlink" title="http返回头"></a>http返回头</h4><p>返回头同样包括四个部分：<br>状态行<br>消息报头<br>空行<br>响应正文</p><h3 id="通过网络调试助手测试"><a href="#通过网络调试助手测试" class="headerlink" title="通过网络调试助手测试"></a>通过网络调试助手测试</h3><p>我们测试使用的api如下<br><a href="http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8">http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8</a><br>这是果创云提供的一个天气查询的接口，通过发送get请求，可以得到对应城市的天气，返回的数据类型为json格式。<br>我们先使用浏览器访问一下这个接口<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_1.png" ><br>由于网络调试助手的限制，我们必须要知道api的服务器地址和端口号<br>在浏览器上点击检查网页，在network标签下的header标签中可以找到我们想要的信息</p><p>通过网络调试助手，输入刚刚查到的ip和端口号，建立一个tcp连接<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_2.png" ><br>发送相应格式的请求，可以看到，我们已经收到了api接口返回的数据<br>（这里由于调试助手编码格式的问题，中文会显示乱码）</p><h3 id="esp8266通过TCP透传发送http请求"><a href="#esp8266通过TCP透传发送http请求" class="headerlink" title="esp8266通过TCP透传发送http请求"></a>esp8266通过TCP透传发送http请求</h3><p>调试时遇到了挺大的bug,模块的硬件电路出了点莫名其妙的问题，串口连接模块后，发送任何指令都没有反应，后来拿电压表测了一下，模块上电后CH_PD居然是低电平，于是又自己把CH_PD拉到高电平，解决了这一问题。<br>esp8266连接串口之后，依次发送如下指令：<br><code>AT+RST</code><br>//复位模块<br><code>AT+CWMODE=1</code><br>//进入STA模式<br><code>AT+RST</code><br>//复位生效上一条命令<br><code>AT+CWJAP=”note”,”123456789” </code><br>//连接到wifi<br><code>AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.1.115&quot;,8080</code><br>//连接到tcp服务器<br><code>AT+CIPMODE=1</code><br>//开启透传模式<br><code>AT+CIPSEND</code><br>//进入透传</p><p>进入透传后，发送以下数据<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_3.png" ><br>可以看到，我们成功地收到了服务器返回的接口数据<br>（由于电脑编码格式问题，此处存在乱码）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。&lt;br&gt;仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。&lt;br&gt;</summary>
      
    
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/categories/esp8266/"/>
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>Android实现mqtt客户端</title>
    <link href="http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/</id>
    <published>2021-04-25T14:26:16.000Z</published>
    <updated>2021-04-25T15:16:46.513Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。</p><h3 id="在gradle中添加依赖"><a href="#在gradle中添加依赖" class="headerlink" title="在gradle中添加依赖"></a>在gradle中添加依赖</h3><pre class="line-numbers language-none"><code class="language-none">implementation &#39;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0&#39;implementation &#39;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="添加相关的权限"><a href="#添加相关的权限" class="headerlink" title="添加相关的权限"></a>添加相关的权限</h3><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.WAKE_LOCK&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p><code>&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot;&gt;&lt;/service&gt;</code></p><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><ul><li>xml<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;zhuti&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的主题&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;neirong&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的内容&quot;        &#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;button&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;发送&quot;        &#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;textView&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>MainActivity.java<pre class="line-numbers language-none"><code class="language-none">import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;public class MainActivity extends AppCompatActivity &#123;    EditText zhuti;    EditText neirong;    Button fasong;    TextView jieshou;    MqttClient client;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F;App lianjie&#x3D;new App();        String subTopic &#x3D; &quot;test&quot;;        String pubTopic &#x3D; &quot;test&quot;;        String content &#x3D; &quot;Hello World&quot;;        int qos &#x3D; 2;        String broker &#x3D; &quot;tcp:&#x2F;&#x2F;49.235.68.28:1883&quot;;        String clientId &#x3D; &quot;emqx_test&quot;;        MemoryPersistence persistence &#x3D; new MemoryPersistence();        Log.i(&quot;aaa&quot;, &quot;运行中&quot;);        zhuti&#x3D;findViewById(R.id.zhuti);        neirong&#x3D;findViewById(R.id.neirong);        fasong&#x3D;findViewById(R.id.button);        jieshou&#x3D;findViewById(R.id.textView);        try &#123;             client &#x3D; new MqttClient(broker, clientId, persistence);            &#x2F;&#x2F; MQTT 连接选项            MqttConnectOptions connOpts &#x3D; new MqttConnectOptions();            connOpts.setUserName(&quot;emqx_test&quot;);            connOpts.setPassword(&quot;emqx_test_password&quot;.toCharArray());            &#x2F;&#x2F; 保留会话            connOpts.setCleanSession(true);            &#x2F;&#x2F; 设置回调            client.setCallback(new OnMessageCallback1());            &#x2F;&#x2F; 建立连接            Log.i(&quot;abc&quot;, &quot;Connecting to broker: &quot; + broker);            client.connect(connOpts);            Log.i(&quot;bcd&quot;, &quot;Connected&quot;);            Log.i(&quot;cde&quot;, &quot;Publishing message: &quot; + content);            &#x2F;&#x2F; 订阅            client.subscribe(subTopic);            &#x2F;&#x2F; 消息发布所需参数            MqttMessage  message &#x3D; new MqttMessage(content.getBytes());            message.setQos(qos);            client.publish(pubTopic, message);            Log.i(&quot;def&quot;, &quot;Message published&quot;);            &#x2F;&#x2F;client.disconnect();            &#x2F;&#x2F; Log.i(&quot;efg&quot;,&quot;Disconnected&quot;);            &#x2F;&#x2F; client.close();            &#x2F;&#x2F;System.exit(0);        &#125; catch (MqttException me) &#123;            Log.i(&quot;1&quot;, &quot;reason &quot; + me.getReasonCode());            Log.i(&quot;2&quot;, &quot;msg &quot; + me.getMessage());            Log.i(&quot;3&quot;, &quot;loc &quot; + me.getLocalizedMessage());            Log.i(&quot;4&quot;, &quot;cause &quot; + me.getCause());            Log.i(&quot;5&quot;, &quot;excep &quot; + me);            me.printStackTrace();        &#125;        fasong.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;            if(zhuti.getText().toString().equals(&quot;&quot;)||neirong.getText().toString().equals(&quot;&quot;))&#123;                Toast.makeText(MainActivity.this, &quot;请输入主题和内容&quot;, Toast.LENGTH_SHORT).show();            &#125;            else&#123;                try &#123;                    MqttMessage  message &#x3D; new MqttMessage(neirong.getText().toString().getBytes());                    message.setQos(qos);                    client.publish(zhuti.getText().toString(), message);                &#125; catch (MqttException e) &#123;                    e.printStackTrace();                &#125;&#125;            &#125;        &#125;);    &#125;&#x2F;&#x2F;回调函数 class OnMessageCallback1 implements MqttCallback &#123;    public void connectionLost(Throwable cause) &#123;        &#x2F;&#x2F; 连接丢失后，一般在这里面进行重连        Log.i(&quot;duankai&quot;,&quot;连接断开，可以做重连&quot;);    &#125;    public void messageArrived(String topic, MqttMessage message) throws Exception &#123;        &#x2F;&#x2F; subscribe后得到的消息会执行到这里面        Log.i(&quot;xiaoxi&quot;,&quot;接收消息主题:&quot; + topic);        Log.i(&quot;qos&quot;,&quot;接收消息Qos:&quot; + message.getQos());        Log.i(&quot;neirong&quot;,&quot;接收消息内容:&quot; + new String(message.getPayload()));        runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以        &#123;            public void run()            &#123;                &#x2F;&#x2F; TODO Auto-generated method stub               &#x2F;&#x2F; Toast.makeText(MainActivity.this, new String(message.getPayload()), Toast.LENGTH_SHORT).show();               jieshou.append(new String(message.getPayload())+&quot;\n&quot;);            &#125;        &#125;);    &#125;    public void deliveryComplete(IMqttDeliveryToken token) &#123;        Log.i(&quot;delivery&quot;,&quot;deliveryComplete---------&quot; + token.isComplete());    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>模拟器与真机均测试通过<br>以下是模拟器测试的图片<br>app默认订阅了test主题，发送消息的主题可自己设置</li><li>app<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_7.png" width="60%" height="60%"></li><li>websocket(一个在线的mqtt客户端)<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_8.png" ></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/jqnl/p/12660824.html">MQTT协议实现Android中的消息收发</a><br><a href="https://docs.emqx.cn/broker/v4.3/development/java.html">EMQX开发文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。&lt;/p&gt;
&lt;h3 id=&quot;在gradle中添加依赖&quot;&gt;&lt;a href=&quot;#在gradle中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;在gradle中添加依赖&quot;&gt;&lt;/a&gt;在gradle中</summary>
      
    
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/categories/mqtt/"/>
    
    
    <category term="Android" scheme="http://yeyuwenxi.github.io/tags/Android/"/>
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/tags/mqtt/"/>
    
  </entry>
  
</feed>
