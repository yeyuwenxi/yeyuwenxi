<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜雨闻曦</title>
  
  <subtitle>爱我所爱，行我所行</subtitle>
  <link href="http://yeyuwenxi.github.io/atom.xml" rel="self"/>
  
  <link href="http://yeyuwenxi.github.io/"/>
  <updated>2021-05-30T10:58:45.486Z</updated>
  <id>http://yeyuwenxi.github.io/</id>
  
  <author>
    <name>pcl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32实现矩阵键盘</title>
    <link href="http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/"/>
    <id>http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/</id>
    <published>2021-05-30T10:45:21.000Z</published>
    <updated>2021-05-30T10:58:45.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。<br>虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。<br>相比于51单片机，32的io口是要考虑io方向和io模式的。<br>自己参考网上的一个例子写的代码，没想到被误导了，将4个io口设为上拉输入，另外4个io口设为下拉输入，按键按下的时候先检测行，再检测列，没想到遇到了点莫名奇妙的问题，不管怎么接线，总有两行按键检测不到。<br>于是我怀疑是不是io模式的问题，上拉输入和下拉输入接在一起，产生的情况可能是无法预测的。<br>我修改io模式为4个下拉输入，另外4个推挽输出高电平之后，果然解决了这一问题。<br>对于某些细节方面的东西，有时候还是不能想当然地认为会怎么样啊。</p><h3 id="下附代码"><a href="#下附代码" class="headerlink" title="下附代码"></a>下附代码</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;低四位输出高，高四位下拉输入void KEY_Init1(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1;GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);   GPIO_SetBits(GPIOA,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);&#125; &#x2F;&#x2F;低四位下拉输入，高四位输出高void KEY_Init2(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1; GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);GPIO_SetBits(GPIOA,GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);&#125; &#x2F;&#x2F;函数名：扫描函数&#x2F;&#x2F;返回值：有效键值或-1&#x2F;&#x2F;功能：矩阵按键扫描，返回一个值short KeyPad_Scan(void)&#123;short num &#x3D; -1; &#x2F;&#x2F;保持按键值返回u16 readvalue &#x3D; 0;u16 re&#x3D;0;u16 re1&#x3D;0;u16 re2&#x3D;0;KEY_Init1();&#x2F;&#x2F;低4位引脚输出高，高4位引脚下拉输入readvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;&#x2F;&#x2F;保留低8位的值（PA7-PA0）if(readvalue !&#x3D; 0x000f) &#x2F;&#x2F;高4位引脚有一个被按下&#123;delay_ms(10);&#x2F;&#x2F;消抖10msreadvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;if(readvalue !&#x3D; 0x000f)&#123;re1 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re1 &amp;&#x3D; 0x00f0;  &#x2F;&#x2F;保留PA4-PA7的值KEY_Init2();  &#x2F;&#x2F;低4位引脚下拉输入，高4位输出高delay_ms(10);re2 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re2 &amp;&#x3D; 0x000f;&#x2F;&#x2F;保留PA0-PA3的值while((GPIO_ReadInputData(GPIOA)&amp;0x00ff)!&#x3D;0x00f0);&#x2F;&#x2F;等待按键松开re&#x3D;re1|re2;&#x2F;&#x2F;取或，就知道哪一行哪一列被按下啦switch(re)&#123;case 0x0011: num &#x3D; 12;break;  case 0x0012: num &#x3D; 8;break;  case 0x0014: num &#x3D; 4;break; case 0x0018: num &#x3D; 0;break;  case 0x0021: num &#x3D; 13;break;  case 0x0022: num &#x3D; 9;break; case 0x0024: num &#x3D; 5;break;  case 0x0028: num &#x3D; 1;break;  case 0x0041: num &#x3D; 14;break;  case 0x0042: num &#x3D; 10;break;  case 0x0044: num &#x3D; 6;break;  case 0x0048: num &#x3D; 2;break;  case 0x0081: num &#x3D; 15;break;  case 0x0082: num &#x3D; 11;break;  case 0x0084: num &#x3D; 7;break;  case 0x0088: num &#x3D; 3;break;  &#125;return num;&#125;&#125;return -1;&#125;int main()&#123;  delay_init();     &#x2F;&#x2F;延时函数初始化  NVIC_Configuration();  &#x2F;&#x2F;设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init();     &#x2F;&#x2F;LED端口初始化  &#x2F;&#x2F;OLED_Init();&#x2F;&#x2F;初始化OLED  &#x2F;&#x2F;OLED_Clear()  ;  uart_init(115200); &#x2F;&#x2F;串口初始化为115200while(1)&#123;short key&#x3D;0;key&#x3D;KeyPad_Scan();if(key!&#x3D;-1)&#123;printf(&quot;key&#x3D;&quot;);printf(&quot;%d\n&quot;,key);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/Daniel__Lai/article/details/108916185?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162237210816780271566581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162237210816780271566581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-8-108916185.first_rank_v2_pc_rank_v29&utm_term=STM32%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE&spm=1018.2226.3001.4187">STM32的矩阵键盘扫描及处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。&lt;br&gt;虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。&lt;br&gt;相比于51单片机，32的io口是要考虑io方向和io模式的</summary>
      
    
    
    
    <category term="STM32单片机" scheme="http://yeyuwenxi.github.io/categories/STM32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>第一次PCB打板</title>
    <link href="http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/"/>
    <id>http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/</id>
    <published>2021-05-28T08:41:34.000Z</published>
    <updated>2021-05-28T09:08:28.609Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下第一次打PCB板。<br>虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。<br>第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。<br>这次板子主要就是一个简单的流水灯和4x4的矩阵键盘，自己手动画了画四角按键的封装。<br>画完之后就向捷配上传了工程文件和生产文件，几天后收到了板子，没想到的是居然发了六块。<br>下面直接放图</p><ul><li>PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_1.jpg" width="60%" height="60%" style="transform:rotate(270deg)"   ></li><li>焊接成品<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li></ul><p>总的来说，这次打板还是比较成功的，当然也有一些小细节做的不是很好</p><ul><li>流水灯和矩阵按键的接口排针放在了两侧，相对来说还是放在一侧比较好。</li><li>矩阵键盘行与行之间间隙略大</li><li>布线不是特别好看</li><li>流水灯其实可以放8个的，比6个更好写程序</li></ul><p>另外本次打板没有铺铜，主要是没有确定的地，也没有哪个网络比其他网络要大很多。问了一些专业人士，简单的二层板不铺铜的话，也没有特别大的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下第一次打PCB板。&lt;br&gt;虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。&lt;br&gt;第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。&lt;br&gt;这次板</summary>
      
    
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/categories/PCB/"/>
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>esp32入门</title>
    <link href="http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/"/>
    <id>http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/</id>
    <published>2021-05-24T08:13:02.000Z</published>
    <updated>2021-05-24T08:57:41.742Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算做一个物联网的应用，买了块ESP32的开发板。</p><h3 id="ESP32的简单介绍"><a href="#ESP32的简单介绍" class="headerlink" title="ESP32的简单介绍"></a>ESP32的简单介绍</h3><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><p>ESP32支持使用arduino,espif等开发平台进行开发。<br>我们由简到难，先从最简单的开始，这里使用arduino IDE加上ESP32的arduino包进行开发。<br>开发环境搭建详见下文<br><a href="https://blog.csdn.net/dpjcn1990/article/details/94414983">ESP32 开发之旅① 走进ESP32的世界 安装开发环境</a></p><h3 id="烧录遇到的问题"><a href="#烧录遇到的问题" class="headerlink" title="烧录遇到的问题"></a>烧录遇到的问题</h3><h3 id="arduino开发环境介绍"><a href="#arduino开发环境介绍" class="headerlink" title="arduino开发环境介绍"></a>arduino开发环境介绍</h3><h3 id="helloworld程序"><a href="#helloworld程序" class="headerlink" title="helloworld程序"></a>helloworld程序</h3><p>编写程序如下，编译完成后点击上传烧录到单片机中。<br><strong>注意:</strong> 烧录时屏幕下方出现connecting时按住boot按钮不放，直到烧录完成后松开boot按钮，此时，按一下复位按钮，程序就可以在单片机上正常运行了。<br>打开arduino IDE中的串口监视器，可以看到每秒都会收到一次单片机发送的helloworld.<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210524_1.png" ></p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><h3 id="点灯程序"><a href="#点灯程序" class="headerlink" title="点灯程序"></a>点灯程序</h3><p>这块开发板上自带两个LED，其中红色的应该时电源指示灯，不受我们控制。<br>网上查询发现蓝色的LED，应该时接在GPIO2上，下面我们写一个驱动程序控制蓝色LED闪烁。<br>编写程序如下，并烧录到单片机中，可以看到LED正常闪烁。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;WiFi.h&gt;#define LED       2void setup() &#123;   pinMode(LED, OUTPUT);  &#125;void loop() &#123;  digitalWrite(LED, LOW);  delay(1000);  digitalWrite(LED, HIGH);  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算做一个物联网的应用，买了块ESP32的开发板。&lt;/p&gt;
&lt;h3 id=&quot;ESP32的简单介绍&quot;&gt;&lt;a href=&quot;#ESP32的简单介绍&quot; class=&quot;headerlink&quot; title=&quot;ESP32的简单介绍&quot;&gt;&lt;/a&gt;ESP32的简单介绍&lt;/h3&gt;&lt;h3 id</summary>
      
    
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="esp32" scheme="http://yeyuwenxi.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>开博客的初心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/</id>
    <published>2021-05-22T16:07:12.000Z</published>
    <updated>2021-05-22T16:18:27.528Z</updated>
    
    <content type="html"><![CDATA[<p>好多天没写博客了，今天开个新篇，反省一下。<br>做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。<br>这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。<br>动态的框架也尝试过typecho和wordpress。<br>折腾了一大堆，文章倒是好久没写了，不知不觉方向就走的有点偏了。<br>博客的框架，样式，音乐，其实并没有那么重要，只适合刚开始学框架图个新鲜罢了，内容才是博客的本质。<br>这么多框架，如果不是为了更好的写文章，而是沉迷于各种框架的细节，那就真的偏离自己的方向了。<br>所以接下来，还是明确一点，认真学技术，积极写文章。<br>平时少看各种无意义的东西，静下心来沉淀自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好多天没写博客了，今天开个新篇，反省一下。&lt;br&gt;做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。&lt;br&gt;这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。&lt;br&gt;动态的框架也尝试过typ</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云何降伏其心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/</id>
    <published>2021-05-17T15:30:54.000Z</published>
    <updated>2021-05-17T16:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p>人的欲望不满足就痛苦，满足了就无聊。<br>我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。<br>渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。<br>等到不渴的时候，再多的水放在自己面前也觉得乏味无比。<br>曾有一段时间，眼睛特别肿，眨下眼都难受，做什么事情都会想着眼睛，那时候才想起平时健康的时候生活有多么的快乐。<br>可等到眼睛好了，无所事事的时候又是枯燥和无聊，丝毫不记得曾经满心期待的快乐生活。<br>或许遗忘是人类的本能吧，总是不太长记性，痛苦的时候渴望平淡的生活，等生活平淡了又空虚无比，亟待刺激。<br>我们的心似乎总是躁动无比，安定不下来，总是需要寻求刺激来掩盖空虚，像是音乐，游戏，又或是需要痛苦来压制欲望，抽烟，喝酒，莫不是如此。</p><p>孔子云，食色性也。<br>生而为人，某些东西是刻在基因里的，谁也不可能做到无欲，所以一个很重要的问题就是如何面对自己的欲望。<br>吃好吃的，喝好喝的，玩好玩的，这都是我们的欲望，有欲也无可厚非，只要做到适度即可。</p><p>欲望可以适当满足，痛苦也可以合理规避，但还有一个问题确实很难解决的？<br>我们那什么来面对平凡的生活？那什么了面对内心的空虚和无聊？<br>金刚经有问，云何降伏其心？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人的欲望不满足就痛苦，满足了就无聊。&lt;br&gt;我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。&lt;br&gt;渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。&lt;br&gt;等到不渴的时候，再多的水放在自己面前也觉得乏味无比。&lt;br&gt;曾有一段时间</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈专题</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/</id>
    <published>2021-04-27T13:32:40.000Z</published>
    <updated>2021-05-03T09:21:33.612Z</updated>
    
    <content type="html"><![CDATA[<p>写篇文章，总结一下栈和队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。<br>主要包括压栈，出栈，查看栈顶元素三种操作。</p><h4 id="C语言数组实现顺序栈"><a href="#C语言数组实现顺序栈" class="headerlink" title="C语言数组实现顺序栈"></a>C语言数组实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;数组实现顺序栈typedef struct zhan &#123;char data[100];int top;&#125;zhan;void initzhan(zhan *a)&#123;a-&gt;top &#x3D; -1;&#125;void push(zhan* a, char b) &#123;a-&gt;data[++a-&gt;top] &#x3D; b;&#125;char pop(zhan* a) &#123;return a-&gt;data[a-&gt;top--];&#125;char gettop(zhan* a) &#123;return a-&gt;data[a-&gt;top];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言指针实现顺序栈"><a href="#C语言指针实现顺序栈" class="headerlink" title="C语言指针实现顺序栈"></a>C语言指针实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;指针实现顺序栈typedef struct stack &#123;int* top;int* base;&#125;stack;void initstack(stack* a) &#123;a-&gt;base &#x3D; (int*)malloc(sizeof(int)*100);&#x2F;&#x2F;最大空间为100a-&gt;top &#x3D; a-&gt;base;&#125;void pushstack(stack* a, int b)&#123;*a-&gt;top &#x3D; b;a-&gt;top++;&#125;int popstack(stack* a) &#123;a-&gt;top--;return *a-&gt;top;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言实现链栈"><a href="#C语言实现链栈" class="headerlink" title="C语言实现链栈"></a>C语言实现链栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;链栈的实现typedef struct stack &#123;int data;struct stack *next;&#125;stack;void initstack(stack*a) &#123;&#x2F;&#x2F;stack* p;&#x2F;&#x2F;a &#x3D; p &#x3D; (stack*)malloc(sizeof(stack));&#x2F;&#x2F;a-&gt;next &#x3D; NULL;&#125;void pushstack(stack* a,int b) &#123;stack* p;p &#x3D; (stack*)malloc(sizeof(stack));p-&gt;data &#x3D; b;p-&gt;next &#x3D; a-&gt;next;a-&gt;next &#x3D; p;&#125;int popstack(stack * a)&#123;stack* p;int b;p &#x3D; a-&gt;next;b&#x3D; p-&gt;data;a-&gt;next &#x3D; p-&gt;next;free(p);return b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-的栈"><a href="#C-的栈" class="headerlink" title="C++的栈"></a>C++的栈</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;stack&gt;初始化出栈压栈取栈顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="C-的队列"><a href="#C-的队列" class="headerlink" title="C++的队列"></a>C++的队列</h4><h3 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h3><p>来自leetcode的一道题目。<br>挺有启发性的，如何用两个队列实现一个栈。</p><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    queue&lt;int&gt; queue1;    queue&lt;int&gt; queue2;    MyStack() &#123;         &#125;        &#x2F;** Push element x onto stack. *&#x2F;    void push(int x) &#123;       &#x2F;&#x2F;queue2做辅助队列，用来翻转queue1,同理，一个队列也可以实现       while(!queue1.empty())&#123;        int a&#x3D;queue1.front();        queue1.pop();        queue2.push(a);      &#125;      queue1.push(x);      while(!queue2.empty())&#123;        int a&#x3D;queue2.front();        queue2.pop();        queue1.push(a);      &#125;    &#125;        &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;    int pop() &#123;     int a&#x3D; queue1.front();     queue1.pop();     return a;    &#125;        &#x2F;** Get the top element. *&#x2F;    int top() &#123;     return queue1.front();    &#125;        &#x2F;** Returns whether the stack is empty. *&#x2F;    bool empty() &#123;   return queue1.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>来自leetcode的另一个题目，用两个栈实现一个队列。</p><pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    stack&lt;int&gt; a;    stack&lt;int&gt; b;    MyQueue() &#123;    &#125;        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) &#123;     while(!a.empty())&#123;         int c&#x3D;a.top();         a.pop();         b.push(c);     &#125;     a.push(x);     while(!b.empty())&#123;         int c&#x3D;b.top();         b.pop();         a.push(c);     &#125;    &#125;        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() &#123;        int c&#x3D;a.top();        a.pop();          return c ;    &#125;        &#x2F;** Get the front element. *&#x2F;    int peek() &#123;                 return a.top();    &#125;        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() &#123;      return a.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写篇文章，总结一下栈和队列&lt;/p&gt;
&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。&lt;br&gt;主要包括压栈，出栈，查看栈顶元</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="队列" scheme="http://yeyuwenxi.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://yeyuwenxi.github.io/tags/%E6%A0%88/"/>
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/</id>
    <published>2021-04-27T13:29:49.000Z</published>
    <updated>2021-05-17T07:19:26.471Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些常用的排序算法。</p><p>先定义一个数组用来进行接下来的排序</p><pre class="line-numbers language-none"><code class="language-none">int num[] &#x3D; &#123; 4,9,7,15,67,89,97,123,468,12,34,76,8,9,4,1,80,100 &#125;;&#x2F;&#x2F;获取数组长度int length;length &#x3D; sizeof(num) &#x2F; sizeof(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下皆为从小到大的排序</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length - 1; i++) &#123;for (int j &#x3D; 0; j &lt; length - 1-i; j++) &#123;if (num[j] &gt; num[j + 1]) &#123;int t &#x3D; num[j];num[j] &#x3D; num[j + 1];num[j + 1] &#x3D; t;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length; i++) &#123;int min &#x3D; num[i];for (int j &#x3D; i; j &lt; length; j++) &#123;if (min &gt; num[j]) &#123;int t &#x3D; min;min &#x3D; num[j];num[j] &#x3D; t;&#125;&#125;num[i] &#x3D; min;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;先定义一个交换函数void exchange(int* p, int* q) &#123;int temp &#x3D; *p;*p &#x3D; *q;*q &#x3D; temp;&#125;int quaipai(int left, int right) &#123;&#x2F;&#x2F;双指针相遇，排序结束if (left &gt;&#x3D; right) &#123;return 0;&#125;int i,j, t;&#x2F;&#x2F;左右指针及基准i &#x3D; left;j &#x3D; right;t &#x3D; num[left];&#x2F;&#x2F;移动函数while (i !&#x3D; j) &#123;while (i &lt; j &amp;&amp; num[j] &gt;&#x3D; t) &#123;j--;&#125;exchange(&amp;num[i], &amp;num[j]);        while (i &lt; j &amp;&amp; num[i] &lt;&#x3D; t) &#123;i++;                                     &#125;exchange(&amp;num[i], &amp;num[j]);&#125;&#x2F;&#x2F;递归此过程quaipai(i + 1, right);quaipai(left, i - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一些常用的排序算法。&lt;/p&gt;
&lt;p&gt;先定义一个数组用来进行接下来的排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;int num[] &amp;#x3D; &amp;#123; 4,9</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ STL学习笔记</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/</id>
    <published>2021-04-27T13:02:25.000Z</published>
    <updated>2021-05-03T09:20:56.216Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。<br>Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。<br>写个帖子，做一些记录。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>见得最多的容器，还是数vector.<br>vector可以看做是一个动态的数组。</p><ul><li>常见用法<br>初始化<br>vector<int> a;<br>a.size();<br>a.empty();</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue<int> a;<br>a.pop();<br>a.push(x);<br>a.front();<br>a.empty();<br>a.size();</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack<int> a;<br>a.pop();<br>a.push(x);<br>a.top();<br>a.empty();<br>a.size();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。&lt;br&gt;Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。&lt;br&gt;写个帖子，做一些记录。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://yeyuwenxi.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>esp8266通过串口发送http请求</title>
    <link href="http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/"/>
    <id>http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/</id>
    <published>2021-04-26T01:31:57.000Z</published>
    <updated>2021-05-03T09:18:14.755Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。<br>仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。<br>不得不说，计算机网络的一些知识好久不用都忘的差不多了，有些东西果然还是要在实践中加强认识。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><h4 id="http请求头"><a href="#http请求头" class="headerlink" title="http请求头"></a>http请求头</h4><p>请求头包括四个部分：<br>请求行<br>请求首部<br>空行<br>请求正文</p><h4 id="http返回头"><a href="#http返回头" class="headerlink" title="http返回头"></a>http返回头</h4><p>返回头同样包括四个部分：<br>状态行<br>消息报头<br>空行<br>响应正文</p><h3 id="通过网络调试助手测试"><a href="#通过网络调试助手测试" class="headerlink" title="通过网络调试助手测试"></a>通过网络调试助手测试</h3><p>我们测试使用的api如下<br><a href="http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8">http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8</a><br>这是果创云提供的一个天气查询的接口，通过发送get请求，可以得到对应城市的天气，返回的数据类型为json格式。<br>我们先使用浏览器访问一下这个接口<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_1.png" ><br>由于网络调试助手的限制，我们必须要知道api的服务器地址和端口号<br>在浏览器上点击检查网页，在network标签下的header标签中可以找到我们想要的信息</p><p>通过网络调试助手，输入刚刚查到的ip和端口号，建立一个tcp连接<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_2.png" ><br>发送相应格式的请求，可以看到，我们已经收到了api接口返回的数据<br>（这里由于调试助手编码格式的问题，中文会显示乱码）</p><h3 id="esp8266通过TCP透传发送http请求"><a href="#esp8266通过TCP透传发送http请求" class="headerlink" title="esp8266通过TCP透传发送http请求"></a>esp8266通过TCP透传发送http请求</h3><p>调试时遇到了挺大的bug,模块的硬件电路出了点莫名其妙的问题，串口连接模块后，发送任何指令都没有反应，后来拿电压表测了一下，模块上电后CH_PD居然是低电平，于是又自己把CH_PD拉到高电平，解决了这一问题。<br>esp8266连接串口之后，依次发送如下指令：<br><code>AT+RST</code><br>//复位模块<br><code>AT+CWMODE=1</code><br>//进入STA模式<br><code>AT+RST</code><br>//复位生效上一条命令<br><code>AT+CWJAP=”note”,”123456789” </code><br>//连接到wifi<br><code>AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.1.115&quot;,8080</code><br>//连接到tcp服务器<br><code>AT+CIPMODE=1</code><br>//开启透传模式<br><code>AT+CIPSEND</code><br>//进入透传</p><p>进入透传后，发送以下数据<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_3.png" ><br>可以看到，我们成功地收到了服务器返回的接口数据<br>（由于电脑编码格式问题，此处存在乱码）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。&lt;br&gt;仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。&lt;br&gt;</summary>
      
    
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/categories/esp8266/"/>
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>Android实现mqtt客户端</title>
    <link href="http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/</id>
    <published>2021-04-25T14:26:16.000Z</published>
    <updated>2021-04-25T15:16:46.513Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。</p><h3 id="在gradle中添加依赖"><a href="#在gradle中添加依赖" class="headerlink" title="在gradle中添加依赖"></a>在gradle中添加依赖</h3><pre class="line-numbers language-none"><code class="language-none">implementation &#39;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0&#39;implementation &#39;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="添加相关的权限"><a href="#添加相关的权限" class="headerlink" title="添加相关的权限"></a>添加相关的权限</h3><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.WAKE_LOCK&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p><code>&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot;&gt;&lt;/service&gt;</code></p><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><ul><li>xml<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;zhuti&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的主题&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;neirong&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的内容&quot;        &#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;button&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;发送&quot;        &#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;textView&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>MainActivity.java<pre class="line-numbers language-none"><code class="language-none">import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;public class MainActivity extends AppCompatActivity &#123;    EditText zhuti;    EditText neirong;    Button fasong;    TextView jieshou;    MqttClient client;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F;App lianjie&#x3D;new App();        String subTopic &#x3D; &quot;test&quot;;        String pubTopic &#x3D; &quot;test&quot;;        String content &#x3D; &quot;Hello World&quot;;        int qos &#x3D; 2;        String broker &#x3D; &quot;tcp:&#x2F;&#x2F;49.235.68.28:1883&quot;;        String clientId &#x3D; &quot;emqx_test&quot;;        MemoryPersistence persistence &#x3D; new MemoryPersistence();        Log.i(&quot;aaa&quot;, &quot;运行中&quot;);        zhuti&#x3D;findViewById(R.id.zhuti);        neirong&#x3D;findViewById(R.id.neirong);        fasong&#x3D;findViewById(R.id.button);        jieshou&#x3D;findViewById(R.id.textView);        try &#123;             client &#x3D; new MqttClient(broker, clientId, persistence);            &#x2F;&#x2F; MQTT 连接选项            MqttConnectOptions connOpts &#x3D; new MqttConnectOptions();            connOpts.setUserName(&quot;emqx_test&quot;);            connOpts.setPassword(&quot;emqx_test_password&quot;.toCharArray());            &#x2F;&#x2F; 保留会话            connOpts.setCleanSession(true);            &#x2F;&#x2F; 设置回调            client.setCallback(new OnMessageCallback1());            &#x2F;&#x2F; 建立连接            Log.i(&quot;abc&quot;, &quot;Connecting to broker: &quot; + broker);            client.connect(connOpts);            Log.i(&quot;bcd&quot;, &quot;Connected&quot;);            Log.i(&quot;cde&quot;, &quot;Publishing message: &quot; + content);            &#x2F;&#x2F; 订阅            client.subscribe(subTopic);            &#x2F;&#x2F; 消息发布所需参数            MqttMessage  message &#x3D; new MqttMessage(content.getBytes());            message.setQos(qos);            client.publish(pubTopic, message);            Log.i(&quot;def&quot;, &quot;Message published&quot;);            &#x2F;&#x2F;client.disconnect();            &#x2F;&#x2F; Log.i(&quot;efg&quot;,&quot;Disconnected&quot;);            &#x2F;&#x2F; client.close();            &#x2F;&#x2F;System.exit(0);        &#125; catch (MqttException me) &#123;            Log.i(&quot;1&quot;, &quot;reason &quot; + me.getReasonCode());            Log.i(&quot;2&quot;, &quot;msg &quot; + me.getMessage());            Log.i(&quot;3&quot;, &quot;loc &quot; + me.getLocalizedMessage());            Log.i(&quot;4&quot;, &quot;cause &quot; + me.getCause());            Log.i(&quot;5&quot;, &quot;excep &quot; + me);            me.printStackTrace();        &#125;        fasong.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;            if(zhuti.getText().toString().equals(&quot;&quot;)||neirong.getText().toString().equals(&quot;&quot;))&#123;                Toast.makeText(MainActivity.this, &quot;请输入主题和内容&quot;, Toast.LENGTH_SHORT).show();            &#125;            else&#123;                try &#123;                    MqttMessage  message &#x3D; new MqttMessage(neirong.getText().toString().getBytes());                    message.setQos(qos);                    client.publish(zhuti.getText().toString(), message);                &#125; catch (MqttException e) &#123;                    e.printStackTrace();                &#125;&#125;            &#125;        &#125;);    &#125;&#x2F;&#x2F;回调函数 class OnMessageCallback1 implements MqttCallback &#123;    public void connectionLost(Throwable cause) &#123;        &#x2F;&#x2F; 连接丢失后，一般在这里面进行重连        Log.i(&quot;duankai&quot;,&quot;连接断开，可以做重连&quot;);    &#125;    public void messageArrived(String topic, MqttMessage message) throws Exception &#123;        &#x2F;&#x2F; subscribe后得到的消息会执行到这里面        Log.i(&quot;xiaoxi&quot;,&quot;接收消息主题:&quot; + topic);        Log.i(&quot;qos&quot;,&quot;接收消息Qos:&quot; + message.getQos());        Log.i(&quot;neirong&quot;,&quot;接收消息内容:&quot; + new String(message.getPayload()));        runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以        &#123;            public void run()            &#123;                &#x2F;&#x2F; TODO Auto-generated method stub               &#x2F;&#x2F; Toast.makeText(MainActivity.this, new String(message.getPayload()), Toast.LENGTH_SHORT).show();               jieshou.append(new String(message.getPayload())+&quot;\n&quot;);            &#125;        &#125;);    &#125;    public void deliveryComplete(IMqttDeliveryToken token) &#123;        Log.i(&quot;delivery&quot;,&quot;deliveryComplete---------&quot; + token.isComplete());    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>模拟器与真机均测试通过<br>以下是模拟器测试的图片<br>app默认订阅了test主题，发送消息的主题可自己设置</li><li>app<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_7.png" width="60%" height="60%"></li><li>websocket(一个在线的mqtt客户端)<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_8.png" ></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/jqnl/p/12660824.html">MQTT协议实现Android中的消息收发</a><br><a href="https://docs.emqx.cn/broker/v4.3/development/java.html">EMQX开发文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。&lt;/p&gt;
&lt;h3 id=&quot;在gradle中添加依赖&quot;&gt;&lt;a href=&quot;#在gradle中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;在gradle中添加依赖&quot;&gt;&lt;/a&gt;在gradle中</summary>
      
    
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/categories/mqtt/"/>
    
    
    <category term="Android" scheme="http://yeyuwenxi.github.io/tags/Android/"/>
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>mqtt服务器的搭建</title>
    <link href="http://yeyuwenxi.github.io/2021/04/25/mqtt-fu-wu-qi-de-da-jian/"/>
    <id>http://yeyuwenxi.github.io/2021/04/25/mqtt-fu-wu-qi-de-da-jian/</id>
    <published>2021-04-25T04:39:23.000Z</published>
    <updated>2021-04-25T08:14:37.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><em>(以上内容来自百度百科)</em></p><p>mqtt是一种基于发布/订阅的消息传输协议，客户端可以发送或接受某个主题的消息，而服务器则是用来为各个客户端推送消息的中间件，通常称为代理。</p><p>通俗地说，如果把我们每个人的qq账号看做是客户端，那么腾讯的服务器就类似于mqtt的代理，只有有了这个代理，各个客户端之间才能正常通信，所以说代理（mqtt服务器）是mqtt通信的重要组成部分。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下面直接进入正题，开始我们mqtt服务器的搭建。<br>常见的mqtt服务器软件有很多种，这里我们采用EMQX来进行我们mqtt服务器的搭建。<br>EMQX的使用文档如下:<br><a href="https://docs.emqx.cn/broker/v4.3/">EMQX</a></p><p>首先登陆自己购买的服务器的管理界面（我这里使用的是腾讯云的服务器），打开webshell连接到服务器。<br>在webshell中输入以下命令:<br><code>curl https://repos.emqx.io/install_emqx.sh | bash</code><br>如果显示权限不够，请切换到root用户执行该命令</p><ul><li>显示以下结果，则说明安装成功</li></ul><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_1.png" ><ul><li>最后，在shell中输入<code>emqx start</code>启动mqtt服务器</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。</p><p>我们可以通过ip:18083来访问dashboard.<br>如果访问失败，检查服务器的安全组规则是否放行该端口。<br>Dashboard的默认用户名是 admin，密码是 public。<br>在设置中可以将语言改成中文。<br>dashboard提供了一个websocket,可以作为一个在线的mqtt客户端来进行测试。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_2.png" ></li></ul><p>我们可以使用一个本地的mqtt客户端，来和websocket进行通信。<br>这里我们使用mqttx来进行测试，下载链接如下。<br><a href="https://mqttx.app/cn/">mqttx客户端</a></p><p>在websocket中订阅一个test主题，并在该主题下发布消息，可以看到，在下方的列表中显示了该主题下的消息。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_3.png" >使用本地的mqtt客户端连接到mqtt服务器</li><li>本地客户端连接到服务器<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_4.png" ></li><li>在本地mqtt客户端订阅test主题，并在test主题下发布消息“hello”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_5.png" ></li><li>在websocket订阅test主题，并在test主题下发布消息“hi”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_6.png">可以看到，websocket和本地的mqtt客户端都收到了他们互相发布的消息，测试成功。同时，我们也可以看到，当客户端订阅一个主题的时候，即使主题下有一个消息是自己发布的，客户端也会收到这个消息。</li></ul><h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publis</summary>
      
    
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/categories/mqtt/"/>
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>c语言在函数中修改外部指针变量的值</title>
    <link href="http://yeyuwenxi.github.io/2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/"/>
    <id>http://yeyuwenxi.github.io/2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/</id>
    <published>2021-04-18T07:31:17.000Z</published>
    <updated>2021-04-18T09:03:27.655Z</updated>
    
    <content type="html"><![CDATA[<p>最近又开始学数据结构了，总结一下之前写链表时遇到的一个问题。<br>如何在函数中修改一个外部指针变量的值，注意，是指针变量本身的值，而不是指针指向的变量的值，也就是说，我们要在函数中改变指针的指向。<br>先来看一个例子吧</p><ul><li>示例1<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在redirect函数中，s指向了b，但是p并未指向b,p中储存的仍然是a的地址。<br>这是为什么呢？<br>指针s并不是指针p本身，它仅仅是指针p的一个副本，储存了指针p的值，也就是说，指针s其实是另一个变量，它储存的地址和p储存的地址是一样的，但是改变s储存的地址，并不会改变p储存的地址。</li></ul><p>那我们怎么才能在函数中改变指针的指向呢？<br>我们知道，函数是默认传递值的，而不是传递地址，想要改变一个普通变量的值，我们就需要传递它的指针给函数。<br>那么，想要改变指针变量的值，我们就需要传递指针的指针给函数，没错，需要使用二级指针来改变指针的值。</p><ul><li>示例2<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">*</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，这时p已经指向了b,即我们成功地在函数中改变了指针p的值。</li></ul><p>此外，我们也可以通过引用在函数中改变指针的值。</p><ul><li>示例3：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，此时p也指向了b.</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>c语言在传递函数的参数时，传递给函数的，并不是变量本身，而是变量的一个拷贝。<br>只有在使用引用时，传递给函数的才是变量本身。<br>要想在函数中改变一个普通变量的值，我们需要使用指针来实现，那么要想在函数中改变一个指针变量的值，我们需要使用指针的指针，即二级指针来实现。<br>此外，也可以通过使用引用，传递变量本身来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近又开始学数据结构了，总结一下之前写链表时遇到的一个问题。&lt;br&gt;如何在函数中修改一个外部指针变量的值，注意，是指针变量本身的值，而不是指针指向的变量的值，也就是说，我们要在函数中改变指针的指向。&lt;br&gt;先来看一个例子吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例1&lt;pre clas</summary>
      
    
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>MSP432入门之流水灯实验</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/</id>
    <published>2021-04-15T15:50:45.000Z</published>
    <updated>2021-04-17T11:46:18.301Z</updated>
    
    <content type="html"><![CDATA[<p>最近在电赛培训网参加活动，中了一块TI的单片机开发板，具体型号为SimpleLink Ethernet MSP432E401Y Microcontroller LaunchPad。<br>这两天打算简单学一学这款单片机。<br>不得不说，网上关于MSP432单片机的资料是真的少，关于MSP432E4的资料更是少的可怜。<br>无奈只能从读TI官方给出的SDK和datasheet开始学习了。</p><h3 id="开发环境的选择"><a href="#开发环境的选择" class="headerlink" title="开发环境的选择"></a>开发环境的选择</h3><p>MSP432可以采用keil,ccs,iar来进行开发，这里我选择了官方主推的ccs来进行学习。<br>从ti的官网下载ccs和MSP432E4的SDK，并将ccs和SDK配置好，之后就可以进行我们的开发了。</p><h3 id="driverlib和tidriver"><a href="#driverlib和tidriver" class="headerlink" title="driverlib和tidriver"></a>driverlib和tidriver</h3><p>关于MSP432，官方的SDK中给出了两大类库，driverlib和tidriver.<br>driverlib更接近底层，能实现的功能也更加的丰富。<br>tidriver更加的抽象，也更容易理解和使用，更重要的是，tidriver可以采用图形化的操作来配置单片机的外设。<br>当然，tidriver的功能可能不是特别的完善，所以有时候也可以调用driverlib中的部分功能或者直接操作寄存器来实现某些功能，不过tidriver和driverlib的某些文件可能会产生冲突，这一点在使用时是需要注意的。</p><h3 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h3><p>SDK中提供了很多demo，我们可以直接通过导入demo的工程来进行开发，这里我们采用tidriver的工程来进行开发，对于初学者来说，图形化的外设配置相比于代码要容易好多。<br>首先我们打开css,导入一个tidriver库中的demo，随便挑选一个就可以。</p><ul><li>导入工程<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_1.png" ></li></ul><p>通过项目管理栏可以看出，工程中主要有两个c文件，main_nortos.c主要负责开发板的初始化启动，启动后跳转到gpiointerrupt.c中的mainThread函数中运行，这里我们不需要进行改动。</p><ul><li>mainnortos.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_2.png" ></li></ul><p>gpiointertupt.c文件中有一个mainThread函数，我们要在mainThread函数中书写我们需要的用户代码。</p><p>外设的配置<br>打开资源管理栏后缀名为syscfg的配置文件，在其中配置我们需要使用的设备。<br>这里我们配置4个LED灯就可以。</p><ul><li>图形化外设配置<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_3.png" ></li></ul><p>保存之后，我们对外设的配置都会保存到ti_driver_config.c(.h)文件中.</p><ul><li>ti_driver_config.h<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_4.png" ></li></ul><p>打开interrupt函数，删掉原有代码，编写我们需要的代码。</p><ul><li>interrupt.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_5.png" ></li></ul><p>点击导航栏进行编译和烧录</p><ul><li>编译和烧录<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_6.png" ></li></ul><p>之后，就可以看到板子上的4个LED轮流点亮和熄灭了。</p><ul><li>运行效果<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_7.jpg" ></li></ul><h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><p> void delay(){<br>        int i=0;<br>        for(i=0;i&lt;1000000;i++);<br>    }</p><p>void *mainThread(void <em>arg0)<br>{<br>    /</em> Call driver unit functions <em>/<br>    GPIO_init();<br>    /</em> Configure the LED and button pins */<br>    GPIO_setConfig(CONFIG_GPIO_1, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_2, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_3, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_4, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    while(1){<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_1);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_2);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_3);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_4);<br>    }<br>    return (NULL);<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在电赛培训网参加活动，中了一块TI的单片机开发板，具体型号为SimpleLink Ethernet MSP432E401Y Microcontroller LaunchPad。&lt;br&gt;这两天打算简单学一学这款单片机。&lt;br&gt;不得不说，网上关于MSP432单片机的资料是真</summary>
      
    
    
    
    <category term="MSP432单片机" scheme="http://yeyuwenxi.github.io/categories/MSP432%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MSP432" scheme="http://yeyuwenxi.github.io/tags/MSP432/"/>
    
  </entry>
  
  <entry>
    <title>AD之PCB画板初探</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/</id>
    <published>2021-04-15T15:48:19.000Z</published>
    <updated>2021-04-16T11:30:02.636Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于选修课的要求，速成了一波AD，这两天完成了自己的第一个PCB板的绘制。</p><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><p>1.三个开关控制一盏灯<br>2.使用按钮实现开关的功能</p><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>1.三个开关控制一盏灯，算是比较基础的数电问题了，这里我采用了74LS86（异或门）来实现这一逻辑功能。</p><p>2.按钮实现开关的功能，这一点我上网查资料发现都是采用模拟电路实现的，采用电容充放电实现开关的功能，电路较为复杂，实现原理也较为复杂，这里就不讲了。</p><p>分享一篇文章，有兴趣的可以自己看看<a href="https://baijiahao.baidu.com/s?id=1603206971622118062&wfr=spider&for=pc&qq-pf-to=pcqq.group">点按式轻触开关如何实现自锁轻触开关带锁按键开关功能？</a><br>3.后来想了想，还是采用数字电路实现比较简单，通过JK触发器的电平翻转来实现电路开关的功能，最后通过带JK触发器的74LS109实现了这一功能。</p><h3 id="PCB绘制流程"><a href="#PCB绘制流程" class="headerlink" title="PCB绘制流程"></a>PCB绘制流程</h3><p>1.原理图库的绘制<br>由于官方封装库中的门电路芯片都是只显示部分的，所以这里我自己绘制了74LS86和74LS109芯片的原理图。</p><ul><li>74LS86<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li><li>74LS109<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li></ul><p>2.原理图的绘制</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_4.png" ></li></ul><p><strong>ps:</strong> 经老师提醒，原理图中按钮部分存在问题，TTL芯片悬空时为高电平，所以芯片的CLK端口需要接一个下拉电阻。</p><p>3.PCB封装库的绘制<br>这里偷了点懒，直接采用了TI官方的封装库。</p><ul><li>D014_N封装<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_3.png" ></li></ul><p>4.PCB图的绘制</p><p>这一步才算是到了PCB绘制的核心部分。</p><h4 id="器件摆放"><a href="#器件摆放" class="headerlink" title="器件摆放"></a>器件摆放</h4><p>AD会将原理图中用到所有器件直接转移到PCB文件中，我们需要将各个器件以合适的位置摆放好。</p><h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><p>AD有自动布线功能，但还是推荐手动布线。<br>布线拐角采用钝角，降低电磁干扰。<br>多层板可能需要过孔，将各个板层进行电气连接。</p><h4 id="铺铜"><a href="#铺铜" class="headerlink" title="铺铜"></a>铺铜</h4><p>将没有导线的地方铺铜，提高抗干扰能力。</p><h4 id="丝印"><a href="#丝印" class="headerlink" title="丝印"></a>丝印</h4><p>添加需要的标记符号和个性化定制文字内容。</p><h4 id="版型设计"><a href="#版型设计" class="headerlink" title="版型设计"></a>版型设计</h4><p>对PCB板进行裁剪，打定位孔等操作，推荐矩形版型。</p><ul><li>最后贴上我的第一个PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_5.png" >(空白处有姓名等相关信息，已打码)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近由于选修课的要求，速成了一波AD，这两天完成了自己的第一个PCB板的绘制。&lt;/p&gt;
&lt;h3 id=&quot;任务目标&quot;&gt;&lt;a href=&quot;#任务目标&quot; class=&quot;headerlink&quot; title=&quot;任务目标&quot;&gt;&lt;/a&gt;任务目标&lt;/h3&gt;&lt;p&gt;1.三个开关控制一盏灯&lt;br&gt;</summary>
      
    
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/categories/PCB/"/>
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
    <category term="数字电路" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>博客域名大赏</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/bo-ke-yu-ming-da-shang/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/bo-ke-yu-ming-da-shang/</id>
    <published>2021-04-15T15:04:27.000Z</published>
    <updated>2021-04-15T15:39:15.388Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客从最开始在gitee上搭建，到github上搭建，又到vercel上托管，前前后后变换了好几个平台，也搞出了好多个域名。<br>今天写个记录，记录一下这些域名。</p><h3 id="gitee-版"><a href="#gitee-版" class="headerlink" title="gitee 版"></a>gitee 版</h3><p>1.<a href="https://yeyuwenxi.gitee.io/">https://yeyuwenxi.gitee.io/</a><br>gitee的主要问题有两个，一是不能自动更新，而是首页图标的显示存在问题，与github双部署时无法同时正常显示</p><h3 id="github版"><a href="#github版" class="headerlink" title="github版"></a>github版</h3><p>2.<a href="https://yeyuwenxi.github.io/%EF%BC%88%E8%AE%BF%E9%97%AE%E6%97%B6%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B03%EF%BC%89">https://yeyuwenxi.github.io/（访问时自动跳转到3）</a><br>3.<a href="https://yeyuwenxi.xyz/%EF%BC%88%E4%B8%BB%E7%AB%99%E7%82%B9%EF%BC%89">https://yeyuwenxi.xyz/（主站点）</a></p><h3 id="vercel加速版"><a href="#vercel加速版" class="headerlink" title="vercel加速版"></a>vercel加速版</h3><p>4.<a href="https://yeyuwenxi.vercel.app/%EF%BC%88%E5%B7%B2%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B07%EF%BC%89">https://yeyuwenxi.vercel.app/（已重定向到7）</a><br>5.<a href="https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/</a><br>6.<a href="https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/</a><br>7.<a href="https://blog.yeyuwenxi.xyz/">https://blog.yeyuwenxi.xyz/</a><br>不得不说，vercel托管后，域名是真的多</p><h3 id="关于域名解析服务器"><a href="#关于域名解析服务器" class="headerlink" title="关于域名解析服务器"></a>关于域名解析服务器</h3><p>yeyuwenxi.xyz的域名服务器在腾讯云<br>blog.yeyuwenxi.xyz的域名服务器在vercel</p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>目前并没有感觉vercel比github pages快多少</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个博客从最开始在gitee上搭建，到github上搭建，又到vercel上托管，前前后后变换了好几个平台，也搞出了好多个域名。&lt;br&gt;今天写个记录，记录一下这些域名。&lt;/p&gt;
&lt;h3 id=&quot;gitee-版&quot;&gt;&lt;a href=&quot;#gitee-版&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="博客搭建" scheme="http://yeyuwenxi.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客搭建" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习笔记</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/markdown-yu-fa-xue-xi-bi-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/markdown-yu-fa-xue-xi-bi-ji/</id>
    <published>2021-04-12T05:58:22.000Z</published>
    <updated>2021-04-15T11:06:33.674Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。<br>个人认为，Markdown可以看做xml,html的简化版，非常适合用来纯文本编辑。<br>好了，下面直接进入语法部分。</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>markdown使用#来表示标题,支持六级标题<br>示例：<br><code># 一</code><br><code>## 二</code><br><code>### 三</code><br><code>#### 四</code><br><code>##### 五</code><br><code>###### 六</code></p><p>显示效果：</p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><h5 id="五"><a href="#五" class="headerlink" title="五"></a>五</h5><h6 id="六"><a href="#六" class="headerlink" title="六"></a>六</h6><p>注意：#和文字之间要加1个空格</p><h3 id="2-超链接"><a href="#2-超链接" class="headerlink" title="2.超链接"></a>2.超链接</h3><p>示例：<br><code> [百度](baidu.com)</code><br>显示效果：<br><a href="baidu.com">百度</a></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;a href=&quot;baidu.com&quot;&gt;百度 &lt;/a&gt;</code><br>显示效果：<br><a href="baidu.com">百度 </a></p><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3.图片"></a>3.图片</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>示例：<br><code>![图片名称](https://www.baidu.com/img/flexible/logo/pc/result.png)</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png" alt="图片名称"></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;&gt;</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png"></p><h4 id="3-2-设置图片的大小"><a href="#3-2-设置图片的大小" class="headerlink" title="3.2 设置图片的大小"></a>3.2 设置图片的大小</h4><p>示例：<code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;      width=&quot;10%&quot; height=&quot;10%&quot;&gt;</code><br>显示效果：<img src="https://www.baidu.com/img/flexible/logo/pc/result.png" width="10%" height="10%" ></p><h4 id="3-3-设置图片居中显示"><a href="#3-3-设置图片居中显示" class="headerlink" title="3.3 设置图片居中显示"></a>3.3 设置图片居中显示</h4><h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h3><h4 id="4-1单行代码"><a href="#4-1单行代码" class="headerlink" title="4.1单行代码"></a>4.1单行代码</h4><p>使用英文反顿号”<code> </code>“表示单行代码<br>示例：<br>显示效果：123</p><h4 id="4-2多行代码"><a href="#4-2多行代码" class="headerlink" title="4.2多行代码"></a>4.2多行代码</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。&lt;br&gt;个人认为，Markdown可以看做xml,html的简化版，非常适合用来纯文本编辑。&lt;br&gt;好了，下面直接进入语法部分。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://yeyuwenxi.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://yeyuwenxi.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Markdown" scheme="http://yeyuwenxi.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Matlab实现简单的语音信号处理</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/</id>
    <published>2021-04-12T05:06:02.000Z</published>
    <updated>2021-04-12T05:50:19.903Z</updated>
    
    <content type="html"><![CDATA[<p>学习数字信号处理课程时做过的一个实验。</p><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>  1.学习并掌握数字信号处理的基本方法。<br>  2.学会使用MATLAB对语音信号进行处理。<br>  3.学习并掌握MATLAB设计滤波器的方法。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>   本次实验基于MATLAB R2019a完成，利用MATLAB对录制的语音信号进行了读取，播放，时域分析，频域分析以及滤波处理等操作。<br>   本次实验主要包括以下几个步骤：<br>1.音频的录制与导入<br>    使用手机自带的录音软件录制了格式为wav的一段语音信号。录音完成后，使用MATLAB的audioread函数对语音信号进行采样。<br>2.语音信号的时域分析和频域分析<br>    使用plot函数绘制语音信号的时域波形，对语音信号进行快速傅里叶变换，并绘制出语音信号的频域波形。<br>    <img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_1.jpg" width="60%" height="60%"><br>3.设计滤波器对语音信号进行处理<br>（1）低通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯低通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字低通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_2.jpg" width="60%" height="60%"><br>低通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_3.jpg" width="60%" height="60%"><br>（2）高通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯高通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字高通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_4.jpg" width="60%" height="60%"><br>高通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_5.jpg" width="60%" height="60%"><br>（3）陷波器的设计<br>根据陷波器的表达式配置参数，设计陷波器如下图所示<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_6.jpg" width="60%" height="60%"><br>使用陷波器处理后的频谱<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_7.jpg" width="60%" height="60%"><br>（4）对语音信号加噪<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_8.jpg" width="60%" height="60%"></p><h3 id="三、实验代码"><a href="#三、实验代码" class="headerlink" title="三、实验代码"></a>三、实验代码</h3><p>[x,fs]=audioread(‘yuyin.wav’);%录入语音信号<br>n=length(x);%获取语音信号的长度<br>x_p=fft(x,n);%利用FFT算法对语音信号进行离散傅里叶变换<br>f=fs*(0:n-1)/n;%频率的归一化<br>figure(1);%绘制时域和频域波形<br>subplot(2,1,1);<br>plot(x);<br>title(‘原始语音信号采样后的时域波形’);<br>xlabel(‘时间轴’)<br>ylabel(‘幅值A’)<br>subplot(2,1,2);<br>plot(f,abs(x_p));<br>title(‘原始语音信号采样后的频谱图’);<br>xlabel(‘频率Hz’);<br>ylabel(‘频率幅值’);<br>%噪声<br>% noise=0.2<em>randn(1,n);<br>% x_z=x+noise’;<br>% sound(x_z,fs);<br>% n=length(x);<br>% x_zp=fft(x_z,n);<br>% f=fs</em>(0:n/2-1)/n;<br>% figure(5);<br>% subplot(2,1,1);<br>% plot(x_z);<br>% title(‘加噪语音信号时域波形’);<br>% xlabel(‘时间轴’)<br>% ylabel(‘幅值A’)<br>% subplot(2,1,2);<br>% plot(f,abs(x_zp(1:n/2)));<br>% title(‘加噪语音信号频谱图’);<br>% xlabel(‘频率Hz’);<br>% ylabel(‘频率幅值’);<br>% %低通滤波器<br>fp=800;fs=1300;rs=35;rp=0.5;Fs=44100;<br>wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>[n,wn]=buttord(wp,ws,rp,rs,’s’);<br>[b,a]=butter(n,wn,’s’);<br>[num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>[h,w]=freqz(num,den,512,Fs);<br>% 512为点数 Fs为频率范围<br>figure(2)<br>plot(w,abs(h));<br>xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>title(‘巴特沃斯低通滤波器幅度特性’);<br>axis([0,5000,0,1.2]);<br>grid on;%网格线<br>%高通滤波器<br>% fp=3800;fs=3300;rs=3;rp=0.5;Fs=44100;<br>% wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>% ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>% [n,wn]=buttord(wp,ws,rp,rs,’s’);<br>% [b,a]=butter(n,wn,’high’,’s’);<br>% [num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>% [h,w]=freqz(num,den,512,Fs);<br>% % 512为点数 Fs为频率范围<br>% figure(2)<br>% plot(w,abs(h));<br>% xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>% title(‘巴特沃斯高通滤波器幅度特性’);<br>% axis([0,5000,0,1.2]);<br>% grid on;%网格线<br>%陷波器<br>% f0=3000;Fs=44100;r=0.9;<br>% w0=2<em>pi</em>f0/Fs;<br>% num=[1 -2<em>cos(w0) 1];<br>% den=[1 -2</em>r<em>cos(w0) r</em>r];<br>% N=1024;<br>% [H,w]=freqz(num,den,N);<br>% plot(w/pi/2<em>Fs,abs(H));<br>% grid on;<br>% title(‘陷波器的幅频响应’);<br>% [s1,Fs]=audioread(‘yuyin.wav’);<br>% %x1=s1(:,1);%选取一个声道的数据<br>% x1=s1;<br>% %sound(x1,Fs);<br>% N1=length(x1);<br>% Y1=fft(x1,N1);<br>% f1=Fs</em>(0:N1-1)/N1;<br>% %t1=(0:N1-1)/Fs;<br>% figure(3)<br>% plot(f1,abs(Y1))<br>% xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>% title(‘原始信号频谱’);<br>% grid on;axis([0 50000 0 600])<br>y=filter(num,den,x);<br>%sound(y,Fs);<br>N2=length(y);<br>Y2=fft(y,N2);<br>f2=Fs*(0:N2-1)/N2;<br>%t2=(0:N2-1)/Fs;<br>figure(4)<br>plot(f2,abs(Y2))<br>xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>title(‘过滤后信号的频谱’);<br>grid on;<br>axis([0 50000 0 600])</p><h3 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h3><p>分析语音信号的频谱图可以看出，有效的语音信号主要集中在0到4000Hz之间，根据奈奎斯特定理，最低的采样频率为8000Hz.观察滤波前后语音信号频谱的变化，可以看出滤波器按要求处理了语音信号，本次实验顺利完成。<br>总的来说，通过这次实验我收获了很多，对matlab有了更加深入的认识，了解到了如何利用matlab的各种函数对语音信号进行处理，这次实验也加深了我对离散傅里叶变换和滤波器设计的理解，巩固了课堂上所学到的知识，也让我看到了自己所学的知识在生活中的应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习数字信号处理课程时做过的一个实验。&lt;/p&gt;
&lt;h3 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h3&gt;&lt;p&gt;  1.学习并掌握数字信号处理的基本方法。&lt;br&gt;  </summary>
      
    
    
    
    <category term="Matlab" scheme="http://yeyuwenxi.github.io/categories/Matlab/"/>
    
    
    <category term="Matlab" scheme="http://yeyuwenxi.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>读《嘉莉妹妹》</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/du-jia-li-mei-mei/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/du-jia-li-mei-mei/</id>
    <published>2021-04-12T04:54:13.000Z</published>
    <updated>2021-04-12T04:59:57.918Z</updated>
    
    <content type="html"><![CDATA[<p>大二时英文选修课写的一篇小论文，这里是中文版，内容有所删减。</p><p>西奥多·德莱塞，美国伟大的现实主义作家。他的父亲是贫苦的德国移民，家里有很多的孩子，一家人生活很是拮据。德莱赛一生的大部分时间从事新闻工作，他走遍芝加哥、匹兹堡、纽约等大城市，广泛深入地观察了解社会，对资本主义制度有了很深的认识，为日后的文学创作积累了丰富的素材。</p><p>《嘉莉妹妹》是德莱赛的第一部著作，描写了农村姑娘嘉莉来到大城市芝加哥寻找幸福，为摆脱贫困，出卖自己的贞操，先后与推销员和酒店经理同居，后又凭美貌与表演才能成为演员而后走红的故事。其中，嘉莉私奔的情节来源于德莱赛妹妹的真实生活经历，他的妹妹曾跟一个偷钱潜逃的酒店经理私奔。</p><p>嘉莉是一个年轻的，纯朴的，没有经验的农村小姑娘，为了追求幸福的生活来到了大城市芝加哥。</p><p>正如作者在开篇时所写到的，一个年轻的没有经验的来自乡下的小姑娘来到大城市时，通常只有两种可能，得到善良的帮助而成为更好的人，或者被物质的诱惑影响而堕落。</p><p>很遗憾，嘉莉没有遇到能够真正在精神上帮助她的人，她的姐姐以及她的两个情人都不是那样的人，他们所教给嘉莉的，只有对物欲和名利的追求，只有物质至上的幸福观。在他们的影响下，嘉莉对上层社会，充盈的物质生活有了极大的渴望，她要拼劲全力地挤进那个社会，去享受物质上的快感与愉悦。对物欲的追求，让嘉莉迷失了初心，虚荣感让她放弃了一个人身上最淳朴的品质，就这样，嘉莉为了富裕的生活而两次出卖自己的贞操。</p><p>在德莱赛的那个时代，在垄断资本主义盛行的社会背景下，很难出现那样能给嘉莉以正确引导的人，每个人都在为自己的各种欲望而奔波。</p><p>嘉莉早期求职的过程也充分说明，在那个充满压迫，充满剥削的时代里，一个底层的普通人，靠自己的努力和勤奋是难以实现梦想的，是没有真正意义上的出路的，残酷的生活压迫着每一个普通人。</p><p>嘉莉靠美貌和运气以及出卖贞操走向了成功，而许许多多的平凡的人却只能在社会的底层不断地挣扎，承受着这个社会带给他们的苦难。从另一方面来说，获得成功的嘉莉也没有拥有真正意义上的快乐，与她相伴的只有内心的孤苦与空虚。无论成功与否，嘉莉都是痛苦的，物质上的满足并没有带给嘉莉真正的幸福感。</p><p>嘉莉正是作者所处那个时代的一个缩影，作者借嘉莉的视角，展现了资本主义带给人的种种苦难，揭露了资本主义社会的弊端，批判了金钱至上，物欲横流的社会现状。</p><p>在一个病态的资本主义社会里，在物质至上的时代里，是没有真正的幸福可言的。我想，这正是作者想要告诉我们的东西，一个人哪怕有了物质上的充盈，也会因为精神上的匮乏而陷入空虚。这一点对现在的我们也是适用的，我们不能陷于物质的牢笼而忽略了那些精神上值得我们去追寻的东西，不能为了自己的虚荣与欲望而放弃那些珍贵的有价值的道德品质。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大二时英文选修课写的一篇小论文，这里是中文版，内容有所删减。&lt;/p&gt;
&lt;p&gt;西奥多·德莱塞，美国伟大的现实主义作家。他的父亲是贫苦的德国移民，家里有很多的孩子，一家人生活很是拮据。德莱赛一生的大部分时间从事新闻工作，他走遍芝加哥、匹兹堡、纽约等大城市，广泛深入地观察了解社会</summary>
      
    
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>单片机温度、压力信息采集与电机控制系统</title>
    <link href="http://yeyuwenxi.github.io/2021/04/11/dan-pian-ji-wen-du-ya-li-xin-xi-cai-ji-yu-dian-ji-kong-zhi-xi-tong/"/>
    <id>http://yeyuwenxi.github.io/2021/04/11/dan-pian-ji-wen-du-ya-li-xin-xi-cai-ji-yu-dian-ji-kong-zhi-xi-tong/</id>
    <published>2021-04-11T13:58:06.000Z</published>
    <updated>2021-04-11T14:52:40.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>本次单片机温度、压力信息采集与电机控制系统实验是基于模数转换，数模转换，LCD显示，键盘扫描，脉冲控制等知识的一个综合性的实验模块。<br>本次实验作品主要包括温度的采集与显示，压力的采集与显示，步进电机的驱动与控制三个模块。<br>温度的采集采用DS18B20模块，DS18B20采集温度后将温度转换为数字量并将数字量通过串行通信的方式发送给单片机。压力的采集采用称重传感器和HX711模块，HX711可将称重传感器的小信号放大并转换为数字量，最后再通过串行通信的方式将数字量传送给单片机。单片机处理完HX711和DS18B20的数据后，将压力值和温度值显示再LCD1602上。步进电机模块采用了一个四相五线的步进电机和一个ULN2003A驱动板，单片机连接驱动板，驱动板放大单片机的脉冲信号后驱动步进电机转动。<br>本次实验的硬件部分主要包括单片机最小系统，LCD1602显示屏，DS18B20测温模块，步进电机和驱动板以及称重传感器和HX711模块。</p><h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3><p>1.准备电路元器件及焊接工具：STC89C52RC芯片1个、IC插座、40p排针2个、12MHz晶振1个、30pF瓷片电容2个、10uF电解电容1个、排阻一个、电阻若干、LCD1602A显示屏1个、称重传感器1个、HX711模块1个、DS18B20模块1个、步进电机1个、ULN2003A驱动板1个、蜂鸣器1个、10*15cm洞洞板一个、电源线、杜邦线、下载器、电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接。<br>3.调试：下载程序，将单片机系统与各个模块相连，观察LCD是否正常显示压力、温度等信息，若正常显示，说明压力，温度模块正常，按动按键，观察步进电机是否随按键控制正常转动，若转动正常，说明步进电机模块正常。 </p><ul><li>焊接成果图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_12.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写。<br>2.设计仿真电路图：将电源、时钟电路、复位电路、51单片机、DS18B20模块、称重传感器模块、HX711模块及LCD1602显示屏正确连接。电源选用+5v，晶振选用12MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否能达到目标要求。</p><ul><li>编程<br>ORG 0000H<br>//接口初始化<br>DOUT EQU P2.2<br>SCK EQU P2.3</li></ul><p>RS EQU P2.5<br>RW EQU P2.6<br>E EQU P2.7 </p><p>DQ EQU P2.4<br>GEWEI1 EQU 35H<br>SHIWEI1 EQU 36H</p><p>QIAN EQU 31H<br>BAI EQU 32H<br>SHI EQU 33H<br>GEWEI EQU 34H</p><p>FENGMING EQU P3.7<br>LJMP MAIN</p><p>ORG 000BH<br>LJMP IT00 //中断入口<br>ORG 0100H<br>MAIN:<br>MOV P0,#00000001B<br>ACALL ENABLE<br>MOV P0,#00111000B<br>ACALL ENABLE<br>MOV P0,#00001100B<br>ACALL ENABLE<br>MOV P0,#00000110B<br>ACALL ENABLE<br>MOV P0,#80H<br>ACALL ENABLE<br>MOV P0,#’W’<br>ACALL WRITELCD</p><p>MOV P0,#’E’<br>ACALL WRITELCD</p><p>MOV P0,#’N’<br>ACALL WRITELCD</p><p>MOV P0,#’D’<br>ACALL WRITELCD</p><p>MOV P0,#’U’<br>ACALL WRITELCD</p><p>MOV P0,#’:’<br>ACALL WRITELCD<br>MOV P0,#0C0H<br>ACALL ENABLE</p><p>MOV P0,#’Y’<br>ACALL WRITELCD<br>MOV P0,#’A’<br>ACALL WRITELCD<br>MOV P0,#’L’<br>ACALL WRITELCD<br>MOV P0,#’I’<br>ACALL WRITELCD<br>MOV P0,#’:’<br>ACALL WRITELCD</p><p>MOV P0,#0C9H<br>ACALL ENABLE</p><p>MOV P0,#’g’<br>ACALL WRITELCD<br>MOV 40H,#00H</p><p>MOV TMOD,#01H<br>MOV TH0,#3CH<br>MOV TL0,#0B0H<br>SETB EA<br>SETB ET0<br>SETB TR0</p><p>ACALL DIANJI<br>LJMP MAIN<br>IT00:<br>INC 40H<br>MOV A,40H<br>CJNE A,#3AH,L11</p><p>L10: MOV 40H,#00H<br>ACALL AD</p><p>L11:MOV TH0,#3CH<br>MOV TL0,#0B0H<br>RETI<br>AD:<br>ACALL READTEM<br>ACALL YALI</p><p>ACALL XIANSHI</p><p>MOV P0,#86H<br>ACALL ENABLE<br>MOV P0,SHIWEI1<br>ACALL WRITELCD<br>MOV P0,#87H<br>ACALL ENABLE<br>MOV P0,GEWEI1<br>ACALL WRITELCD</p><p>CLR C<br>MOV A,#00H<br>SUBB A,GEWEI1<br>MOV A,#03H<br>SUBB A,SHIWEI1<br>JNC L12<br>CLR P3.7<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>SETB P3.7<br>L12:<br>MOV P0,#0C5H<br>ACALL ENABLE<br>MOV P0,QIAN<br>ACALL WRITELCD<br>MOV P0,#0C6H<br>ACALL ENABLE<br>MOV P0,BAI<br>ACALL WRITELCD<br>MOV P0,#0C7H<br>ACALL ENABLE<br>MOV P0,SHI<br>ACALL WRITELCD<br>MOV P0,#0C8H<br>ACALL ENABLE<br>MOV P0,GEWEI<br>ACALL WRITELCD</p><p>RET<br>//步进电机<br>DIANJI:<br>MOV 38H,#00H<br>JNB P3.0,START1<br>JNB P3.1,START2<br>JNB P3.2,START3</p><p>LJMP DIANJI<br>START1:<br>MOV DPTR,#TABLE1<br>LJMP LOOP<br>START2:<br>MOV DPTR,#TABLE2<br>LJMP LOOP<br>START3:<br>MOV DPTR,#TABLE3<br>LJMP LOOP<br>LOOP:<br>MOV A,38H<br>MOVC A,@A+DPTR<br>MOV P1,A<br>LCALL DELAY1<br>INC 38H<br>MOV A,38H<br>CJNE A,#08H,LOOP</p><p>JNB P3.0,L1<br>JNB P3.1,L1<br>JNB P3.2,L1<br>MOV 38H,#00H<br>LJMP LOOP<br>L1:<br>LJMP DIANJI<br>RET</p><p>DELAY1:MOV R5,#25  //步进电机的延时<br>DEL1:MOV R6,#50<br>     DJNZ R6,$<br>     DJNZ R5,DEL1<br>     RET<br>//步进电机码表<br>TABLE1:<br>DB 02H,06H,04H,0CH,08H,09H,01H,03H<br>TABLE2:<br>DB 03h,01H,09H,08H,0CH,04H,06H,02H<br>TABLE3:<br>DB 00H,00H,00H,00H,00H,00H,00H,00H</p><p>//温度传感器</p><p>READTEM:</p><p>ACALL RST</p><p>MOV R1,#30<br>DJNZ R1,$<br>MOV A,#0CCH<br>ACALL WRITE<br>MOV A,#44H<br>ACALL WRITE<br>ACALL RST<br>MOV R1,#30<br>DJNZ R1,$<br>MOV A,#0CCH<br>ACALL WRITE<br>MOV A,#0BEH<br>ACALL WRITE</p><p>ACALL READ<br>MOV 30H,A     ;读低八位<br>ACALL READ<br>MOV 31H,A       ;读高八位</p><p>ANL 30H,#0F0H<br>ANL 31H,#0FH<br>MOV A,30H<br>ORL A,31H<br>SWAP A</p><p>MOV R3,A</p><p>MOV B,#10<br>DIV AB<br>ADD A,#30H<br>MOV SHIWEI1,A<br>MOV A,B<br>ADD A,#30H<br>MOV GEWEI1,A<br>RET</p><p>RST:SETB DQ                       ;  总线释放<br>      NOP                           ;  保持高电平，延时<br>      CLR DQ                    ;  总线置 0，请求响应<br>      MOV R0,#0FBH<br>TSR1: DJNZ R0,TSR1                    ;  延时<br>      SETB DQ                        ;  再释放<br>      MOV R0,#25H<br>TSR2: JNB DQ,TSR3                    ;  改变为 0，则代表得到对应<br>      DJNZ R0,TSR2                ;  未得到则继续等待，判断<br>TSR3:                     ;  得到相应则标志位置 1，代表传感器正常存在<br>      MOV R0,#06BH<br>TSR4: DJNZ R0,TSR4                    ;  延时<br>      SETB DQ<br>RET</p><p>WRITE:MOV R0,#8<br>LOOP1:<br>CLR C<br>CLR DQ</p><p>RRC A<br>MOV R1,#6<br>DJNZ R1,$<br>MOV DQ,C<br>MOV R1,#23<br>DJNZ R1,$<br>SETB DQ<br>NOP</p><p>DJNZ R0,LOOP1<br>SETB DQ<br>MOV R1,#05<br>DJNZ R1,$<br>RET</p><p>READ:;<br>MOV R0,#8<br>LOOP2:<br>CLR C<br>SETB DQ<br>NOP<br>NOP<br>CLR DQ<br>NOP<br>NOP<br>NOP<br>SETB DQ<br>MOV R1,#7<br>DJNZ R1,$<br>MOV C,DQ<br>RRC A<br>MOV R1,#23<br>DJNZ R1,$</p><p>DJNZ R0,LOOP2<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY2<br>SETB E<br>RET<br>WRITELCD:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY2<br>SETB E<br>RET</p><p>DELAY2:<br>MOV R4,#200<br>D1:MOV R5,#200<br>D2:DJNZ R5,D2<br>DJNZ R4,D1<br>RET</p><p>//压力传感器<br>YALI:</p><p>CLR SCK<br>JB DOUT,$<br>MOV R0,#24<br>LOOP3:<br>SETB SCK<br>NOP<br>CLR SCK<br>MOV C,DOUT</p><p>XCH A,R4<br>RLC A<br>XCH A,R4        //低八位<br>XCH A,R3<br>RLC A<br>XCH A,R3      //中八位<br>XCH A,R2<br>RLC A<br>XCH A,R2  //高八位</p><p>DJNZ R0,LOOP3</p><p>SETB SCK<br>NOP<br>CLR SCK              ;采集部分到此结束</p><p>RET</p><p>ZHUANHUAN:<br>NDIV31:<br>    MOV A,R2<br>    MOV B,R7<br>    DIV AB<br>    PUSH ACC<br>    MOV R2,B<br>    MOV B,#10H<br>NDV311:<br>    CLR C<br>    MOV A,R4<br>    RLC A<br>    MOV R4,A<br>    MOV A,R3<br>    RLC A<br>    MOV R3,A<br>    MOV A,R2<br>    RLC A<br>    MOV R2,A<br>    MOV F0,C<br>    CLR C<br>    SUBB A,R7<br>    JB F0,NDV312<br>    JC NDV313<br>NDV312:<br>    MOV R2,A<br>    INC R4<br>NDV313:<br>    DJNZ B,NDV311<br>    POP ACC<br>    ;CLR OV<br>    JZ NDV314<br>    ;SETB OV<br>NDV314:<br>    XCH A,R2<br>    MOV R7,A<br>RET</p><p>XIANSHI:<br>MOV A,R2<br>XRL A,#80H<br>MOV R2,A</p><p>MOV R7,#40<br>LCALL ZHUANHUAN</p><p>MOV R7,#10<br>LCALL ZHUANHUAN//到此温度转换结束</p><p>//去皮，减去初始重量<br>MOV R0,#04H<br>L3:CLR C<br>MOV A,R4<br>SUBB A,#208<br>MOV R4,A<br>JC JIAN<br>LJMP L2<br>JIAN:DEC R3<br>L2:DJNZ R0,L3</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV GEWEI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV SHI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV BAI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV QIAN,A</p><p>RET</p><p>END</p><p>*Proteus 仿真电路图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_13.jpg" ></p><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3><p>相比于之前的几次实验，这次的实验难度明显要高出一个数量级。从拿到实验方案开始，每一步都充满了许多问题，光是确立实验的基本方案和实验器件的选取就花费了好长时间。经过反复的筛选、比较，温度传感器选择了12位精度的DS18B20，蜂鸣器选择了有源的蜂鸣器，最麻烦的还是压力传感器的选取了，在反复查找信息之后，我简单地罗列出了三套方案：<br>1.使用压片传感器加上一个电压转换模块和ADC0809来完成压力的测试。压片传感器将压力值转换为电阻值，电压转换模块再将电阻值转换为电压值，最后再由ADC0809将电压值转换为数字量，送交单片机处理。<br>2.使用称重传感器和小信号放大芯片以及ADC0809芯片来实现。称重传感器将压力值转换为一个电压值，信号放大芯片将这个电压值放大到ADC0809可以处理的状态，最后由ADC0809将数字量送交给单片机。<br>3.使用称重传感器加上一个HX711芯片来实现。HX711是一个自带增益的AD芯片，可以放大称重传感器产生的电压值并将它转换为数字量，最后HX711通过串行通信的方式将数字量传送给单片机。<br>反复考虑各个方案的实用性，精度，稳定性以及可实现性之后，我选择了第三个方案，通过HX711来实现本次的压力测量。<br>本次实验模块在硬件的焊接上并没有遇到太大的问题，最大的难点还是在程序的编写和仿真的实现上。<br>相对来说，步进电机的程序编写还是比较简单的，通过调制脉冲来驱动步进电机的转动，仿真的演示也没有遇到什么困难。但在进行实物制作的时候还是遇到了一些问题，明明仿真可以执行的程序，但在实物里步进电机就是无法转动，经过反复排查，发现原来是程序的延时存在问题，修改了延时之后，步进电机终于开始了转动。<br>DS18B20是一个具有12位精度的温度采集模块，DS18B20的时序相对来说比较复杂，在编写汇编程序的时候，我上网查找了很多资料，分析了好多时序图，也在这个过程中认识到了时序对于单片机程序的重要性。在DS18B20的实物实现时，也遇到了仿真时没有遇到的问题，后来发现原来是晶振的问题，更换晶振之后，DS18B20也终于正常读取显示了温度。<br>最麻烦的还是HX711模块的使用了，HX711模块是一个高精度的24位的自带增益的AD模块，可以将模拟量转换为数字量之后以串行通信的方式发送给单片机。由于51单片机一次只能处理8位数据，所以24位的数据必须读取到3个寄存器中来处理，而且HX711读取的的数值必须要做一个除法才能得到压力值，这样就特别的麻烦，我花时间最长的地方也是在这里，经过反复地查找资料，不断修改自己的程序，最后通过移位相减的方法把HX711的数据给处理了。最后做出的实物总有一个不为零的初始值，经过反复考虑，我觉得是传感器本身所造成的，最后通过把所有的压力值都减去这一个初始值，获得了真实的重量。</p><p>在三个模块都各自制作完毕，没有什么问题之后，我试着把这三个模块综合起来。温度和压力模块都通过不断扫描，反复执行的方法结合在了一起，但是在结合步进电机的时候遇到了麻烦，如果把温度和压力模块直接嵌入到步进电机的程序中，步进电机的转动就会产生问题。经过反复思索后，我写了一个定时中断的程序，把步进电机的程序放在了主程序中，而把温度和压力扫描的程序放在了中断中，这样每隔一段时间，单片机就会扫描显示一次温度和压力值，而在其他时间，都在扫描按键，执行步进电机的程序。最终，通过这样一个中断，终于把几个模块完美地结合在了一起。 </p><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p> 本次实验模块的设计与制作相比之前的三个实验确实难了好多，自己花费的时间也长了好多，在整个模块的制作过程中前前后后遇到了好多困难，但自己在不断克服困难的过程中也得到了很大的提高与成长。<br>从实验方案的设计，实验器件的选取，汇编语言的编写，到仿真的演示和实物的实现，每一步充满了各种挫折和困顿。第一次自己接到一个只有题目，没有例子的方案，从零开始设计制作，每一步都比之前的实验难了很多。中间好多时候都感到很沮丧，甚至都不太想做了，整个人状态就很不好，尤其是写代码的时候，反反复复，改来改去就是得不到想要的结果，甚至有时候都不想用汇编了，想之间拿c语言把这个程序给写了。但是自己还是逐渐地调整状态，慢慢地解决了一个又一个问题，最终用汇编语言完成了整个实验模块。最终完成的时候，看着整个四五百行的汇编程序，就觉得特别有成就感。<br>写代码和做实物的过程中虽然遇到过很多挫败，也有过很多心情沮丧的时候，但更多的是知识的成长以及心中不断燃烧的好奇与热情，我想正是在这样的热情和兴趣下，自己才能一步步克服障碍，完成了这次实验模块的制作。 尽管每一次遇到困难都很沮丧，但当自己战胜一个又一个困难，最后完成整个实验模块的时候，就感觉之前所有的沮丧都不值一提。<br>通过温度压力采集及步进电机的驱动系统设计与制作，自己的的确确学到了很多。从知识方面来看，自己认识到了温度、压力传感器的使用，还对串行通信有了更加深入的认识，看到了串行通信相对于并行通信的优势。另外，自己也对汇编语言有了更加深入而细致的认识，了解到了如何使用汇编语言经行加减运算，位操作以及数据处理，看到了汇编语言相对其他语言在单片机操作上的优势，看到了汇编语言的形象化与底层化。除此之外，自己通过这个过程，也收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。自己也十分期待在未来的学习和工作中，能够更加深入地学习单片机，并把这些知识和技能应用到未来的工作和生活中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章-系统整体概述&quot;&gt;&lt;a href=&quot;#第一章-系统整体概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 系统整体概述&quot;&gt;&lt;/a&gt;第一章 系统整体概述&lt;/h3&gt;&lt;p&gt;本次单片机温度、压力信息采集与电机控制系统实验是基于模数转换，数模转换，LC</summary>
      
    
    
    
    <category term="51单片机" scheme="http://yeyuwenxi.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="汇编" scheme="http://yeyuwenxi.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>UART实现51单片机双机串行通信</title>
    <link href="http://yeyuwenxi.github.io/2021/04/11/uart-shi-xian-51-dan-pian-ji-shuang-ji-chuan-xing-tong-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/04/11/uart-shi-xian-51-dan-pian-ji-shuang-ji-chuan-xing-tong-xin/</id>
    <published>2021-04-11T13:39:02.000Z</published>
    <updated>2021-04-11T14:51:04.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>本次单片机双机通讯系统设计实验是通过单片机间的串行通讯控制两个单片机进行通信的设计与制作。一个单片机系统做为发送端，从键盘输入自己的班级和姓名同时显示在 LCD 显示屏上并发送给另外一个单片机，另一个单片机系统作为接收端，把接收到的信息显示在 LCD 显示屏上。通过判断两个单片机系统中LCD屏幕显示的信息是否相同即可判断双机系统之间的串行通讯是否正常进行。<br>本次双机通讯系统采用了串行口方式1进行通讯，一帧信息为10位，其中有一个起始位，8个数据位和1个停止位。通讯的波特率位2400波特，T1工作在定时器方式2，震荡频率选用11.0592MH，通过计算可得TH1=TL1=0F4H,PCON寄存器的SMOD位为0。<br>整个系统的硬件部分是由两个单片机最小系统，两个 LCD 显示屏以及一个矩阵键盘构成。</p><h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3><p>1.准备电路元器件及焊接工具：STC89C51RC芯片2个、IC插座、40p排针2个、11.0592MHz晶振2个、30pF瓷片电容4个、10uF电解电容2个、排阻一个、电阻若干、LCD1602A显示屏2个、10*15cm洞洞板一个、电源线、杜邦线、下载器、电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接。<br>3.调试：下载程序，将两个单片机系统进行连接，通过按键测试双机通讯能否正常进行，若通讯正常，则两个单片机西铜所连接的lcd屏幕将随着按键按下而显示相同的字符，若不显示或字符紊乱，则双机通讯存在故障。</p><ul><li>焊接成果图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_10.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写<br>2.设计仿真电路图：将电源、时钟电路、复位电路、51单片机、LED数码管及LCD1602显示屏正确连接。电源选用+5v，晶振选用11.0592MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容，LED数码管串联470Ω电阻接在P2引脚，电阻的作用为保护电路,防止led灯被击穿，将键盘矩阵接在P0口，LCD1602A的D0-D7接口接在P1口。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否能达到目标要求。</p><ul><li>编程</li><li>发送端程序<br>ORG 0000H<br>LJMP MAIN<br>MAIN:<br>RS EQU P3.7<br>RW EQU P3.6<br>E EQU P3.5<br>MOV P1,#00000001B    ;清屏<br>ACALL ENABLE<br>MOV P1,#00111100B    ;  功能设定<br>ACALL ENABLE<br>MOV P1,#00001100B     ; 开关控制<br>ACALL ENABLE<br>MOV P1,#00000110B     ;模式设置<br>ACALL ENABLE<br>MOV P1,#80H<br>ACALL ENABLE<br>MOV R2,#00H<br>MOV DPTR,#TABLE3<br>MOV R1,#00H<br>;OR0:MOV A,R1<br>;MOVC A,@A+DPTR<br>;MOV P2,A<br>;ACALL WRITE<br>;INC R1<br>;CJNE A,#00H,OR0<br>MOV P1,#80H<br>ACALL ENABLE</li></ul><p>ORI:MOV P0,#0FH<br>MOV A,P0<br>CJNE A,#0FH,ORII<br>LJMP ORI<br>ORII:<br>ACALL KEYSCAN<br>MOV A,30H</p><p>ASTART:CLR EA<br>MOV TMOD,#20H<br>MOV TH1,#0F4H<br>MOV TL1,#0F4H<br>MOV PCON,#00H<br>SETB TR1<br>MOV SCON,#50H<br>ALOOP1:MOV SBUF,#0E1H<br>JNB TI,$<br>CLR TI<br>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,#0E2H<br>JNZ ALOOP1</p><p>ALOOP2:MOV R0,#30H<br>;MOV R7,#01H<br>MOV R6,#00H<br>ALOOP3:MOV SBUF,@R0<br>MOV A,R6<br>ADD A,@R0<br>MOV R6,A<br>;INC R0<br>JNB TI,$<br>CLR TI<br>;DJNZ R7,ALOOP3<br>MOV SBUF,R6<br>JNB TI,$<br>CLR TI<br>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>JNZ ALOOP2<br>;RET</p><p>;MOV P2,#0C0H<br>;ACALL ENABLE<br>MOV A,30H<br>MOV DPTR,#TABLE1<br>MOVC A,@A+DPTR<br>MOV P1,A      ;lcd的显示<br>ACALL WRITE<br>INC R1;<br>CJNE R1,#04H,JISHU<br>MOV P1,#0C0H<br>ACALL ENABLE<br>MOV R1,#05H<br>JISHU:<br>ACALL DELAY</p><p>SJMP ORI</p><p>AJMP $<br>WRITE:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET<br>KEYSCAN:MOV P0,#0FH<br>        MOV A,P0<br>ANL A,#0FH<br>MOV R3,A<br>MOV P0,#0F0H<br>MOV A,P0<br>ANL A,#0F0H<br>ORL A,R3<br>CJNE A,#0FFH,KEYPRO<br>RET<br>KEYPRO:MOV R3,A      ;R3放键值<br>       MOV DPTR,#KEYVALUE<br>   MOV R4,#0FFH<br>KEY1:INC R4       ;从1到16查找键值<br>     MOV A,R4    ;R4放偏移量<br> MOVC A,@A+DPTR<br> MOV 31H,R3<br> CJNE A,31H,KEY1  ;判断是否与键值相等<br> MOV A,R4<br> MOV 30H,A<br> RET<br>DELAY:<br>MOV R4,#60<br>D1:MOV R5,#60<br>D2:MOV R6,#30<br>DJNZ R6,$<br>DJNZ R5,D2<br>DJNZ R4,D1<br>RET<br>KEYVALUE: DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH<br>TABLE: DB  30H, 31H, 32H, 33H ,34H ,35H ,36H, 37H, 38H, 39H ,41H, 42H, 43H, 44H, 45H, 46H<br>TABLE1:DB ‘1’,’8’,’0’,’3’,’P’,’E’,’N’,’G’,’C’,’H’,’E’,’N’,’L’,’I’,’A’,’G’<br>TABLE2:  DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH<br>TABLE3: DB “ PENG CHENLIANG “,00H<br>END</p><ul><li>接收端程序<br>ORG 0000H<br>RS EQU P3.7<br>RW EQU P3.6<br>E EQU P3.5<br>MOV P1,#00000001B    ;清屏<br>ACALL ENABLE<br>MOV P1,#00111100B    ;  功能设定<br>ACALL ENABLE<br>MOV P1,#00001100B     ; 开关控制<br>ACALL ENABLE<br>MOV P1,#00000110B     ;模式设置<br>ACALL ENABLE<br>MOV P1,#80H<br>ACALL ENABLE<br>MOV R1,#00H<br>BSTART:CLR EA<br>MOV TMOD,#20H<br>MOV TH1,#0F4H<br>MOV TL1,#0F4H<br>MOV PCON,#00H<br>SETB TR1<br>MOV SCON,#50H<br>BLOOP1:     JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,#0E1H<br>JNZ BLOOP1<br>MOV SBUF,#0E2H<br>JNB TI,$<br>CLR TI<br>MOV R0,#30H<br>;MOV R7,#01H<br>MOV R6,#00H</li></ul><p>BLOOP2:JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>MOV @R0,A<br>;INC R0<br>ADD A,R6<br>MOV R6,A</p><p>;DJNZ R7,BLOOP2</p><p>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,R6</p><p>JZ END1<br>MOV SBUF,#0FFH<br>JNB TI,$<br>CLR TI<br>SJMP BLOOP1<br>END1:MOV SBUF,#00H    </p><p>;MOV P2,#0C0H<br>;ACALL ENABLE<br>MOV A,30H<br>MOV DPTR,#TABLE1<br>MOVC A,@A+DPTR<br>MOV P1,A      ;lcd的显示<br>ACALL WRITE<br>INC R1;<br>CJNE R1,#04H,JISHU<br>MOV P1,#0C0H<br>ACALL ENABLE<br>MOV R1,#05H</p><p>JISHU:LJMP BSTART</p><p>WRITE:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>DELAY:<br>MOV R4,#60<br>D1:MOV R5,#60<br>D2:MOV R6,#30<br>DJNZ R6,$<br>DJNZ R5,D2<br>DJNZ R4,D1<br>RET<br>KEYVALUE: DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH<br>TABLE: DB  30H, 31H, 32H, 33H ,34H ,35H ,36H, 37H, 38H, 39H ,41H, 42H, 43H, 44H, 45H, 46H<br>TABLE1:DB ‘1’,’8’,’0’,’3’,’P’,’E’,’N’,’G’,’C’,’H’,’E’,’N’,’L’,’I’,’A’,’G’<br>TABLE2:  DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH<br>TABLE3: DB “ PENG CHENLIANG “,00H<br>END</p><ul><li>Proteus 仿真电路图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_11.jpg"></li></ul><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3><p>本次制作的双机通讯系统是在键盘显示模块之后的又一个更加复杂的模块，不得不说双机通讯系统的设计确实比之前的两个模块难了很多难了很多。从发送端与接收端通讯协议的构建，到键盘扫描，键码获取和键码的发送与传输，每一步都存在很多问题，更加麻烦的是，如何把LCD的显示和通讯系统结合起来。<br>虽然硬件部分并没有遇到什么困难，但软件部分通讯协议的构建和通讯系统与LCD显示如何相结合的问题确实很让人困扰。经过反复思考后，在发送端的程序中，我把通讯信息发送的部分放在了键盘扫描的循环中，每按下一次键盘，系统就把扫描到的键码转换为键值，发送给接收端，并在发送端的LCD上把键值显示出来。而在接收端，我把LCD显示的程序放在了通讯接受的循环里，系统每接收到一个字符，就把字符显示到接收端的LCD上。由于每按下一次键盘只显示一个字符，故每次只发送一个字符即可。<br>在LCD显示时我还发现，两个LCDv0口需要的电压居然不一样，起初我还以为是两个LCD颜色不同，所以特性存在些许的差距，后来仔细检查后才发现，原来是两个单片机系统的GND没有接到一起，所以接在两个LCD的v0口接在同一个单片机系统的电位器上并不能正常运行。之后我把两个单片机系统的GND连到了一起，采用同一个电源供电，解决了这一问题。</p><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p> 本次实验模块的设计与制作确实比之前的复杂了很多，但我自己在这个过程中也得到了很大的提高与成长。<br>从通讯系统的构建，两个系统之间的应答，校验和的检验，到如何把键盘输入的字符正确地发送并正确地显示在LCD屏幕上，每一步充满了各种挫折和困顿。虽然硬件上利用了之前的系统，但软件上协议部分确实很让人头疼。写代码的过程中虽然遇到过很多挫败，也有过很多心情沮丧的时候，但更多的是知识的成长以及心中不断燃烧的好奇与热情，在这样的热情和兴趣下，自己一步步克服障碍，完成了双机通讯系统的设计制作。 虽然每一次看到bug是都很失落，但当最后看到自己的名字成功地显示到两个LCD的屏幕上时，就觉得所有的努力和付出都是值得的。<br>通过双机通讯系统的设计与制作，自己的的确确学到了很多。从知识方面来看，自己对通讯协议的构建有了初步的认识，了解到了如何在单片机之间进行串行通讯。另外，自己也对汇编语言有了更加深入而细致的认识，看到了汇编语言相对其他语言在单片机操作上的优势，看到了汇编语言的形象化与底层化。除此之外，自己通过这个过程，也收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。自己也十分期待下一次的实验模块制作，期待自己可以更好地运用所学的知识，制作出更好的作品。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章-系统整体概述&quot;&gt;&lt;a href=&quot;#第一章-系统整体概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 系统整体概述&quot;&gt;&lt;/a&gt;第一章 系统整体概述&lt;/h3&gt;&lt;p&gt;本次单片机双机通讯系统设计实验是通过单片机间的串行通讯控制两个单片机进行通信</summary>
      
    
    
    
    <category term="51单片机" scheme="http://yeyuwenxi.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="汇编" scheme="http://yeyuwenxi.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
