<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜雨闻曦</title>
  
  <subtitle>爱我所爱，行我所行</subtitle>
  <link href="http://yeyuwenxi.github.io/atom.xml" rel="self"/>
  
  <link href="http://yeyuwenxi.github.io/"/>
  <updated>2021-06-28T07:13:35.904Z</updated>
  <id>http://yeyuwenxi.github.io/</id>
  
  <author>
    <name>pcl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qt入门之简易计算器</title>
    <link href="http://yeyuwenxi.github.io/2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/"/>
    <id>http://yeyuwenxi.github.io/2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/</id>
    <published>2021-06-28T06:54:32.000Z</published>
    <updated>2021-06-28T07:13:35.904Z</updated>
    
    <content type="html"><![CDATA[<p>最近考完试比较闲了，简单学了一下qt,做了个最基本的计算器。</p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>通过可视化的方法，拖动实现界面<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_1.png" ></p><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><p>在头文件中实现类的定义和类内成员的声明</p><pre class="line-numbers language-none"><code class="language-none">class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent &#x3D; 0);    ~MainWindow();    int num1;    int num2;    double result;    int op;private slots:    void on_button_1_clicked();    void on_button_2_clicked();    void on_button_3_clicked();    void on_button_add_clicked();    void on_button_4_clicked();    void on_button_5_clicked();    void on_button_6_clicked();    void on_button_sub_clicked();    void on_button_7_clicked();    void on_button_8_clicked();    void on_button_9_clicked();    void on_button_mult_clicked();    void on_button_clear_clicked();    void on_button_0_clicked();    void on_button_equal_clicked();    void on_button_div_clicked();private:    Ui::MainWindow *ui;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在cpp文件中实现类内成员的定义</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;iostream&gt;using namespace std;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    this-&gt;setWindowTitle(&quot;计算器1.0&quot;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::on_button_1_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;1&quot;);&#125;void MainWindow::on_button_2_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;2&quot;);&#125;void MainWindow::on_button_3_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;3&quot;);&#125;void MainWindow::on_button_add_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;+&quot;);&#125;void MainWindow::on_button_4_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;4&quot;);&#125;void MainWindow::on_button_5_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;5&quot;);&#125;void MainWindow::on_button_6_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;6&quot;);&#125;void MainWindow::on_button_sub_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;-&quot;);&#125;void MainWindow::on_button_7_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;7&quot;);&#125;void MainWindow::on_button_8_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;8&quot;);&#125;void MainWindow::on_button_9_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;9&quot;);&#125;void MainWindow::on_button_mult_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;*&quot;);&#125;void MainWindow::on_button_clear_clicked()&#123; ui-&gt;textEdit-&gt;setText(&quot;&quot;);&#125;void MainWindow::on_button_0_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;0&quot;);&#125;void MainWindow::on_button_equal_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x3D;&quot;);       QString text &#x3D; ui-&gt;textEdit-&gt;toPlainText();       string text1&#x3D;text.toStdString();       &#x2F;&#x2F;cout&lt;&lt;text1&lt;&lt;endl;       &#x2F;&#x2F;cout&lt;&lt;text1[1]&lt;&lt;endl;       int len&#x3D;text1.size();       const char * text2&#x3D;text1.c_str();       cout&lt;&lt;text2;       int flag&#x3D;0;       num1&#x3D;0;       num2&#x3D;0;       op&#x3D;0;       result&#x3D;0;       for(int i&#x3D;0;i&lt;len;i++)&#123;       if(text2[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;text2[i]&lt;&#x3D;&#39;9&#39;)&#123;       if(flag&#x3D;&#x3D;0)&#123;           num1&#x3D;num1*10+text2[i]-&#39;0&#39;;       &#125;       if(flag&#x3D;&#x3D;1)&#123;           num2&#x3D;num2*10+text2[i]-&#39;0&#39;;       &#125;       &#125;else if(text2[i]&#x3D;&#x3D;&#39;+&#39;)&#123;           flag&#x3D;1;           op&#x3D;1;           cout&lt;&lt;&quot;+++&quot;&lt;&lt;endl;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;-&#39;)&#123;           flag&#x3D;1;           op&#x3D;2;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;*&#39;)&#123;           flag&#x3D;1;           op&#x3D;3;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)&#123;           flag&#x3D;1;           op&#x3D;4;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;           if(op&#x3D;&#x3D;1)&#123;               result&#x3D;num1+num2;               cout&lt;&lt;num1&lt;&lt;endl;               cout&lt;&lt;num2&lt;&lt;endl;           &#125;           if(op&#x3D;&#x3D;2)&#123;               result&#x3D;num1-num2;           &#125;           if(op&#x3D;&#x3D;3)&#123;               result&#x3D;num1*num2;           &#125;           if(op&#x3D;&#x3D;4)&#123;               result&#x3D;(num1*1.00)&#x2F;num2;           &#125;              ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);              ui-&gt;textEdit-&gt;insertPlainText(QString::number(result));       &#125;       &#125;&#125;void MainWindow::on_button_div_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x2F;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>qt整体的架构还是比较清晰的，界面和逻辑部分互相分离，又通过信号与槽进行必要的通信。<br>头文件中完成了类的定义，而对类的成员函数仅作声明，具体实现在cpp文件中完成，整个过程实现了类内声明，类外定义。<br>计算器的基本原理也比较简单，按下按钮时，字符附加到编辑框对应的字符串后，最后按下等号时读取整个字符串，分离两个操作数和一个运算符，进行计算，并将最后的计算结果显示到编辑框中。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>生成exe文件并通过命令行配置好注册表文件后，点击exe文件就可以正常运行了，运行结果如图所示。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_2.png" ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近考完试比较闲了，简单学了一下qt,做了个最基本的计算器。&lt;/p&gt;
&lt;h3 id=&quot;界面设计&quot;&gt;&lt;a href=&quot;#界面设计&quot; class=&quot;headerlink&quot; title=&quot;界面设计&quot;&gt;&lt;/a&gt;界面设计&lt;/h3&gt;&lt;p&gt;通过可视化的方法，拖动实现界面&lt;br&gt;&lt;img </summary>
      
    
    
    
    <category term="qt" scheme="http://yeyuwenxi.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="http://yeyuwenxi.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>51单片机最小系统pcb板</title>
    <link href="http://yeyuwenxi.github.io/2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/"/>
    <id>http://yeyuwenxi.github.io/2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/</id>
    <published>2021-06-03T05:34:47.000Z</published>
    <updated>2021-06-04T13:30:33.205Z</updated>
    
    <content type="html"><![CDATA[<p>最近画了块51单片机的最小系统，然后到捷配上把他打了出来。<br>下面直接放图</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_1.png" ></li><li>PCB正面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li><li>PCB背面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_3.jpg" width="60%" height="60%" style="transform:rotate(270deg)">总的来说，板子打的还可以，当然仍然避免不了某些小问题，系统库自己提供的电容封装不是很好，孔距有点大，焊盘有点小，另外布线也不是特别好。### 做个总结PCB画板还是一个比较靠经验的活，各种常见的封装，常见的库，这些都是要靠经验来一步步熟悉的。自己技术方向也不是做硬件，这方面估计也就浅尝辄止了，各种线宽，电磁兼容，信号完整性的东西应该也不会去学，画画板子，更多的还是拓展一下视野，平时有精力，还是应该多学一些软件方面的东西。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近画了块51单片机的最小系统，然后到捷配上把他打了出来。&lt;br&gt;下面直接放图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理图&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_1.png&quot; </summary>
      
    
    
    
    <category term="51单片机" scheme="http://yeyuwenxi.github.io/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
  </entry>
  
  <entry>
    <title>STM32实现矩阵键盘</title>
    <link href="http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/"/>
    <id>http://yeyuwenxi.github.io/2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/</id>
    <published>2021-05-30T10:45:21.000Z</published>
    <updated>2021-05-30T10:58:45.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。<br>虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。<br>相比于51单片机，32的io口是要考虑io方向和io模式的。<br>自己参考网上的一个例子写的代码，没想到被误导了，将4个io口设为上拉输入，另外4个io口设为下拉输入，按键按下的时候先检测行，再检测列，没想到遇到了点莫名奇妙的问题，不管怎么接线，总有两行按键检测不到。<br>于是我怀疑是不是io模式的问题，上拉输入和下拉输入接在一起，产生的情况可能是无法预测的。<br>我修改io模式为4个下拉输入，另外4个推挽输出高电平之后，果然解决了这一问题。<br>对于某些细节方面的东西，有时候还是不能想当然地认为会怎么样啊。</p><h3 id="下附代码"><a href="#下附代码" class="headerlink" title="下附代码"></a>下附代码</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;低四位输出高，高四位下拉输入void KEY_Init1(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1;GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);   GPIO_SetBits(GPIOA,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);&#125; &#x2F;&#x2F;低四位下拉输入，高四位输出高void KEY_Init2(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1; GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);GPIO_SetBits(GPIOA,GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);&#125; &#x2F;&#x2F;函数名：扫描函数&#x2F;&#x2F;返回值：有效键值或-1&#x2F;&#x2F;功能：矩阵按键扫描，返回一个值short KeyPad_Scan(void)&#123;short num &#x3D; -1; &#x2F;&#x2F;保持按键值返回u16 readvalue &#x3D; 0;u16 re&#x3D;0;u16 re1&#x3D;0;u16 re2&#x3D;0;KEY_Init1();&#x2F;&#x2F;低4位引脚输出高，高4位引脚下拉输入readvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;&#x2F;&#x2F;保留低8位的值（PA7-PA0）if(readvalue !&#x3D; 0x000f) &#x2F;&#x2F;高4位引脚有一个被按下&#123;delay_ms(10);&#x2F;&#x2F;消抖10msreadvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;if(readvalue !&#x3D; 0x000f)&#123;re1 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re1 &amp;&#x3D; 0x00f0;  &#x2F;&#x2F;保留PA4-PA7的值KEY_Init2();  &#x2F;&#x2F;低4位引脚下拉输入，高4位输出高delay_ms(10);re2 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re2 &amp;&#x3D; 0x000f;&#x2F;&#x2F;保留PA0-PA3的值while((GPIO_ReadInputData(GPIOA)&amp;0x00ff)!&#x3D;0x00f0);&#x2F;&#x2F;等待按键松开re&#x3D;re1|re2;&#x2F;&#x2F;取或，就知道哪一行哪一列被按下啦switch(re)&#123;case 0x0011: num &#x3D; 12;break;  case 0x0012: num &#x3D; 8;break;  case 0x0014: num &#x3D; 4;break; case 0x0018: num &#x3D; 0;break;  case 0x0021: num &#x3D; 13;break;  case 0x0022: num &#x3D; 9;break; case 0x0024: num &#x3D; 5;break;  case 0x0028: num &#x3D; 1;break;  case 0x0041: num &#x3D; 14;break;  case 0x0042: num &#x3D; 10;break;  case 0x0044: num &#x3D; 6;break;  case 0x0048: num &#x3D; 2;break;  case 0x0081: num &#x3D; 15;break;  case 0x0082: num &#x3D; 11;break;  case 0x0084: num &#x3D; 7;break;  case 0x0088: num &#x3D; 3;break;  &#125;return num;&#125;&#125;return -1;&#125;int main()&#123;  delay_init();     &#x2F;&#x2F;延时函数初始化  NVIC_Configuration();  &#x2F;&#x2F;设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init();     &#x2F;&#x2F;LED端口初始化  &#x2F;&#x2F;OLED_Init();&#x2F;&#x2F;初始化OLED  &#x2F;&#x2F;OLED_Clear()  ;  uart_init(115200); &#x2F;&#x2F;串口初始化为115200while(1)&#123;short key&#x3D;0;key&#x3D;KeyPad_Scan();if(key!&#x3D;-1)&#123;printf(&quot;key&#x3D;&quot;);printf(&quot;%d\n&quot;,key);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/Daniel__Lai/article/details/108916185?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162237210816780271566581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162237210816780271566581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-8-108916185.first_rank_v2_pc_rank_v29&utm_term=STM32%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE&spm=1018.2226.3001.4187">STM32的矩阵键盘扫描及处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。&lt;br&gt;虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。&lt;br&gt;相比于51单片机，32的io口是要考虑io方向和io模式的</summary>
      
    
    
    
    <category term="STM32单片机" scheme="http://yeyuwenxi.github.io/categories/STM32%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>第一次PCB打板</title>
    <link href="http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/"/>
    <id>http://yeyuwenxi.github.io/2021/05/28/di-yi-ci-pcb-da-ban/</id>
    <published>2021-05-28T08:41:34.000Z</published>
    <updated>2021-05-28T09:08:28.609Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下第一次打PCB板。<br>虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。<br>第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。<br>这次板子主要就是一个简单的流水灯和4x4的矩阵键盘，自己手动画了画四角按键的封装。<br>画完之后就向捷配上传了工程文件和生产文件，几天后收到了板子，没想到的是居然发了六块。<br>下面直接放图</p><ul><li>PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_1.jpg" width="60%" height="60%" style="transform:rotate(270deg)"   ></li><li>焊接成品<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li></ul><p>总的来说，这次打板还是比较成功的，当然也有一些小细节做的不是很好</p><ul><li>流水灯和矩阵按键的接口排针放在了两侧，相对来说还是放在一侧比较好。</li><li>矩阵键盘行与行之间间隙略大</li><li>布线不是特别好看</li><li>流水灯其实可以放8个的，比6个更好写程序</li></ul><p>另外本次打板没有铺铜，主要是没有确定的地，也没有哪个网络比其他网络要大很多。问了一些专业人士，简单的二层板不铺铜的话，也没有特别大的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下第一次打PCB板。&lt;br&gt;虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。&lt;br&gt;第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。&lt;br&gt;这次板</summary>
      
    
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/categories/PCB/"/>
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
    <category term="矩阵键盘" scheme="http://yeyuwenxi.github.io/tags/%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>esp32入门</title>
    <link href="http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/"/>
    <id>http://yeyuwenxi.github.io/2021/05/24/esp32-ru-men/</id>
    <published>2021-05-24T08:13:02.000Z</published>
    <updated>2021-06-04T14:18:42.115Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算做一个物联网的应用，买了块ESP32的开发板。</p><h3 id="ESP32的简单介绍"><a href="#ESP32的简单介绍" class="headerlink" title="ESP32的简单介绍"></a>ESP32的简单介绍</h3><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><p>ESP32支持使用arduino,espif等进行开发，可供使用的开发编辑器也有很多。<br>我们由简到难，先从最简单的开始，这里使用arduino IDE加上ESP32的arduino包进行开发。<br>开发环境搭建详见下文<br><a href="https://blog.csdn.net/dpjcn1990/article/details/94414983">ESP32 开发之旅① 走进ESP32的世界 安装开发环境</a></p><h3 id="烧录遇到的问题"><a href="#烧录遇到的问题" class="headerlink" title="烧录遇到的问题"></a>烧录遇到的问题</h3><p>安装完CP2102的驱动后，连到电脑上居然无法下载，串口时断时续的，后来采用自己的USB转TTL的烧录器成功地烧录了程序。<br>跟客服聊了聊，认为是CP2102的芯片坏了，客服直接发了块新的给我，而且说旧的不用退了。<br>这里强推一波优信电子！物美价廉，客服也很周到！</p><h3 id="arduino开发环境介绍"><a href="#arduino开发环境介绍" class="headerlink" title="arduino开发环境介绍"></a>arduino开发环境介绍</h3><p>arduino既有自己的硬件平台，又有一个基于arduino IDE的软件框架，arduino IDE属实不好用，连个最基本的函数查找都做不到，但arduino本身的框架封装了很多简单易用的函数，而且网上基于这一框架有很多有趣的开发实例，这里我们主要使用arduino的框架进行开发。</p><h3 id="开发板原理图"><a href="#开发板原理图" class="headerlink" title="开发板原理图"></a>开发板原理图</h3><p>最离谱的是，淘宝商家居然没有提供原理图，自己在网上搜索才找到了一张跟手上开发板一样的原理图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210604_1.png" ></p><h3 id="helloworld程序"><a href="#helloworld程序" class="headerlink" title="helloworld程序"></a>helloworld程序</h3><p>编写程序如下，编译完成后点击上传烧录到单片机中。<br><strong>注意:</strong> 烧录时屏幕下方出现connecting时按住boot按钮不放，直到烧录完成后松开boot按钮，此时，按一下复位按钮，程序就可以在单片机上正常运行了。<br>打开arduino IDE中的串口监视器，可以看到每秒都会收到一次单片机发送的helloworld.<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210524_1.png" ></p><h3 id="点灯程序"><a href="#点灯程序" class="headerlink" title="点灯程序"></a>点灯程序</h3><p>这块开发板上自带两个LED，其中红色的应该时电源指示灯，不受我们控制。<br>网上查询发现蓝色的LED，应该时接在GPIO2上，下面我们写一个驱动程序控制蓝色LED闪烁。<br>编写程序如下，并烧录到单片机中，可以看到LED正常闪烁。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;WiFi.h&gt;#define LED       2void setup() &#123;   pinMode(LED, OUTPUT);  &#125;void loop() &#123;  digitalWrite(LED, LOW);  delay(1000);  digitalWrite(LED, HIGH);  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算做一个物联网的应用，买了块ESP32的开发板。&lt;/p&gt;
&lt;h3 id=&quot;ESP32的简单介绍&quot;&gt;&lt;a href=&quot;#ESP32的简单介绍&quot; class=&quot;headerlink&quot; title=&quot;ESP32的简单介绍&quot;&gt;&lt;/a&gt;ESP32的简单介绍&lt;/h3&gt;&lt;h3 id</summary>
      
    
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="esp32" scheme="http://yeyuwenxi.github.io/tags/esp32/"/>
    
  </entry>
  
  <entry>
    <title>开博客的初心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/23/kai-bo-ke-de-chu-xin/</id>
    <published>2021-05-22T16:07:12.000Z</published>
    <updated>2021-05-22T16:18:27.528Z</updated>
    
    <content type="html"><![CDATA[<p>好多天没写博客了，今天开个新篇，反省一下。<br>做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。<br>这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。<br>动态的框架也尝试过typecho和wordpress。<br>折腾了一大堆，文章倒是好久没写了，不知不觉方向就走的有点偏了。<br>博客的框架，样式，音乐，其实并没有那么重要，只适合刚开始学框架图个新鲜罢了，内容才是博客的本质。<br>这么多框架，如果不是为了更好的写文章，而是沉迷于各种框架的细节，那就真的偏离自己的方向了。<br>所以接下来，还是明确一点，认真学技术，积极写文章。<br>平时少看各种无意义的东西，静下心来沉淀自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好多天没写博客了，今天开个新篇，反省一下。&lt;br&gt;做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。&lt;br&gt;这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。&lt;br&gt;动态的框架也尝试过typ</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云何降伏其心</title>
    <link href="http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/"/>
    <id>http://yeyuwenxi.github.io/2021/05/17/yun-he-jiang-fu-qi-xin/</id>
    <published>2021-05-17T15:30:54.000Z</published>
    <updated>2021-05-17T16:05:34.689Z</updated>
    
    <content type="html"><![CDATA[<p>人的欲望不满足就痛苦，满足了就无聊。<br>我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。<br>渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。<br>等到不渴的时候，再多的水放在自己面前也觉得乏味无比。<br>曾有一段时间，眼睛特别肿，眨下眼都难受，做什么事情都会想着眼睛，那时候才想起平时健康的时候生活有多么的快乐。<br>可等到眼睛好了，无所事事的时候又是枯燥和无聊，丝毫不记得曾经满心期待的快乐生活。<br>或许遗忘是人类的本能吧，总是不太长记性，痛苦的时候渴望平淡的生活，等生活平淡了又空虚无比，亟待刺激。<br>我们的心似乎总是躁动无比，安定不下来，总是需要寻求刺激来掩盖空虚，像是音乐，游戏，又或是需要痛苦来压制欲望，抽烟，喝酒，莫不是如此。</p><p>孔子云，食色性也。<br>生而为人，某些东西是刻在基因里的，谁也不可能做到无欲，所以一个很重要的问题就是如何面对自己的欲望。<br>吃好吃的，喝好喝的，玩好玩的，这都是我们的欲望，有欲也无可厚非，只要做到适度即可。</p><p>欲望可以适当满足，痛苦也可以合理规避，但还有一个问题确实很难解决的？<br>我们那什么来面对平凡的生活？那什么了面对内心的空虚和无聊？<br>金刚经有问，云何降伏其心？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人的欲望不满足就痛苦，满足了就无聊。&lt;br&gt;我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。&lt;br&gt;渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。&lt;br&gt;等到不渴的时候，再多的水放在自己面前也觉得乏味无比。&lt;br&gt;曾有一段时间</summary>
      
    
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/categories/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="心情日记" scheme="http://yeyuwenxi.github.io/tags/%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>队列和栈专题</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/dui-lie-he-zhan-zhuan-ti/</id>
    <published>2021-04-27T13:32:40.000Z</published>
    <updated>2021-05-03T09:21:33.612Z</updated>
    
    <content type="html"><![CDATA[<p>写篇文章，总结一下栈和队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。<br>主要包括压栈，出栈，查看栈顶元素三种操作。</p><h4 id="C语言数组实现顺序栈"><a href="#C语言数组实现顺序栈" class="headerlink" title="C语言数组实现顺序栈"></a>C语言数组实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;数组实现顺序栈typedef struct zhan &#123;char data[100];int top;&#125;zhan;void initzhan(zhan *a)&#123;a-&gt;top &#x3D; -1;&#125;void push(zhan* a, char b) &#123;a-&gt;data[++a-&gt;top] &#x3D; b;&#125;char pop(zhan* a) &#123;return a-&gt;data[a-&gt;top--];&#125;char gettop(zhan* a) &#123;return a-&gt;data[a-&gt;top];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言指针实现顺序栈"><a href="#C语言指针实现顺序栈" class="headerlink" title="C语言指针实现顺序栈"></a>C语言指针实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;指针实现顺序栈typedef struct stack &#123;int* top;int* base;&#125;stack;void initstack(stack* a) &#123;a-&gt;base &#x3D; (int*)malloc(sizeof(int)*100);&#x2F;&#x2F;最大空间为100a-&gt;top &#x3D; a-&gt;base;&#125;void pushstack(stack* a, int b)&#123;*a-&gt;top &#x3D; b;a-&gt;top++;&#125;int popstack(stack* a) &#123;a-&gt;top--;return *a-&gt;top;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言实现链栈"><a href="#C语言实现链栈" class="headerlink" title="C语言实现链栈"></a>C语言实现链栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;链栈的实现typedef struct stack &#123;int data;struct stack *next;&#125;stack;void initstack(stack*a) &#123;&#x2F;&#x2F;stack* p;&#x2F;&#x2F;a &#x3D; p &#x3D; (stack*)malloc(sizeof(stack));&#x2F;&#x2F;a-&gt;next &#x3D; NULL;&#125;void pushstack(stack* a,int b) &#123;stack* p;p &#x3D; (stack*)malloc(sizeof(stack));p-&gt;data &#x3D; b;p-&gt;next &#x3D; a-&gt;next;a-&gt;next &#x3D; p;&#125;int popstack(stack * a)&#123;stack* p;int b;p &#x3D; a-&gt;next;b&#x3D; p-&gt;data;a-&gt;next &#x3D; p-&gt;next;free(p);return b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-的栈"><a href="#C-的栈" class="headerlink" title="C++的栈"></a>C++的栈</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;stack&gt;初始化出栈压栈取栈顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="C-的队列"><a href="#C-的队列" class="headerlink" title="C++的队列"></a>C++的队列</h4><h3 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h3><p>来自leetcode的一道题目。<br>挺有启发性的，如何用两个队列实现一个栈。</p><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    queue&lt;int&gt; queue1;    queue&lt;int&gt; queue2;    MyStack() &#123;         &#125;        &#x2F;** Push element x onto stack. *&#x2F;    void push(int x) &#123;       &#x2F;&#x2F;queue2做辅助队列，用来翻转queue1,同理，一个队列也可以实现       while(!queue1.empty())&#123;        int a&#x3D;queue1.front();        queue1.pop();        queue2.push(a);      &#125;      queue1.push(x);      while(!queue2.empty())&#123;        int a&#x3D;queue2.front();        queue2.pop();        queue1.push(a);      &#125;    &#125;        &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;    int pop() &#123;     int a&#x3D; queue1.front();     queue1.pop();     return a;    &#125;        &#x2F;** Get the top element. *&#x2F;    int top() &#123;     return queue1.front();    &#125;        &#x2F;** Returns whether the stack is empty. *&#x2F;    bool empty() &#123;   return queue1.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>来自leetcode的另一个题目，用两个栈实现一个队列。</p><pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    stack&lt;int&gt; a;    stack&lt;int&gt; b;    MyQueue() &#123;    &#125;        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) &#123;     while(!a.empty())&#123;         int c&#x3D;a.top();         a.pop();         b.push(c);     &#125;     a.push(x);     while(!b.empty())&#123;         int c&#x3D;b.top();         b.pop();         a.push(c);     &#125;    &#125;        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() &#123;        int c&#x3D;a.top();        a.pop();          return c ;    &#125;        &#x2F;** Get the front element. *&#x2F;    int peek() &#123;                 return a.top();    &#125;        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() &#123;      return a.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写篇文章，总结一下栈和队列&lt;/p&gt;
&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。&lt;br&gt;主要包括压栈，出栈，查看栈顶元</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="队列" scheme="http://yeyuwenxi.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://yeyuwenxi.github.io/tags/%E6%A0%88/"/>
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法总结</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/</id>
    <published>2021-04-27T13:29:49.000Z</published>
    <updated>2021-05-17T07:19:26.471Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些常用的排序算法。</p><p>先定义一个数组用来进行接下来的排序</p><pre class="line-numbers language-none"><code class="language-none">int num[] &#x3D; &#123; 4,9,7,15,67,89,97,123,468,12,34,76,8,9,4,1,80,100 &#125;;&#x2F;&#x2F;获取数组长度int length;length &#x3D; sizeof(num) &#x2F; sizeof(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下皆为从小到大的排序</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length - 1; i++) &#123;for (int j &#x3D; 0; j &lt; length - 1-i; j++) &#123;if (num[j] &gt; num[j + 1]) &#123;int t &#x3D; num[j];num[j] &#x3D; num[j + 1];num[j + 1] &#x3D; t;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length; i++) &#123;int min &#x3D; num[i];for (int j &#x3D; i; j &lt; length; j++) &#123;if (min &gt; num[j]) &#123;int t &#x3D; min;min &#x3D; num[j];num[j] &#x3D; t;&#125;&#125;num[i] &#x3D; min;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;先定义一个交换函数void exchange(int* p, int* q) &#123;int temp &#x3D; *p;*p &#x3D; *q;*q &#x3D; temp;&#125;int quaipai(int left, int right) &#123;&#x2F;&#x2F;双指针相遇，排序结束if (left &gt;&#x3D; right) &#123;return 0;&#125;int i,j, t;&#x2F;&#x2F;左右指针及基准i &#x3D; left;j &#x3D; right;t &#x3D; num[left];&#x2F;&#x2F;移动函数while (i !&#x3D; j) &#123;while (i &lt; j &amp;&amp; num[j] &gt;&#x3D; t) &#123;j--;&#125;exchange(&amp;num[i], &amp;num[j]);        while (i &lt; j &amp;&amp; num[i] &lt;&#x3D; t) &#123;i++;                                     &#125;exchange(&amp;num[i], &amp;num[j]);&#125;&#x2F;&#x2F;递归此过程quaipai(i + 1, right);quaipai(left, i - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一些常用的排序算法。&lt;/p&gt;
&lt;p&gt;先定义一个数组用来进行接下来的排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;int num[] &amp;#x3D; &amp;#123; 4,9</summary>
      
    
    
    
    <category term="数据结构" scheme="http://yeyuwenxi.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ STL学习笔记</title>
    <link href="http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/04/27/c-stl-xue-xi-bi-ji/</id>
    <published>2021-04-27T13:02:25.000Z</published>
    <updated>2021-05-03T09:20:56.216Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。<br>Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。<br>写个帖子，做一些记录。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>见得最多的容器，还是数vector.<br>vector可以看做是一个动态的数组。</p><ul><li>常见用法<br>初始化<br>vector<int> a;<br>a.size();<br>a.empty();</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue<int> a;<br>a.pop();<br>a.push(x);<br>a.front();<br>a.empty();<br>a.size();</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack<int> a;<br>a.pop();<br>a.push(x);<br>a.top();<br>a.empty();<br>a.size();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。&lt;br&gt;Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。&lt;br&gt;写个帖子，做一些记录。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://yeyuwenxi.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://yeyuwenxi.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>esp8266通过串口发送http请求</title>
    <link href="http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/"/>
    <id>http://yeyuwenxi.github.io/2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/</id>
    <published>2021-04-26T01:31:57.000Z</published>
    <updated>2021-05-03T09:18:14.755Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。<br>仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。<br>不得不说，计算机网络的一些知识好久不用都忘的差不多了，有些东西果然还是要在实践中加强认识。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><h4 id="http请求头"><a href="#http请求头" class="headerlink" title="http请求头"></a>http请求头</h4><p>请求头包括四个部分：<br>请求行<br>请求首部<br>空行<br>请求正文</p><h4 id="http返回头"><a href="#http返回头" class="headerlink" title="http返回头"></a>http返回头</h4><p>返回头同样包括四个部分：<br>状态行<br>消息报头<br>空行<br>响应正文</p><h3 id="通过网络调试助手测试"><a href="#通过网络调试助手测试" class="headerlink" title="通过网络调试助手测试"></a>通过网络调试助手测试</h3><p>我们测试使用的api如下<br><a href="http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8">http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8</a><br>这是果创云提供的一个天气查询的接口，通过发送get请求，可以得到对应城市的天气，返回的数据类型为json格式。<br>我们先使用浏览器访问一下这个接口<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_1.png" ><br>由于网络调试助手的限制，我们必须要知道api的服务器地址和端口号<br>在浏览器上点击检查网页，在network标签下的header标签中可以找到我们想要的信息</p><p>通过网络调试助手，输入刚刚查到的ip和端口号，建立一个tcp连接<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_2.png" ><br>发送相应格式的请求，可以看到，我们已经收到了api接口返回的数据<br>（这里由于调试助手编码格式的问题，中文会显示乱码）</p><h3 id="esp8266通过TCP透传发送http请求"><a href="#esp8266通过TCP透传发送http请求" class="headerlink" title="esp8266通过TCP透传发送http请求"></a>esp8266通过TCP透传发送http请求</h3><p>调试时遇到了挺大的bug,模块的硬件电路出了点莫名其妙的问题，串口连接模块后，发送任何指令都没有反应，后来拿电压表测了一下，模块上电后CH_PD居然是低电平，于是又自己把CH_PD拉到高电平，解决了这一问题。<br>esp8266连接串口之后，依次发送如下指令：<br><code>AT+RST</code><br>//复位模块<br><code>AT+CWMODE=1</code><br>//进入STA模式<br><code>AT+RST</code><br>//复位生效上一条命令<br><code>AT+CWJAP=”note”,”123456789” </code><br>//连接到wifi<br><code>AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.1.115&quot;,8080</code><br>//连接到tcp服务器<br><code>AT+CIPMODE=1</code><br>//开启透传模式<br><code>AT+CIPSEND</code><br>//进入透传</p><p>进入透传后，发送以下数据<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_3.png" ><br>可以看到，我们成功地收到了服务器返回的接口数据<br>（由于电脑编码格式问题，此处存在乱码）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。&lt;br&gt;仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。&lt;br&gt;</summary>
      
    
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/categories/esp8266/"/>
    
    
    <category term="esp8266" scheme="http://yeyuwenxi.github.io/tags/esp8266/"/>
    
  </entry>
  
  <entry>
    <title>Android实现mqtt客户端</title>
    <link href="http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/25/android-shi-xian-mqtt-ke-hu-duan/</id>
    <published>2021-04-25T14:26:16.000Z</published>
    <updated>2021-04-25T15:16:46.513Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。</p><h3 id="在gradle中添加依赖"><a href="#在gradle中添加依赖" class="headerlink" title="在gradle中添加依赖"></a>在gradle中添加依赖</h3><pre class="line-numbers language-none"><code class="language-none">implementation &#39;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0&#39;implementation &#39;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="添加相关的权限"><a href="#添加相关的权限" class="headerlink" title="添加相关的权限"></a>添加相关的权限</h3><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.WAKE_LOCK&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p><code>&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot;&gt;&lt;/service&gt;</code></p><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><ul><li>xml<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;zhuti&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的主题&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;neirong&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的内容&quot;        &#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;button&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;发送&quot;        &#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;textView&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>MainActivity.java<pre class="line-numbers language-none"><code class="language-none">import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;public class MainActivity extends AppCompatActivity &#123;    EditText zhuti;    EditText neirong;    Button fasong;    TextView jieshou;    MqttClient client;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F;App lianjie&#x3D;new App();        String subTopic &#x3D; &quot;test&quot;;        String pubTopic &#x3D; &quot;test&quot;;        String content &#x3D; &quot;Hello World&quot;;        int qos &#x3D; 2;        String broker &#x3D; &quot;tcp:&#x2F;&#x2F;49.235.68.28:1883&quot;;        String clientId &#x3D; &quot;emqx_test&quot;;        MemoryPersistence persistence &#x3D; new MemoryPersistence();        Log.i(&quot;aaa&quot;, &quot;运行中&quot;);        zhuti&#x3D;findViewById(R.id.zhuti);        neirong&#x3D;findViewById(R.id.neirong);        fasong&#x3D;findViewById(R.id.button);        jieshou&#x3D;findViewById(R.id.textView);        try &#123;             client &#x3D; new MqttClient(broker, clientId, persistence);            &#x2F;&#x2F; MQTT 连接选项            MqttConnectOptions connOpts &#x3D; new MqttConnectOptions();            connOpts.setUserName(&quot;emqx_test&quot;);            connOpts.setPassword(&quot;emqx_test_password&quot;.toCharArray());            &#x2F;&#x2F; 保留会话            connOpts.setCleanSession(true);            &#x2F;&#x2F; 设置回调            client.setCallback(new OnMessageCallback1());            &#x2F;&#x2F; 建立连接            Log.i(&quot;abc&quot;, &quot;Connecting to broker: &quot; + broker);            client.connect(connOpts);            Log.i(&quot;bcd&quot;, &quot;Connected&quot;);            Log.i(&quot;cde&quot;, &quot;Publishing message: &quot; + content);            &#x2F;&#x2F; 订阅            client.subscribe(subTopic);            &#x2F;&#x2F; 消息发布所需参数            MqttMessage  message &#x3D; new MqttMessage(content.getBytes());            message.setQos(qos);            client.publish(pubTopic, message);            Log.i(&quot;def&quot;, &quot;Message published&quot;);            &#x2F;&#x2F;client.disconnect();            &#x2F;&#x2F; Log.i(&quot;efg&quot;,&quot;Disconnected&quot;);            &#x2F;&#x2F; client.close();            &#x2F;&#x2F;System.exit(0);        &#125; catch (MqttException me) &#123;            Log.i(&quot;1&quot;, &quot;reason &quot; + me.getReasonCode());            Log.i(&quot;2&quot;, &quot;msg &quot; + me.getMessage());            Log.i(&quot;3&quot;, &quot;loc &quot; + me.getLocalizedMessage());            Log.i(&quot;4&quot;, &quot;cause &quot; + me.getCause());            Log.i(&quot;5&quot;, &quot;excep &quot; + me);            me.printStackTrace();        &#125;        fasong.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;            if(zhuti.getText().toString().equals(&quot;&quot;)||neirong.getText().toString().equals(&quot;&quot;))&#123;                Toast.makeText(MainActivity.this, &quot;请输入主题和内容&quot;, Toast.LENGTH_SHORT).show();            &#125;            else&#123;                try &#123;                    MqttMessage  message &#x3D; new MqttMessage(neirong.getText().toString().getBytes());                    message.setQos(qos);                    client.publish(zhuti.getText().toString(), message);                &#125; catch (MqttException e) &#123;                    e.printStackTrace();                &#125;&#125;            &#125;        &#125;);    &#125;&#x2F;&#x2F;回调函数 class OnMessageCallback1 implements MqttCallback &#123;    public void connectionLost(Throwable cause) &#123;        &#x2F;&#x2F; 连接丢失后，一般在这里面进行重连        Log.i(&quot;duankai&quot;,&quot;连接断开，可以做重连&quot;);    &#125;    public void messageArrived(String topic, MqttMessage message) throws Exception &#123;        &#x2F;&#x2F; subscribe后得到的消息会执行到这里面        Log.i(&quot;xiaoxi&quot;,&quot;接收消息主题:&quot; + topic);        Log.i(&quot;qos&quot;,&quot;接收消息Qos:&quot; + message.getQos());        Log.i(&quot;neirong&quot;,&quot;接收消息内容:&quot; + new String(message.getPayload()));        runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以        &#123;            public void run()            &#123;                &#x2F;&#x2F; TODO Auto-generated method stub               &#x2F;&#x2F; Toast.makeText(MainActivity.this, new String(message.getPayload()), Toast.LENGTH_SHORT).show();               jieshou.append(new String(message.getPayload())+&quot;\n&quot;);            &#125;        &#125;);    &#125;    public void deliveryComplete(IMqttDeliveryToken token) &#123;        Log.i(&quot;delivery&quot;,&quot;deliveryComplete---------&quot; + token.isComplete());    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>模拟器与真机均测试通过<br>以下是模拟器测试的图片<br>app默认订阅了test主题，发送消息的主题可自己设置</li><li>app<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_7.png" width="60%" height="60%"></li><li>websocket(一个在线的mqtt客户端)<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_8.png" ></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/jqnl/p/12660824.html">MQTT协议实现Android中的消息收发</a><br><a href="https://docs.emqx.cn/broker/v4.3/development/java.html">EMQX开发文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。&lt;/p&gt;
&lt;h3 id=&quot;在gradle中添加依赖&quot;&gt;&lt;a href=&quot;#在gradle中添加依赖&quot; class=&quot;headerlink&quot; title=&quot;在gradle中添加依赖&quot;&gt;&lt;/a&gt;在gradle中</summary>
      
    
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/categories/mqtt/"/>
    
    
    <category term="Android" scheme="http://yeyuwenxi.github.io/tags/Android/"/>
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>mqtt服务器的搭建</title>
    <link href="http://yeyuwenxi.github.io/2021/04/25/mqtt-fu-wu-qi-de-da-jian/"/>
    <id>http://yeyuwenxi.github.io/2021/04/25/mqtt-fu-wu-qi-de-da-jian/</id>
    <published>2021-04-25T04:39:23.000Z</published>
    <updated>2021-04-25T08:14:37.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><em>(以上内容来自百度百科)</em></p><p>mqtt是一种基于发布/订阅的消息传输协议，客户端可以发送或接受某个主题的消息，而服务器则是用来为各个客户端推送消息的中间件，通常称为代理。</p><p>通俗地说，如果把我们每个人的qq账号看做是客户端，那么腾讯的服务器就类似于mqtt的代理，只有有了这个代理，各个客户端之间才能正常通信，所以说代理（mqtt服务器）是mqtt通信的重要组成部分。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下面直接进入正题，开始我们mqtt服务器的搭建。<br>常见的mqtt服务器软件有很多种，这里我们采用EMQX来进行我们mqtt服务器的搭建。<br>EMQX的使用文档如下:<br><a href="https://docs.emqx.cn/broker/v4.3/">EMQX</a></p><p>首先登陆自己购买的服务器的管理界面（我这里使用的是腾讯云的服务器），打开webshell连接到服务器。<br>在webshell中输入以下命令:<br><code>curl https://repos.emqx.io/install_emqx.sh | bash</code><br>如果显示权限不够，请切换到root用户执行该命令</p><ul><li>显示以下结果，则说明安装成功</li></ul><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_1.png" ><ul><li>最后，在shell中输入<code>emqx start</code>启动mqtt服务器</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。</p><p>我们可以通过ip:18083来访问dashboard.<br>如果访问失败，检查服务器的安全组规则是否放行该端口。<br>Dashboard的默认用户名是 admin，密码是 public。<br>在设置中可以将语言改成中文。<br>dashboard提供了一个websocket,可以作为一个在线的mqtt客户端来进行测试。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_2.png" ></li></ul><p>我们可以使用一个本地的mqtt客户端，来和websocket进行通信。<br>这里我们使用mqttx来进行测试，下载链接如下。<br><a href="https://mqttx.app/cn/">mqttx客户端</a></p><p>在websocket中订阅一个test主题，并在该主题下发布消息，可以看到，在下方的列表中显示了该主题下的消息。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_3.png" >使用本地的mqtt客户端连接到mqtt服务器</li><li>本地客户端连接到服务器<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_4.png" ></li><li>在本地mqtt客户端订阅test主题，并在test主题下发布消息“hello”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_5.png" ></li><li>在websocket订阅test主题，并在test主题下发布消息“hi”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_6.png">可以看到，websocket和本地的mqtt客户端都收到了他们互相发布的消息，测试成功。同时，我们也可以看到，当客户端订阅一个主题的时候，即使主题下有一个消息是自己发布的，客户端也会收到这个消息。</li></ul><h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publis</summary>
      
    
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/categories/mqtt/"/>
    
    
    <category term="mqtt" scheme="http://yeyuwenxi.github.io/tags/mqtt/"/>
    
  </entry>
  
  <entry>
    <title>c语言在函数中修改外部指针变量的值</title>
    <link href="http://yeyuwenxi.github.io/2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/"/>
    <id>http://yeyuwenxi.github.io/2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/</id>
    <published>2021-04-18T07:31:17.000Z</published>
    <updated>2021-04-18T09:03:27.655Z</updated>
    
    <content type="html"><![CDATA[<p>最近又开始学数据结构了，总结一下之前写链表时遇到的一个问题。<br>如何在函数中修改一个外部指针变量的值，注意，是指针变量本身的值，而不是指针指向的变量的值，也就是说，我们要在函数中改变指针的指向。<br>先来看一个例子吧</p><ul><li>示例1<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在redirect函数中，s指向了b，但是p并未指向b,p中储存的仍然是a的地址。<br>这是为什么呢？<br>指针s并不是指针p本身，它仅仅是指针p的一个副本，储存了指针p的值，也就是说，指针s其实是另一个变量，它储存的地址和p储存的地址是一样的，但是改变s储存的地址，并不会改变p储存的地址。</li></ul><p>那我们怎么才能在函数中改变指针的指向呢？<br>我们知道，函数是默认传递值的，而不是传递地址，想要改变一个普通变量的值，我们就需要传递它的指针给函数。<br>那么，想要改变指针变量的值，我们就需要传递指针的指针给函数，没错，需要使用二级指针来改变指针的值。</p><ul><li>示例2<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">*</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，这时p已经指向了b,即我们成功地在函数中改变了指针p的值。</li></ul><p>此外，我们也可以通过引用在函数中改变指针的值。</p><ul><li>示例3：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，此时p也指向了b.</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>c语言在传递函数的参数时，传递给函数的，并不是变量本身，而是变量的一个拷贝。<br>只有在使用引用时，传递给函数的才是变量本身。<br>要想在函数中改变一个普通变量的值，我们需要使用指针来实现，那么要想在函数中改变一个指针变量的值，我们需要使用指针的指针，即二级指针来实现。<br>此外，也可以通过使用引用，传递变量本身来实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近又开始学数据结构了，总结一下之前写链表时遇到的一个问题。&lt;br&gt;如何在函数中修改一个外部指针变量的值，注意，是指针变量本身的值，而不是指针指向的变量的值，也就是说，我们要在函数中改变指针的指向。&lt;br&gt;先来看一个例子吧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例1&lt;pre clas</summary>
      
    
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c语言" scheme="http://yeyuwenxi.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>MSP432入门之流水灯实验</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/</id>
    <published>2021-04-15T15:50:45.000Z</published>
    <updated>2021-04-17T11:46:18.301Z</updated>
    
    <content type="html"><![CDATA[<p>最近在电赛培训网参加活动，中了一块TI的单片机开发板，具体型号为SimpleLink Ethernet MSP432E401Y Microcontroller LaunchPad。<br>这两天打算简单学一学这款单片机。<br>不得不说，网上关于MSP432单片机的资料是真的少，关于MSP432E4的资料更是少的可怜。<br>无奈只能从读TI官方给出的SDK和datasheet开始学习了。</p><h3 id="开发环境的选择"><a href="#开发环境的选择" class="headerlink" title="开发环境的选择"></a>开发环境的选择</h3><p>MSP432可以采用keil,ccs,iar来进行开发，这里我选择了官方主推的ccs来进行学习。<br>从ti的官网下载ccs和MSP432E4的SDK，并将ccs和SDK配置好，之后就可以进行我们的开发了。</p><h3 id="driverlib和tidriver"><a href="#driverlib和tidriver" class="headerlink" title="driverlib和tidriver"></a>driverlib和tidriver</h3><p>关于MSP432，官方的SDK中给出了两大类库，driverlib和tidriver.<br>driverlib更接近底层，能实现的功能也更加的丰富。<br>tidriver更加的抽象，也更容易理解和使用，更重要的是，tidriver可以采用图形化的操作来配置单片机的外设。<br>当然，tidriver的功能可能不是特别的完善，所以有时候也可以调用driverlib中的部分功能或者直接操作寄存器来实现某些功能，不过tidriver和driverlib的某些文件可能会产生冲突，这一点在使用时是需要注意的。</p><h3 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h3><p>SDK中提供了很多demo，我们可以直接通过导入demo的工程来进行开发，这里我们采用tidriver的工程来进行开发，对于初学者来说，图形化的外设配置相比于代码要容易好多。<br>首先我们打开css,导入一个tidriver库中的demo，随便挑选一个就可以。</p><ul><li>导入工程<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_1.png" ></li></ul><p>通过项目管理栏可以看出，工程中主要有两个c文件，main_nortos.c主要负责开发板的初始化启动，启动后跳转到gpiointerrupt.c中的mainThread函数中运行，这里我们不需要进行改动。</p><ul><li>mainnortos.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_2.png" ></li></ul><p>gpiointertupt.c文件中有一个mainThread函数，我们要在mainThread函数中书写我们需要的用户代码。</p><p>外设的配置<br>打开资源管理栏后缀名为syscfg的配置文件，在其中配置我们需要使用的设备。<br>这里我们配置4个LED灯就可以。</p><ul><li>图形化外设配置<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_3.png" ></li></ul><p>保存之后，我们对外设的配置都会保存到ti_driver_config.c(.h)文件中.</p><ul><li>ti_driver_config.h<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_4.png" ></li></ul><p>打开interrupt函数，删掉原有代码，编写我们需要的代码。</p><ul><li>interrupt.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_5.png" ></li></ul><p>点击导航栏进行编译和烧录</p><ul><li>编译和烧录<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_6.png" ></li></ul><p>之后，就可以看到板子上的4个LED轮流点亮和熄灭了。</p><ul><li>运行效果<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_7.jpg" ></li></ul><h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><p> void delay(){<br>        int i=0;<br>        for(i=0;i&lt;1000000;i++);<br>    }</p><p>void *mainThread(void <em>arg0)<br>{<br>    /</em> Call driver unit functions <em>/<br>    GPIO_init();<br>    /</em> Configure the LED and button pins */<br>    GPIO_setConfig(CONFIG_GPIO_1, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_2, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_3, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_4, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    while(1){<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_1);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_2);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_3);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_4);<br>    }<br>    return (NULL);<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在电赛培训网参加活动，中了一块TI的单片机开发板，具体型号为SimpleLink Ethernet MSP432E401Y Microcontroller LaunchPad。&lt;br&gt;这两天打算简单学一学这款单片机。&lt;br&gt;不得不说，网上关于MSP432单片机的资料是真</summary>
      
    
    
    
    <category term="MSP432单片机" scheme="http://yeyuwenxi.github.io/categories/MSP432%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="单片机" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="MSP432" scheme="http://yeyuwenxi.github.io/tags/MSP432/"/>
    
  </entry>
  
  <entry>
    <title>AD之PCB画板初探</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/</id>
    <published>2021-04-15T15:48:19.000Z</published>
    <updated>2021-04-16T11:30:02.636Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于选修课的要求，速成了一波AD，这两天完成了自己的第一个PCB板的绘制。</p><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><p>1.三个开关控制一盏灯<br>2.使用按钮实现开关的功能</p><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>1.三个开关控制一盏灯，算是比较基础的数电问题了，这里我采用了74LS86（异或门）来实现这一逻辑功能。</p><p>2.按钮实现开关的功能，这一点我上网查资料发现都是采用模拟电路实现的，采用电容充放电实现开关的功能，电路较为复杂，实现原理也较为复杂，这里就不讲了。</p><p>分享一篇文章，有兴趣的可以自己看看<a href="https://baijiahao.baidu.com/s?id=1603206971622118062&wfr=spider&for=pc&qq-pf-to=pcqq.group">点按式轻触开关如何实现自锁轻触开关带锁按键开关功能？</a><br>3.后来想了想，还是采用数字电路实现比较简单，通过JK触发器的电平翻转来实现电路开关的功能，最后通过带JK触发器的74LS109实现了这一功能。</p><h3 id="PCB绘制流程"><a href="#PCB绘制流程" class="headerlink" title="PCB绘制流程"></a>PCB绘制流程</h3><p>1.原理图库的绘制<br>由于官方封装库中的门电路芯片都是只显示部分的，所以这里我自己绘制了74LS86和74LS109芯片的原理图。</p><ul><li>74LS86<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li><li>74LS109<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li></ul><p>2.原理图的绘制</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_4.png" ></li></ul><p><strong>ps:</strong> 经老师提醒，原理图中按钮部分存在问题，TTL芯片悬空时为高电平，所以芯片的CLK端口需要接一个下拉电阻。</p><p>3.PCB封装库的绘制<br>这里偷了点懒，直接采用了TI官方的封装库。</p><ul><li>D014_N封装<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_3.png" ></li></ul><p>4.PCB图的绘制</p><p>这一步才算是到了PCB绘制的核心部分。</p><h4 id="器件摆放"><a href="#器件摆放" class="headerlink" title="器件摆放"></a>器件摆放</h4><p>AD会将原理图中用到所有器件直接转移到PCB文件中，我们需要将各个器件以合适的位置摆放好。</p><h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><p>AD有自动布线功能，但还是推荐手动布线。<br>布线拐角采用钝角，降低电磁干扰。<br>多层板可能需要过孔，将各个板层进行电气连接。</p><h4 id="铺铜"><a href="#铺铜" class="headerlink" title="铺铜"></a>铺铜</h4><p>将没有导线的地方铺铜，提高抗干扰能力。</p><h4 id="丝印"><a href="#丝印" class="headerlink" title="丝印"></a>丝印</h4><p>添加需要的标记符号和个性化定制文字内容。</p><h4 id="版型设计"><a href="#版型设计" class="headerlink" title="版型设计"></a>版型设计</h4><p>对PCB板进行裁剪，打定位孔等操作，推荐矩形版型。</p><ul><li>最后贴上我的第一个PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_5.png" >(空白处有姓名等相关信息，已打码)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近由于选修课的要求，速成了一波AD，这两天完成了自己的第一个PCB板的绘制。&lt;/p&gt;
&lt;h3 id=&quot;任务目标&quot;&gt;&lt;a href=&quot;#任务目标&quot; class=&quot;headerlink&quot; title=&quot;任务目标&quot;&gt;&lt;/a&gt;任务目标&lt;/h3&gt;&lt;p&gt;1.三个开关控制一盏灯&lt;br&gt;</summary>
      
    
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/categories/PCB/"/>
    
    
    <category term="PCB" scheme="http://yeyuwenxi.github.io/tags/PCB/"/>
    
    <category term="数字电路" scheme="http://yeyuwenxi.github.io/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>博客域名大赏</title>
    <link href="http://yeyuwenxi.github.io/2021/04/15/bo-ke-yu-ming-da-shang/"/>
    <id>http://yeyuwenxi.github.io/2021/04/15/bo-ke-yu-ming-da-shang/</id>
    <published>2021-04-15T15:04:27.000Z</published>
    <updated>2021-04-15T15:39:15.388Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客从最开始在gitee上搭建，到github上搭建，又到vercel上托管，前前后后变换了好几个平台，也搞出了好多个域名。<br>今天写个记录，记录一下这些域名。</p><h3 id="gitee-版"><a href="#gitee-版" class="headerlink" title="gitee 版"></a>gitee 版</h3><p>1.<a href="https://yeyuwenxi.gitee.io/">https://yeyuwenxi.gitee.io/</a><br>gitee的主要问题有两个，一是不能自动更新，而是首页图标的显示存在问题，与github双部署时无法同时正常显示</p><h3 id="github版"><a href="#github版" class="headerlink" title="github版"></a>github版</h3><p>2.<a href="https://yeyuwenxi.github.io/%EF%BC%88%E8%AE%BF%E9%97%AE%E6%97%B6%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B03%EF%BC%89">https://yeyuwenxi.github.io/（访问时自动跳转到3）</a><br>3.<a href="https://yeyuwenxi.xyz/%EF%BC%88%E4%B8%BB%E7%AB%99%E7%82%B9%EF%BC%89">https://yeyuwenxi.xyz/（主站点）</a></p><h3 id="vercel加速版"><a href="#vercel加速版" class="headerlink" title="vercel加速版"></a>vercel加速版</h3><p>4.<a href="https://yeyuwenxi.vercel.app/%EF%BC%88%E5%B7%B2%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B07%EF%BC%89">https://yeyuwenxi.vercel.app/（已重定向到7）</a><br>5.<a href="https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/</a><br>6.<a href="https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/</a><br>7.<a href="https://blog.yeyuwenxi.xyz/">https://blog.yeyuwenxi.xyz/</a><br>不得不说，vercel托管后，域名是真的多</p><h3 id="关于域名解析服务器"><a href="#关于域名解析服务器" class="headerlink" title="关于域名解析服务器"></a>关于域名解析服务器</h3><p>yeyuwenxi.xyz的域名服务器在腾讯云<br>blog.yeyuwenxi.xyz的域名服务器在vercel</p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>目前并没有感觉vercel比github pages快多少</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个博客从最开始在gitee上搭建，到github上搭建，又到vercel上托管，前前后后变换了好几个平台，也搞出了好多个域名。&lt;br&gt;今天写个记录，记录一下这些域名。&lt;/p&gt;
&lt;h3 id=&quot;gitee-版&quot;&gt;&lt;a href=&quot;#gitee-版&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="博客搭建" scheme="http://yeyuwenxi.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客搭建" scheme="http://yeyuwenxi.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习笔记</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/markdown-yu-fa-xue-xi-bi-ji/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/markdown-yu-fa-xue-xi-bi-ji/</id>
    <published>2021-04-12T05:58:22.000Z</published>
    <updated>2021-04-15T11:06:33.674Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。<br>个人认为，Markdown可以看做xml,html的简化版，非常适合用来纯文本编辑。<br>好了，下面直接进入语法部分。</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>markdown使用#来表示标题,支持六级标题<br>示例：<br><code># 一</code><br><code>## 二</code><br><code>### 三</code><br><code>#### 四</code><br><code>##### 五</code><br><code>###### 六</code></p><p>显示效果：</p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><h5 id="五"><a href="#五" class="headerlink" title="五"></a>五</h5><h6 id="六"><a href="#六" class="headerlink" title="六"></a>六</h6><p>注意：#和文字之间要加1个空格</p><h3 id="2-超链接"><a href="#2-超链接" class="headerlink" title="2.超链接"></a>2.超链接</h3><p>示例：<br><code> [百度](baidu.com)</code><br>显示效果：<br><a href="baidu.com">百度</a></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;a href=&quot;baidu.com&quot;&gt;百度 &lt;/a&gt;</code><br>显示效果：<br><a href="baidu.com">百度 </a></p><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3.图片"></a>3.图片</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>示例：<br><code>![图片名称](https://www.baidu.com/img/flexible/logo/pc/result.png)</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png" alt="图片名称"></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;&gt;</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png"></p><h4 id="3-2-设置图片的大小"><a href="#3-2-设置图片的大小" class="headerlink" title="3.2 设置图片的大小"></a>3.2 设置图片的大小</h4><p>示例：<code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;      width=&quot;10%&quot; height=&quot;10%&quot;&gt;</code><br>显示效果：<img src="https://www.baidu.com/img/flexible/logo/pc/result.png" width="10%" height="10%" ></p><h4 id="3-3-设置图片居中显示"><a href="#3-3-设置图片居中显示" class="headerlink" title="3.3 设置图片居中显示"></a>3.3 设置图片居中显示</h4><h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h3><h4 id="4-1单行代码"><a href="#4-1单行代码" class="headerlink" title="4.1单行代码"></a>4.1单行代码</h4><p>使用英文反顿号”<code> </code>“表示单行代码<br>示例：<br>显示效果：123</p><h4 id="4-2多行代码"><a href="#4-2多行代码" class="headerlink" title="4.2多行代码"></a>4.2多行代码</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。&lt;br&gt;个人认为，Markdown可以看做xml,html的简化版，非常适合用来纯文本编辑。&lt;br&gt;好了，下面直接进入语法部分。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://yeyuwenxi.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="http://yeyuwenxi.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Markdown" scheme="http://yeyuwenxi.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Matlab实现简单的语音信号处理</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/</id>
    <published>2021-04-12T05:06:02.000Z</published>
    <updated>2021-04-12T05:50:19.903Z</updated>
    
    <content type="html"><![CDATA[<p>学习数字信号处理课程时做过的一个实验。</p><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>  1.学习并掌握数字信号处理的基本方法。<br>  2.学会使用MATLAB对语音信号进行处理。<br>  3.学习并掌握MATLAB设计滤波器的方法。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>   本次实验基于MATLAB R2019a完成，利用MATLAB对录制的语音信号进行了读取，播放，时域分析，频域分析以及滤波处理等操作。<br>   本次实验主要包括以下几个步骤：<br>1.音频的录制与导入<br>    使用手机自带的录音软件录制了格式为wav的一段语音信号。录音完成后，使用MATLAB的audioread函数对语音信号进行采样。<br>2.语音信号的时域分析和频域分析<br>    使用plot函数绘制语音信号的时域波形，对语音信号进行快速傅里叶变换，并绘制出语音信号的频域波形。<br>    <img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_1.jpg" width="60%" height="60%"><br>3.设计滤波器对语音信号进行处理<br>（1）低通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯低通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字低通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_2.jpg" width="60%" height="60%"><br>低通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_3.jpg" width="60%" height="60%"><br>（2）高通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯高通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字高通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_4.jpg" width="60%" height="60%"><br>高通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_5.jpg" width="60%" height="60%"><br>（3）陷波器的设计<br>根据陷波器的表达式配置参数，设计陷波器如下图所示<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_6.jpg" width="60%" height="60%"><br>使用陷波器处理后的频谱<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_7.jpg" width="60%" height="60%"><br>（4）对语音信号加噪<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_8.jpg" width="60%" height="60%"></p><h3 id="三、实验代码"><a href="#三、实验代码" class="headerlink" title="三、实验代码"></a>三、实验代码</h3><p>[x,fs]=audioread(‘yuyin.wav’);%录入语音信号<br>n=length(x);%获取语音信号的长度<br>x_p=fft(x,n);%利用FFT算法对语音信号进行离散傅里叶变换<br>f=fs*(0:n-1)/n;%频率的归一化<br>figure(1);%绘制时域和频域波形<br>subplot(2,1,1);<br>plot(x);<br>title(‘原始语音信号采样后的时域波形’);<br>xlabel(‘时间轴’)<br>ylabel(‘幅值A’)<br>subplot(2,1,2);<br>plot(f,abs(x_p));<br>title(‘原始语音信号采样后的频谱图’);<br>xlabel(‘频率Hz’);<br>ylabel(‘频率幅值’);<br>%噪声<br>% noise=0.2<em>randn(1,n);<br>% x_z=x+noise’;<br>% sound(x_z,fs);<br>% n=length(x);<br>% x_zp=fft(x_z,n);<br>% f=fs</em>(0:n/2-1)/n;<br>% figure(5);<br>% subplot(2,1,1);<br>% plot(x_z);<br>% title(‘加噪语音信号时域波形’);<br>% xlabel(‘时间轴’)<br>% ylabel(‘幅值A’)<br>% subplot(2,1,2);<br>% plot(f,abs(x_zp(1:n/2)));<br>% title(‘加噪语音信号频谱图’);<br>% xlabel(‘频率Hz’);<br>% ylabel(‘频率幅值’);<br>% %低通滤波器<br>fp=800;fs=1300;rs=35;rp=0.5;Fs=44100;<br>wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>[n,wn]=buttord(wp,ws,rp,rs,’s’);<br>[b,a]=butter(n,wn,’s’);<br>[num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>[h,w]=freqz(num,den,512,Fs);<br>% 512为点数 Fs为频率范围<br>figure(2)<br>plot(w,abs(h));<br>xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>title(‘巴特沃斯低通滤波器幅度特性’);<br>axis([0,5000,0,1.2]);<br>grid on;%网格线<br>%高通滤波器<br>% fp=3800;fs=3300;rs=3;rp=0.5;Fs=44100;<br>% wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>% ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>% [n,wn]=buttord(wp,ws,rp,rs,’s’);<br>% [b,a]=butter(n,wn,’high’,’s’);<br>% [num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>% [h,w]=freqz(num,den,512,Fs);<br>% % 512为点数 Fs为频率范围<br>% figure(2)<br>% plot(w,abs(h));<br>% xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>% title(‘巴特沃斯高通滤波器幅度特性’);<br>% axis([0,5000,0,1.2]);<br>% grid on;%网格线<br>%陷波器<br>% f0=3000;Fs=44100;r=0.9;<br>% w0=2<em>pi</em>f0/Fs;<br>% num=[1 -2<em>cos(w0) 1];<br>% den=[1 -2</em>r<em>cos(w0) r</em>r];<br>% N=1024;<br>% [H,w]=freqz(num,den,N);<br>% plot(w/pi/2<em>Fs,abs(H));<br>% grid on;<br>% title(‘陷波器的幅频响应’);<br>% [s1,Fs]=audioread(‘yuyin.wav’);<br>% %x1=s1(:,1);%选取一个声道的数据<br>% x1=s1;<br>% %sound(x1,Fs);<br>% N1=length(x1);<br>% Y1=fft(x1,N1);<br>% f1=Fs</em>(0:N1-1)/N1;<br>% %t1=(0:N1-1)/Fs;<br>% figure(3)<br>% plot(f1,abs(Y1))<br>% xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>% title(‘原始信号频谱’);<br>% grid on;axis([0 50000 0 600])<br>y=filter(num,den,x);<br>%sound(y,Fs);<br>N2=length(y);<br>Y2=fft(y,N2);<br>f2=Fs*(0:N2-1)/N2;<br>%t2=(0:N2-1)/Fs;<br>figure(4)<br>plot(f2,abs(Y2))<br>xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>title(‘过滤后信号的频谱’);<br>grid on;<br>axis([0 50000 0 600])</p><h3 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h3><p>分析语音信号的频谱图可以看出，有效的语音信号主要集中在0到4000Hz之间，根据奈奎斯特定理，最低的采样频率为8000Hz.观察滤波前后语音信号频谱的变化，可以看出滤波器按要求处理了语音信号，本次实验顺利完成。<br>总的来说，通过这次实验我收获了很多，对matlab有了更加深入的认识，了解到了如何利用matlab的各种函数对语音信号进行处理，这次实验也加深了我对离散傅里叶变换和滤波器设计的理解，巩固了课堂上所学到的知识，也让我看到了自己所学的知识在生活中的应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习数字信号处理课程时做过的一个实验。&lt;/p&gt;
&lt;h3 id=&quot;一、实验目的&quot;&gt;&lt;a href=&quot;#一、实验目的&quot; class=&quot;headerlink&quot; title=&quot;一、实验目的&quot;&gt;&lt;/a&gt;一、实验目的&lt;/h3&gt;&lt;p&gt;  1.学习并掌握数字信号处理的基本方法。&lt;br&gt;  </summary>
      
    
    
    
    <category term="Matlab" scheme="http://yeyuwenxi.github.io/categories/Matlab/"/>
    
    
    <category term="Matlab" scheme="http://yeyuwenxi.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>读《嘉莉妹妹》</title>
    <link href="http://yeyuwenxi.github.io/2021/04/12/du-jia-li-mei-mei/"/>
    <id>http://yeyuwenxi.github.io/2021/04/12/du-jia-li-mei-mei/</id>
    <published>2021-04-12T04:54:13.000Z</published>
    <updated>2021-04-12T04:59:57.918Z</updated>
    
    <content type="html"><![CDATA[<p>大二时英文选修课写的一篇小论文，这里是中文版，内容有所删减。</p><p>西奥多·德莱塞，美国伟大的现实主义作家。他的父亲是贫苦的德国移民，家里有很多的孩子，一家人生活很是拮据。德莱赛一生的大部分时间从事新闻工作，他走遍芝加哥、匹兹堡、纽约等大城市，广泛深入地观察了解社会，对资本主义制度有了很深的认识，为日后的文学创作积累了丰富的素材。</p><p>《嘉莉妹妹》是德莱赛的第一部著作，描写了农村姑娘嘉莉来到大城市芝加哥寻找幸福，为摆脱贫困，出卖自己的贞操，先后与推销员和酒店经理同居，后又凭美貌与表演才能成为演员而后走红的故事。其中，嘉莉私奔的情节来源于德莱赛妹妹的真实生活经历，他的妹妹曾跟一个偷钱潜逃的酒店经理私奔。</p><p>嘉莉是一个年轻的，纯朴的，没有经验的农村小姑娘，为了追求幸福的生活来到了大城市芝加哥。</p><p>正如作者在开篇时所写到的，一个年轻的没有经验的来自乡下的小姑娘来到大城市时，通常只有两种可能，得到善良的帮助而成为更好的人，或者被物质的诱惑影响而堕落。</p><p>很遗憾，嘉莉没有遇到能够真正在精神上帮助她的人，她的姐姐以及她的两个情人都不是那样的人，他们所教给嘉莉的，只有对物欲和名利的追求，只有物质至上的幸福观。在他们的影响下，嘉莉对上层社会，充盈的物质生活有了极大的渴望，她要拼劲全力地挤进那个社会，去享受物质上的快感与愉悦。对物欲的追求，让嘉莉迷失了初心，虚荣感让她放弃了一个人身上最淳朴的品质，就这样，嘉莉为了富裕的生活而两次出卖自己的贞操。</p><p>在德莱赛的那个时代，在垄断资本主义盛行的社会背景下，很难出现那样能给嘉莉以正确引导的人，每个人都在为自己的各种欲望而奔波。</p><p>嘉莉早期求职的过程也充分说明，在那个充满压迫，充满剥削的时代里，一个底层的普通人，靠自己的努力和勤奋是难以实现梦想的，是没有真正意义上的出路的，残酷的生活压迫着每一个普通人。</p><p>嘉莉靠美貌和运气以及出卖贞操走向了成功，而许许多多的平凡的人却只能在社会的底层不断地挣扎，承受着这个社会带给他们的苦难。从另一方面来说，获得成功的嘉莉也没有拥有真正意义上的快乐，与她相伴的只有内心的孤苦与空虚。无论成功与否，嘉莉都是痛苦的，物质上的满足并没有带给嘉莉真正的幸福感。</p><p>嘉莉正是作者所处那个时代的一个缩影，作者借嘉莉的视角，展现了资本主义带给人的种种苦难，揭露了资本主义社会的弊端，批判了金钱至上，物欲横流的社会现状。</p><p>在一个病态的资本主义社会里，在物质至上的时代里，是没有真正的幸福可言的。我想，这正是作者想要告诉我们的东西，一个人哪怕有了物质上的充盈，也会因为精神上的匮乏而陷入空虚。这一点对现在的我们也是适用的，我们不能陷于物质的牢笼而忽略了那些精神上值得我们去追寻的东西，不能为了自己的虚荣与欲望而放弃那些珍贵的有价值的道德品质。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大二时英文选修课写的一篇小论文，这里是中文版，内容有所删减。&lt;/p&gt;
&lt;p&gt;西奥多·德莱塞，美国伟大的现实主义作家。他的父亲是贫苦的德国移民，家里有很多的孩子，一家人生活很是拮据。德莱赛一生的大部分时间从事新闻工作，他走遍芝加哥、匹兹堡、纽约等大城市，广泛深入地观察了解社会</summary>
      
    
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://yeyuwenxi.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
