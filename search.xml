<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux信号机制</title>
      <link href="2021/09/13/linux-xin-hao-ji-zhi/"/>
      <url>2021/09/13/linux-xin-hao-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>信号机制主要包括信号的发送和处理。<br>可以类比于单片机中的中断和中断服务函数，也可以类比于Qt中的信号与槽。</p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>signal函数用来处理接受到的信号</p><p><code>sighandler_t signal(int signum, sighandler_t handler);</code><br>第一个参数signum：指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 　<br>第二个参数handler：描述了与信号关联的动作，它可以取以下三种值：</p><ul><li>SIG_IGN 　<br>忽略此信号</li><li>SIG_DFL 　<br>执行系统默认操作</li><li>sighandler_t类型的函数指针<br>执行函数指针所指向的函数<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3>kill函数用来发送信号</li></ul><p><code>int kill(pid_t pid, int signo);</code><br>pid参数存在四种情况</p><ul><li> pid大于零时，将该信号发送给进程ID为pid的进程</li><li> pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。</li><li> pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。</li><li> pid小于-1时，信号将送往以-pid为组标识的进程。</li></ul><p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在执行。</p><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>kill函数将信号发送给进程和进程组，raise函数则允许进程向自身发送信号。<br>调用raise(signo)<br>等价于调用<br>kill(getpid(),signo)</p><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>send.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span>pid<span class="token operator">=</span><span class="token number">18411</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SIGUSR1是系统保留给用户使用的信号</span><span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> SIGUSR1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>recv.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;signal.h></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">signal</span><span class="token punctuation">(</span>SIGUSR1<span class="token punctuation">,</span> hello<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先运行recv程序，使用ps -a命令查寻得pid<br>再运行send程序向该pid的进程发送信号<br>可以看到recv程序以一秒为周期向屏幕打印hello world</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>《UNIX环境高级编程》<br><a href="https://blog.csdn.net/yockie/article/details/51729774?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162969933616780255238561%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162969933616780255238561&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-51729774.first_rank_v2_pc_rank_v29&utm_term=linux%20signal%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">【Linux函数】Signal ()函数详细介绍</a><br><a href="https://blog.csdn.net/sweetfather/article/details/79462559?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162969932716780269892963%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162969932716780269892963&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79462559.first_rank_v2_pc_rank_v29&utm_term=linux%20kill%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187">Linux 下的KILL函数的用法</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux多线程编程</title>
      <link href="2021/09/13/linux-duo-xian-cheng-bian-cheng/"/>
      <url>2021/09/13/linux-duo-xian-cheng-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="linux多线程编程"><a href="#linux多线程编程" class="headerlink" title="linux多线程编程"></a>linux多线程编程</h1><p>这个帖子是一边改代码一边写的，可能会有点乱，有空再好好整理一下</p><p>linux多线程编程使用的接口主要包含在头文件&lt;pthread.h&gt;中</p><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h3 id="多线程入门"><a href="#多线程入门" class="headerlink" title="多线程入门"></a>多线程入门</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;多线程#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;void* print1()&#123;while(1)&#123;sleep(1);printf(&quot;This is thread1\n&quot;);&#125;&#125;void* print2()&#123;while(1)&#123;sleep(1);printf(&quot;This is thread2\n&quot;);&#125;&#125;int main()&#123;pthread_t th1;pthread_t th2;pthread_create(&amp;th1,NULL,print1,NULL);pthread_create(&amp;th2,NULL,print2,NULL);while(1)&#123;sleep(1);printf(&quot;This is function main\n&quot;);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">This is thread2This is thread1This is function mainThis is thread2This is thread1This is function mainThis is thread2This is thread1This is function mainThis is thread1This is thread2This is function mainThis is thread1This is thread2This is function mainThis is thread2This is function mainThis is thread1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个问题一直没有想明白，sleep和printf如果交换顺序的话，代码就不能正常执行了</p><h3 id="给创建的线程传递参数"><a href="#给创建的线程传递参数" class="headerlink" title="给创建的线程传递参数"></a>给创建的线程传递参数</h3><p>这里要注意的是，我们传递的参数一定要是void *类型的指针<br>下面通过修改一下上面的例程，通过参数化的方法来判断线程1和线程2</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多线程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is thread%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>print<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>print<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is function main\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终运行效果与之前是一致的</p><h3 id="线程的互斥问题"><a href="#线程的互斥问题" class="headerlink" title="线程的互斥问题"></a>线程的互斥问题</h3><p>先来看一个经典的卖票问题</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n=%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n<span class="token operator">=</span><span class="token number">10</span>n<span class="token operator">=</span><span class="token number">9</span>n<span class="token operator">=</span><span class="token number">8</span>n<span class="token operator">=</span><span class="token number">7</span>n<span class="token operator">=</span><span class="token number">6</span>n<span class="token operator">=</span><span class="token number">5</span>n<span class="token operator">=</span><span class="token number">4</span>n<span class="token operator">=</span><span class="token number">3</span>n<span class="token operator">=</span><span class="token number">2</span>n<span class="token operator">=</span><span class="token number">1</span>n<span class="token operator">=</span><span class="token number">0</span>n<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>什么？居然出现了-1的情况<br>这时候就需要考虑线程的互斥问题了</p><p>添加互斥锁之后</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多线程</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span> p_mutex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>p_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n=%d\n"</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>p_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pthread_mutex_t</span> m_mutex<span class="token punctuation">;</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>sub<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时查看运行效果，发现到0之后正常停止了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">n<span class="token operator">=</span><span class="token number">10</span>n<span class="token operator">=</span><span class="token number">9</span>n<span class="token operator">=</span><span class="token number">8</span>n<span class="token operator">=</span><span class="token number">7</span>n<span class="token operator">=</span><span class="token number">6</span>n<span class="token operator">=</span><span class="token number">5</span>n<span class="token operator">=</span><span class="token number">4</span>n<span class="token operator">=</span><span class="token number">3</span>n<span class="token operator">=</span><span class="token number">2</span>n<span class="token operator">=</span><span class="token number">1</span>n<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>三个线程按顺序输出ABC</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;多线程&#x2F;&#x2F;多线程#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;pthread_mutex_t m_mutex;pthread_cond_t condA;pthread_cond_t condB;pthread_cond_t condC;void* printA()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condA,&amp;m_mutex);printf(&quot;A&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condB);&#125;&#125;void* printB()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condB,&amp;m_mutex);printf(&quot;B&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condC);&#125;&#125;void* printC()&#123;while(1)&#123;pthread_mutex_lock(&amp;m_mutex);pthread_cond_wait(&amp;condC,&amp;m_mutex);printf(&quot;C&quot;);pthread_mutex_unlock(&amp;m_mutex);pthread_cond_signal(&amp;condA);&#125;&#125;int main()&#123;pthread_cond_init(&amp;condA, NULL);pthread_cond_init(&amp;condB, NULL);pthread_cond_init(&amp;condC, NULL);pthread_mutex_init(&amp;m_mutex, NULL);pthread_t th1;pthread_t th2;pthread_t th3;pthread_create(&amp;th1,NULL,printA,NULL);pthread_create(&amp;th2,NULL,printB,NULL);pthread_create(&amp;th3,NULL,printC,NULL);pthread_cond_signal(&amp;condA);while(1);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以上代码，可以看到程序按顺序输出ABC<br>这里存在一个问题，程序有时候会莫名卡死，暂时没有想明白是为什么</p><h3 id="生产者消费者问题-一对一"><a href="#生产者消费者问题-一对一" class="headerlink" title="生产者消费者问题 一对一"></a>生产者消费者问题 一对一</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token class-name">pthread_mutex_t</span> m_mutex<span class="token punctuation">;</span><span class="token class-name">sem_t</span> sem<span class="token punctuation">;</span><span class="token keyword">int</span> product_num<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">producter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>product_num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is producter. product a product. product_num=%d\n"</span><span class="token punctuation">,</span>product_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>product_num<span class="token operator">--</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is consumer. consume a product. product_num=%d\n"</span><span class="token punctuation">,</span>product_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th1<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> th2<span class="token punctuation">;</span><span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th1<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>producter<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>th2<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>consumer<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">9</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">8</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">7</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">6</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">5</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">4</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">3</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">2</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span>This is producter<span class="token punctuation">.</span> product a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">1</span>This is consumer<span class="token punctuation">.</span> consume a product<span class="token punctuation">.</span> product_num<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言错误信息</title>
      <link href="2021/09/12/c-yu-yan-cuo-wu-xin-xi/"/>
      <url>2021/09/12/c-yu-yan-cuo-wu-xin-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>c语言中存在一个error，用来保存最后的错误代码.<br>errno定义在&lt;errno.h&gt;中，是一个宏定义，用来储存错误代码。<br>当程序发生错误时，就会将错误代码写入errno.<br>程序启动时，errno为0，当发生错误时，程序就会将错误代码写入errno,注意，errno是不会自动清零的，而且错误代码的写入是可覆盖的。<br>所以我们必须在错误发生后立即读取errno的值，进行相关处理。</p><p>错误代码只是一个数字，想要获得具体的错误提示信息有两种办法，一是使用perror直接输出错误信息，二是使用strerror 将错误代码转换成对应的文本信息。</p><h3 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h3><p><code>void perror(const char *s)</code></p><ul><li>函数说明<br>perror ( )用 来 将 上 一 个 函 数 发 生 错 误 的 原 因 输 出 到 标 准 设备 (stderr) 。参数 s 所指的字符串会先打印出,后面再加上错误原因字符串。<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"D:/demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Congratulations, the file opens successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"file error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>运行结果：file error: No such file or directory</p><h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h3><p><code>char *strerror(int errno);</code></p><ul><li>函数说明<br>strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    errno <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//将 errno 设置回 0 值</span>    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"D:/demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Congratulations, the file opens successfully!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error no.%d: %s\n"</span><span class="token punctuation">,</span> errno<span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为<br>Error no.2: No such file or directory</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://c.biancheng.net/ref/errno.html">errno 记录最后的错误代码</a><br><a href="https://blog.csdn.net/wucz122140729/article/details/98437350">C语言系统错误信息</a></p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux多进程</title>
      <link href="2021/09/12/linux-duo-jin-cheng/"/>
      <url>2021/09/12/linux-duo-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>使用fork创建子进程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is the child process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is the father process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">this is the father processthis is the child processthis is the father processthis is the child processthis is the father processthis is the child processthis is the father processthis is the child process<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新进程。<br>vfork与fork都创建一个子进程，但是它并不会将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit,于是也就不会引用该地址空间。不过在子进程中调用exec或exit之前，它在父进程的空间中运行。<br>vfork与fork的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才开始运行。</p><h3 id="wait和waitpid"><a href="#wait和waitpid" class="headerlink" title="wait和waitpid"></a>wait和waitpid</h3><ul><li><p>wait函数等待子进程的结束信号。<br>它是阻塞函数,只有任意一个子进程结束,它才能继续往下执行,否则卡住那里等。</p></li><li><p>waitpid等待指定pid对应的进程结束，可以选择阻塞或者不阻塞的方式。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec系列的函数有很多个，主要用来执行一个新的程序，即用一个全新的程序来替换子进程的内容。</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/weixin_40519315/article/details/104156838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162976969216780255264774%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162976969216780255264774&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104156838.first_rank_v2_pc_rank_v29&utm_term=linux%E5%A4%9A%E8%BF%9B%E7%A8%8B&spm=1018.2226.3001.4187">Linux多进程编程(典藏、含代码)</a><br>《UNIX环境高级编程》</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈应用之表达式优先级</title>
      <link href="2021/08/09/dui-zhan-ying-yong-zhi-biao-da-shi-you-xian-ji/"/>
      <url>2021/08/09/dui-zhan-ying-yong-zhi-biao-da-shi-you-xian-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="带优先级的计算器实现"><a href="#带优先级的计算器实现" class="headerlink" title="带优先级的计算器实现"></a>带优先级的计算器实现</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#define size 100typedef struct Char&#x2F;&#x2F;运算符栈结构&#123;char data[size];int top;&#125;CHAR;typedef struct Num&#x2F;&#x2F;操作数栈结构&#123;double data[size];int top;&#125;NUM;void InitC(CHAR* C)&#x2F;&#x2F;初始化运算符栈&#123;C-&gt;top &#x3D; -1;&#125;void InitN(NUM* N)&#x2F;&#x2F;初始化操作数栈&#123;N-&gt;top &#x3D; -1;&#125;void PushC(CHAR* C, char e)&#x2F;&#x2F;运算符压栈&#123;C-&gt;data[++C-&gt;top] &#x3D; e;&#125;void PushN(NUM* N, double e)&#x2F;&#x2F;操作数压栈&#123;N-&gt;data[++N-&gt;top] &#x3D; e;&#125;char PopC(CHAR* C)&#x2F;&#x2F;运算符出栈&#123;return C-&gt;data[C-&gt;top--];&#125;double PopN(NUM* N)&#x2F;&#x2F;操作数出栈&#123;return N-&gt;data[N-&gt;top--];&#125;double GetTopN(NUM* N)&#x2F;&#x2F;取操作数栈顶元素&#123;return N-&gt;data[N-&gt;top];&#125;char GetTopC(CHAR* C)&#x2F;&#x2F;取运算符栈顶元素&#123;return C-&gt;data[C-&gt;top];&#125;&#x2F;&#x2F;判断输入的字符串是否正确bool fun(char* str)&#123;int x &#x3D; 0, i &#x3D; 0;while (*str) &#123;if ((*str &lt; &#39;0&#39; || *str &gt; &#39;9&#39;) &amp;&amp; *str !&#x3D; &#39;+&#39; &amp;&amp; *str !&#x3D; &#39;-&#39; &#x2F;&#x2F;不是数字+-*&#x2F;（）则false&amp;&amp; *str !&#x3D; &#39;*&#39; &amp;&amp; *str !&#x3D; &#39;&#x2F;&#39; &amp;&amp; *str !&#x3D; &#39;(&#39; &amp;&amp; *str !&#x3D; &#39;)&#39;) &#123;return false;&#125;if ((i &#x3D;&#x3D; 0) &amp;&amp; (*str &lt; &#39;0&#39; || *str &gt; &#39;9&#39;) &amp;&amp; *str !&#x3D; &#39;(&#39;) &#123; &#x2F;&#x2F;开头不为（ 或数字 则falsereturn false;&#125;if (((*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39;) || *str &#x3D;&#x3D; &#39;)&#39;) &amp;&amp; (*(str + 1) &#x3D;&#x3D; &#39;(&#39;)) &#123;return false; &#x2F;&#x2F;如果是数字和 ），后面是 （ 则false&#125;if (*str &#x3D;&#x3D; &#39;)&#39;) &#123; &#x2F;&#x2F;如果是 ） ，x--;if (x &lt; 0) &#123;return false;&#125;&#125;if ((*str &#x3D;&#x3D; &#39;+&#39; || *str &#x3D;&#x3D; &#39;-&#39; || *str &#x3D;&#x3D; &#39;*&#39; || *str &#x3D;&#x3D; &#39;&#x2F;&#39; || *str &#x3D;&#x3D; &#39;(&#39;) &amp;&amp;(*(str + 1) &#x3D;&#x3D; 0 || *(str + 1) &#x3D;&#x3D; &#39;+&#39; || *(str + 1) &#x3D;&#x3D; &#39;-&#39; || *(str + 1) &#x3D;&#x3D; &#39;*&#39; || *(str + 1) &#x3D;&#x3D; &#39;&#x2F;&#39; || *(str + 1) &#x3D;&#x3D; &#39;)&#39;)) &#123;return false; &#x2F;&#x2F;如果是运算符号 ，后面不能是运算符号和 ）&#125;if (*str &#x3D;&#x3D; &#39;(&#39;) &#123; &#x2F;&#x2F;如果是 （x++;&#125;str++; i++;&#125;if (x &gt; 0) &#123; &#x2F;&#x2F;如果括号不匹配return false;&#125;return true;&#125;int op(char ch)&#x2F;&#x2F;判断字符是否为运算符&#123;char a[8] &#x3D; &#123; &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;&#x3D;&#39;,&#39;#&#39; &#125;;int i;for (i &#x3D; 0; i &lt; 8; i++)&#123;if (ch &#x3D;&#x3D; a[i])return 1;&#125;return 0;&#125;double operate(double a, char op, double b)&#x2F;&#x2F;执行运算&#123;switch (op)&#123;case &#39;+&#39;:return a + b; break;case &#39;-&#39;:return a - b; break;case &#39;*&#39;:return a * b; break;case &#39;&#x2F;&#39;:return a &#x2F; b; break;default:return 0; break;&#125;&#125;char compare(char a, char b)&#x2F;&#x2F;比较运算符优先级&#123;int i, j;char Table[8][8] &#x3D;&#123;&#123; &#39; &#39;, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#x2F;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;&#125;,&#123; &#39;+&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;-&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;*&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;&#x2F;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;(&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&#x3D;&#39;, &#39; &#39;&#125;,&#123; &#39;)&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39; &#39;, &#39;&gt;&#39;, &#39;&gt;&#39;&#125;,&#123; &#39;#&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39; &#39;, &#39;&#x3D;&#39;&#125;,&#125;;  &#x2F;&#x2F;优先级对照表for (i &#x3D; 0; i &lt; 8; i++)if (Table[i][0] &#x3D;&#x3D; a)  &#x2F;&#x2F;寻找a的位置break;for (j &#x3D; 0; j &lt; 8; j++)  &#x2F;&#x2F;寻找b的位置if (Table[0][j] &#x3D;&#x3D; b)break;return Table[i][j];&#125;int main() &#123;char ch[100];cout &lt;&lt; &quot;请输入要计算的表达式：&quot;;cin &gt;&gt; ch;&#x2F;&#x2F;输入字符串int len &#x3D; 0;&#x2F;&#x2F;获取表达式长度len &#x3D; strlen(ch);&#x2F;&#x2F;表达式末尾加一个‘#’if (fun(ch) &#x3D;&#x3D; 1) &#123; cout &lt;&lt; &quot;输入的表达式正确&quot;&lt;&lt;endl; &#125;else&#123; cout &lt;&lt; &quot;输入的表达式错误&quot; &lt;&lt; endl; &#125;ch[len] &#x3D; &#39;#&#39;;double a, b;char theta;&#x2F;&#x2F;运算符&#x2F;&#x2F;初始化操作数栈和运算符栈NUM OPND;CHAR OPTR;InitC(&amp;OPTR);InitN(&amp;OPND);PushC(&amp;OPTR, &#39;#&#39;);int i &#x3D; 0;while (ch[i] !&#x3D; &#39;#&#39; || GetTopC(&amp;OPTR) !&#x3D; &#39;#&#39;)&#123;if (!op(ch[i])) &#123;double num &#x3D; 0;int j &#x3D; 0;while (ch[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; ch[i] &lt;&#x3D; &#39;9&#39; || ch[i] &#x3D;&#x3D; &#39;.&#39;) &#123; &#x2F;&#x2F;把字符串换算成实际数值if (ch[i] !&#x3D; &#39;.&#39;)num &#x3D; num * 10 + ch[i] - &#39;0&#39;;if (ch[i] &#x3D;&#x3D; &#39;.&#39; || j &gt; 0) j++;i++;&#125;&#x2F;&#x2F;对小数进行额外处理if (j &gt; 0) num &#x3D; num &#x2F; pow(10, j - 1);PushN(&amp;OPND, num);&#125;if (op(ch[i]))&#123;switch (compare(GetTopC(&amp;OPTR), ch[i]))&#123;case&#39;&lt;&#39;:PushC(&amp;OPTR, ch[i]);i++;break;case&#39;&#x3D;&#39;:PopC(&amp;OPTR);i++;break;case&#39;&gt;&#39;:theta &#x3D; PopC(&amp;OPTR);b &#x3D; PopN(&amp;OPND); a &#x3D; PopN(&amp;OPND);PushN(&amp;OPND, operate(a, theta, b));   break;&#125;&#125;&#125;cout &lt;&lt; &quot;运算结果为：&quot;&lt;&lt;GetTopN(&amp;OPND);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程通信之socket通信</title>
      <link href="2021/08/09/linux-jin-cheng-tong-xin-zhi-socket-tong-xin/"/>
      <url>2021/08/09/linux-jin-cheng-tong-xin-zhi-socket-tong-xin/</url>
      
        <content type="html"><![CDATA[<p>实现基于命令行的linux交互式通信</p><h3 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取客户端传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> sock<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message form server: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//创建套接字</span>    <span class="token keyword">int</span> sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//向服务器（特定的IP和端口）发起请求</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//每个字节都用0填充</span>    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>  <span class="token comment">//使用IPv4地址</span>    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//具体的IP地址</span>    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//端口</span>    <span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//读取服务器传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> readThread<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readThread<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>read_data<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>       <span class="token comment">//关闭套接字</span>    <span class="token function">close</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器端的实现"><a href="#服务器端的实现" class="headerlink" title="服务器端的实现"></a>服务器端的实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">read_data</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//读取客户端传回的数据</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> sock<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Message form client: %s\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//创建套接字</span>    <span class="token keyword">int</span> serv_sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> IPPROTO_TCP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将套接字和IP、端口绑定</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//每个字节都用0填充</span>    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>  <span class="token comment">//使用IPv4地址</span>    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//具体的IP地址</span>    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//端口</span>    <span class="token function">bind</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进入监听状态，等待用户发起请求</span>    <span class="token function">listen</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//接收客户端请求</span>    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> clnt_addr<span class="token punctuation">;</span>    <span class="token class-name">socklen_t</span> clnt_addr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clnt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> clnt_sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clnt_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clnt_addr_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//向客户端发送数据</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pthread_t</span> readThread<span class="token punctuation">;</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>readThread<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>read_data<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//关闭套接字</span>    <span class="token function">close</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android数据库应用之单词本</title>
      <link href="2021/06/28/android-shu-ju-ku-ying-yong-zhi-dan-ci-ben/"/>
      <url>2021/06/28/android-shu-ju-ku-ying-yong-zhi-dan-ci-ben/</url>
      
        <content type="html"><![CDATA[<p>整理一下以前做过的一个小应用，主要是基于SQLite实现了一个简单的记录单词的app.</p><h3 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h3><pre class="line-numbers language-none"><code class="language-none">public class DatabaseHelper extends SQLiteOpenHelper &#123;    private static final int VERSION &#x3D; 1;    &#x2F;&#x2F; private static final String SWORD&#x3D;&quot;SWORD&quot;;    &#x2F;&#x2F;三个不同参数的构造函数    &#x2F;&#x2F;带全部参数的构造函数，此构造函数必不可少    public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,                          int version) &#123;        super(context, name, factory, version);    &#125;    public DatabaseHelper(Context context,String name,int version)&#123;        this(context, name,null,version);    &#125;    &#x2F;&#x2F;创建数据库    public void onCreate(SQLiteDatabase db) &#123;        &#x2F;&#x2F;创建数据库sql语句        String sql &#x3D; &quot;create table danciben(id int,danci text,zhushi text,xiangqing text,xingbiao int,beihui int)&quot;;        &#x2F;&#x2F;执行创建数据库操作        db.execSQL(sql);    &#125;    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;        &#x2F;&#x2F;创建成功，日志输出提示    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre class="line-numbers language-none"><code class="language-none">db &#x3D; new DatabaseHelper(tianjia.this,&quot;danciben&quot;, null, 1); &#x2F;&#x2F;数据库实际上是没有被创建或者打开的，直到getWritableDatabase() 或者 getReadableDatabase() 方法中的一个被调用时才会进行创建或者打开  db.getWritableDatabase();  insertData(db.getReadableDatabase(),ciyu,zhushi,xiangqing);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre class="line-numbers language-none"><code class="language-none">db.getWritableDatabase().delete(&quot;danciben&quot;,&quot;danci&#x3D;?&quot;, new String[]&#123;danci&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>使用游标进行查找<br>like关键词可支持模糊查找</p><pre class="line-numbers language-none"><code class="language-none">Cursor cursor&#x3D;db.getReadableDatabase().query(&quot;danciben&quot;,null,&quot;danci like?&quot;, new String[]&#123;key+&quot;%&quot;&#125;,null,null,null);  while(cursor.moveToNext())&#123;   String danci&#x3D;cursor.getString(cursor.getColumnIndex(&quot;danci&quot;));    String zhushi&#x3D;cursor.getString(cursor.getColumnIndex(&quot;zhushi&quot;));    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="部分功能测试结果"><a href="#部分功能测试结果" class="headerlink" title="部分功能测试结果"></a>部分功能测试结果</h3><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_3.png" ><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_4.png" ><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_5.png" ><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><p><a href="https://github.com/yeyuwenxi/toolcase/blob/main/datalibrary2.zip">github下载链接</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/midnight_time/article/details/80834198?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160522951719725222401033%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160522951719725222401033&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-6-80834198.first_rank_ecpm_v3_pc_rank_v2&utm_term=androidSQLite&spm=1018.2118.3001.4449">【Android】SQLite数据库基本用法详解（极简洁）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt入门之简易计算器</title>
      <link href="2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/"/>
      <url>2021/06/28/qt-ru-men-zhi-jian-yi-ji-suan-qi/</url>
      
        <content type="html"><![CDATA[<p>最近考完试比较闲了，简单学了一下qt,做了个最基本的计算器。</p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>通过可视化的方法，拖动实现界面<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_1.png" ></p><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><p>在头文件中实现类的定义和类内成员的声明</p><pre class="line-numbers language-none"><code class="language-none">class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent &#x3D; 0);    ~MainWindow();    int num1;    int num2;    double result;    int op;private slots:    void on_button_1_clicked();    void on_button_2_clicked();    void on_button_3_clicked();    void on_button_add_clicked();    void on_button_4_clicked();    void on_button_5_clicked();    void on_button_6_clicked();    void on_button_sub_clicked();    void on_button_7_clicked();    void on_button_8_clicked();    void on_button_9_clicked();    void on_button_mult_clicked();    void on_button_clear_clicked();    void on_button_0_clicked();    void on_button_equal_clicked();    void on_button_div_clicked();private:    Ui::MainWindow *ui;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在cpp文件中实现类内成员的定义</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;iostream&gt;using namespace std;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    this-&gt;setWindowTitle(&quot;计算器1.0&quot;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::on_button_1_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;1&quot;);&#125;void MainWindow::on_button_2_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;2&quot;);&#125;void MainWindow::on_button_3_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;3&quot;);&#125;void MainWindow::on_button_add_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;+&quot;);&#125;void MainWindow::on_button_4_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;4&quot;);&#125;void MainWindow::on_button_5_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;5&quot;);&#125;void MainWindow::on_button_6_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;6&quot;);&#125;void MainWindow::on_button_sub_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;-&quot;);&#125;void MainWindow::on_button_7_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;7&quot;);&#125;void MainWindow::on_button_8_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;8&quot;);&#125;void MainWindow::on_button_9_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;9&quot;);&#125;void MainWindow::on_button_mult_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;*&quot;);&#125;void MainWindow::on_button_clear_clicked()&#123; ui-&gt;textEdit-&gt;setText(&quot;&quot;);&#125;void MainWindow::on_button_0_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;0&quot;);&#125;void MainWindow::on_button_equal_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x3D;&quot;);       QString text &#x3D; ui-&gt;textEdit-&gt;toPlainText();       string text1&#x3D;text.toStdString();       &#x2F;&#x2F;cout&lt;&lt;text1&lt;&lt;endl;       &#x2F;&#x2F;cout&lt;&lt;text1[1]&lt;&lt;endl;       int len&#x3D;text1.size();       const char * text2&#x3D;text1.c_str();       cout&lt;&lt;text2;       int flag&#x3D;0;       num1&#x3D;0;       num2&#x3D;0;       op&#x3D;0;       result&#x3D;0;       for(int i&#x3D;0;i&lt;len;i++)&#123;       if(text2[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;text2[i]&lt;&#x3D;&#39;9&#39;)&#123;       if(flag&#x3D;&#x3D;0)&#123;           num1&#x3D;num1*10+text2[i]-&#39;0&#39;;       &#125;       if(flag&#x3D;&#x3D;1)&#123;           num2&#x3D;num2*10+text2[i]-&#39;0&#39;;       &#125;       &#125;else if(text2[i]&#x3D;&#x3D;&#39;+&#39;)&#123;           flag&#x3D;1;           op&#x3D;1;           cout&lt;&lt;&quot;+++&quot;&lt;&lt;endl;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;-&#39;)&#123;           flag&#x3D;1;           op&#x3D;2;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;*&#39;)&#123;           flag&#x3D;1;           op&#x3D;3;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x2F;&#39;)&#123;           flag&#x3D;1;           op&#x3D;4;       &#125;       else if(text2[i]&#x3D;&#x3D;&#39;&#x3D;&#39;)&#123;           if(op&#x3D;&#x3D;1)&#123;               result&#x3D;num1+num2;               cout&lt;&lt;num1&lt;&lt;endl;               cout&lt;&lt;num2&lt;&lt;endl;           &#125;           if(op&#x3D;&#x3D;2)&#123;               result&#x3D;num1-num2;           &#125;           if(op&#x3D;&#x3D;3)&#123;               result&#x3D;num1*num2;           &#125;           if(op&#x3D;&#x3D;4)&#123;               result&#x3D;(num1*1.00)&#x2F;num2;           &#125;              ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);              ui-&gt;textEdit-&gt;insertPlainText(QString::number(result));       &#125;       &#125;&#125;void MainWindow::on_button_div_clicked()&#123;    ui-&gt;textEdit-&gt;moveCursor(QTextCursor::End);       ui-&gt;textEdit-&gt;insertPlainText(&quot;&#x2F;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>qt整体的架构还是比较清晰的，界面和逻辑部分互相分离，又通过信号与槽进行必要的通信。<br>头文件中完成了类的定义，而对类的成员函数仅作声明，具体实现在cpp文件中完成，整个过程实现了类内声明，类外定义。<br>计算器的基本原理也比较简单，按下按钮时，字符附加到编辑框对应的字符串后，最后按下等号时读取整个字符串，分离两个操作数和一个运算符，进行计算，并将最后的计算结果显示到编辑框中。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>生成exe文件并通过命令行配置好注册表文件后，点击exe文件就可以正常运行了，运行结果如图所示。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210628_2.png" ></p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机最小系统pcb板</title>
      <link href="2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/"/>
      <url>2021/06/03/51-dan-pian-ji-zui-xiao-xi-tong-pcb-ban/</url>
      
        <content type="html"><![CDATA[<p>最近画了块51单片机的最小系统，然后到捷配上把他打了出来。<br>下面直接放图</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_1.png" ></li><li>PCB正面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li><li>PCB背面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210603_3.jpg" width="60%" height="60%" style="transform:rotate(270deg)">总的来说，板子打的还可以，当然仍然避免不了某些小问题，系统库自己提供的电容封装不是很好，孔距有点大，焊盘有点小，另外布线也不是特别好。### 做个总结PCB画板还是一个比较靠经验的活，各种常见的封装，常见的库，这些都是要靠经验来一步步熟悉的。自己技术方向也不是做硬件，这方面估计也就浅尝辄止了，各种线宽，电磁兼容，信号完整性的东西应该也不会去学，画画板子，更多的还是拓展一下视野，平时有精力，还是应该多学一些软件方面的东西。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32实现矩阵键盘</title>
      <link href="2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/"/>
      <url>2021/05/30/stm32-shi-xian-ju-zhen-jian-pan/</url>
      
        <content type="html"><![CDATA[<p>最近打了块矩阵按键的PCB板，焊完之后，打算写段代码，用STM32的单片机试试。<br>虽然没用32的单片机写过矩阵键盘的代码，但感觉不就是线反转法分别扫描行和列吗，也没啥难度，写的过程中才发现遇到了点问题。<br>相比于51单片机，32的io口是要考虑io方向和io模式的。<br>自己参考网上的一个例子写的代码，没想到被误导了，将4个io口设为上拉输入，另外4个io口设为下拉输入，按键按下的时候先检测行，再检测列，没想到遇到了点莫名奇妙的问题，不管怎么接线，总有两行按键检测不到。<br>于是我怀疑是不是io模式的问题，上拉输入和下拉输入接在一起，产生的情况可能是无法预测的。<br>我修改io模式为4个下拉输入，另外4个推挽输出高电平之后，果然解决了这一问题。<br>对于某些细节方面的东西，有时候还是不能想当然地认为会怎么样啊。</p><h3 id="下附代码"><a href="#下附代码" class="headerlink" title="下附代码"></a>下附代码</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;低四位输出高，高四位下拉输入void KEY_Init1(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1;GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);   GPIO_SetBits(GPIOA,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);&#125; &#x2F;&#x2F;低四位下拉输入，高四位输出高void KEY_Init2(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure1; GPIO_InitTypeDef  GPIO_InitStructure2;  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure1.GPIO_Pin &#x3D; GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  GPIO_InitStructure1.GPIO_Mode &#x3D; GPIO_Mode_IPD;  GPIO_InitStructure1.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure1);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitStructure2.GPIO_Pin &#x3D; GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;  GPIO_InitStructure2.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;  GPIO_InitStructure2.GPIO_Speed &#x3D; GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);GPIO_SetBits(GPIOA,GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);&#125; &#x2F;&#x2F;函数名：扫描函数&#x2F;&#x2F;返回值：有效键值或-1&#x2F;&#x2F;功能：矩阵按键扫描，返回一个值short KeyPad_Scan(void)&#123;short num &#x3D; -1; &#x2F;&#x2F;保持按键值返回u16 readvalue &#x3D; 0;u16 re&#x3D;0;u16 re1&#x3D;0;u16 re2&#x3D;0;KEY_Init1();&#x2F;&#x2F;低4位引脚输出高，高4位引脚下拉输入readvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;&#x2F;&#x2F;保留低8位的值（PA7-PA0）if(readvalue !&#x3D; 0x000f) &#x2F;&#x2F;高4位引脚有一个被按下&#123;delay_ms(10);&#x2F;&#x2F;消抖10msreadvalue &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;读GPIOA引脚电平readvalue &amp;&#x3D; 0x00ff;if(readvalue !&#x3D; 0x000f)&#123;re1 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re1 &amp;&#x3D; 0x00f0;  &#x2F;&#x2F;保留PA4-PA7的值KEY_Init2();  &#x2F;&#x2F;低4位引脚下拉输入，高4位输出高delay_ms(10);re2 &#x3D; GPIO_ReadInputData(GPIOA);&#x2F;&#x2F;再次读取状态re2 &amp;&#x3D; 0x000f;&#x2F;&#x2F;保留PA0-PA3的值while((GPIO_ReadInputData(GPIOA)&amp;0x00ff)!&#x3D;0x00f0);&#x2F;&#x2F;等待按键松开re&#x3D;re1|re2;&#x2F;&#x2F;取或，就知道哪一行哪一列被按下啦switch(re)&#123;case 0x0011: num &#x3D; 12;break;  case 0x0012: num &#x3D; 8;break;  case 0x0014: num &#x3D; 4;break; case 0x0018: num &#x3D; 0;break;  case 0x0021: num &#x3D; 13;break;  case 0x0022: num &#x3D; 9;break; case 0x0024: num &#x3D; 5;break;  case 0x0028: num &#x3D; 1;break;  case 0x0041: num &#x3D; 14;break;  case 0x0042: num &#x3D; 10;break;  case 0x0044: num &#x3D; 6;break;  case 0x0048: num &#x3D; 2;break;  case 0x0081: num &#x3D; 15;break;  case 0x0082: num &#x3D; 11;break;  case 0x0084: num &#x3D; 7;break;  case 0x0088: num &#x3D; 3;break;  &#125;return num;&#125;&#125;return -1;&#125;int main()&#123;  delay_init();     &#x2F;&#x2F;延时函数初始化  NVIC_Configuration();  &#x2F;&#x2F;设置NVIC中断分组2:2位抢占优先级，2位响应优先级 LED_Init();     &#x2F;&#x2F;LED端口初始化  &#x2F;&#x2F;OLED_Init();&#x2F;&#x2F;初始化OLED  &#x2F;&#x2F;OLED_Clear()  ;  uart_init(115200); &#x2F;&#x2F;串口初始化为115200while(1)&#123;short key&#x3D;0;key&#x3D;KeyPad_Scan();if(key!&#x3D;-1)&#123;printf(&quot;key&#x3D;&quot;);printf(&quot;%d\n&quot;,key);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/Daniel__Lai/article/details/108916185?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162237210816780271566581%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162237210816780271566581&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-8-108916185.first_rank_v2_pc_rank_v29&utm_term=STM32%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE&spm=1018.2226.3001.4187">STM32的矩阵键盘扫描及处理</a></p>]]></content>
      
      
      <categories>
          
          <category> STM32单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 矩阵键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次PCB打板</title>
      <link href="2021/05/28/di-yi-ci-pcb-da-ban/"/>
      <url>2021/05/28/di-yi-ci-pcb-da-ban/</url>
      
        <content type="html"><![CDATA[<p>记录一下第一次打PCB板。<br>虽然之前用AD画过原理图和PCB版图，但还一直没有真正打过板，碰巧捷配在搞活动，每月领券免费打板，就试着打了一次PCB板。<br>第一次打板，没搞什么特别复杂的电路，一是怕出错，二是手上没有特别多的器件可以焊在PCB板上验证。<br>这次板子主要就是一个简单的流水灯和4x4的矩阵键盘，自己手动画了画四角按键的封装。<br>画完之后就向捷配上传了工程文件和生产文件，几天后收到了板子，没想到的是居然发了六块。<br>下面直接放图</p><ul><li>PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_1.jpg" width="60%" height="60%" style="transform:rotate(270deg)"   ></li><li>焊接成品<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210528_2.jpg" width="60%" height="60%" style="transform:rotate(270deg)"></li></ul><p>总的来说，这次打板还是比较成功的，当然也有一些小细节做的不是很好</p><ul><li>流水灯和矩阵按键的接口排针放在了两侧，相对来说还是放在一侧比较好。</li><li>矩阵键盘行与行之间间隙略大</li><li>布线不是特别好看</li><li>流水灯其实可以放8个的，比6个更好写程序</li></ul><p>另外本次打板没有铺铜，主要是没有确定的地，也没有哪个网络比其他网络要大很多。问了一些专业人士，简单的二层板不铺铜的话，也没有特别大的影响。</p>]]></content>
      
      
      <categories>
          
          <category> PCB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
            <tag> 矩阵键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp32入门</title>
      <link href="2021/05/24/esp32-ru-men/"/>
      <url>2021/05/24/esp32-ru-men/</url>
      
        <content type="html"><![CDATA[<p>最近打算做一个物联网的应用，买了块ESP32的开发板。</p><h3 id="ESP32的简单介绍"><a href="#ESP32的简单介绍" class="headerlink" title="ESP32的简单介绍"></a>ESP32的简单介绍</h3><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><p>ESP32支持使用arduino,espif等进行开发，可供使用的开发编辑器也有很多。<br>我们由简到难，先从最简单的开始，这里使用arduino IDE加上ESP32的arduino包进行开发。<br>开发环境搭建详见下文<br><a href="https://blog.csdn.net/dpjcn1990/article/details/94414983">ESP32 开发之旅① 走进ESP32的世界 安装开发环境</a></p><h3 id="烧录遇到的问题"><a href="#烧录遇到的问题" class="headerlink" title="烧录遇到的问题"></a>烧录遇到的问题</h3><p>安装完CP2102的驱动后，连到电脑上居然无法下载，串口时断时续的，后来采用自己的USB转TTL的烧录器成功地烧录了程序。<br>跟客服聊了聊，认为是CP2102的芯片坏了，客服直接发了块新的给我，而且说旧的不用退了。<br>这里强推一波优信电子！物美价廉，客服也很周到！</p><h3 id="arduino开发环境介绍"><a href="#arduino开发环境介绍" class="headerlink" title="arduino开发环境介绍"></a>arduino开发环境介绍</h3><p>arduino既有自己的硬件平台，又有一个基于arduino IDE的软件框架，arduino IDE属实不好用，连个最基本的函数查找都做不到，但arduino本身的框架封装了很多简单易用的函数，而且网上基于这一框架有很多有趣的开发实例，这里我们主要使用arduino的框架进行开发。</p><h3 id="开发板原理图"><a href="#开发板原理图" class="headerlink" title="开发板原理图"></a>开发板原理图</h3><p>最离谱的是，淘宝商家居然没有提供原理图，自己在网上搜索才找到了一张跟手上开发板一样的原理图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210604_1.png" ></p><h3 id="helloworld程序"><a href="#helloworld程序" class="headerlink" title="helloworld程序"></a>helloworld程序</h3><p>编写程序如下，编译完成后点击上传烧录到单片机中。<br><strong>注意:</strong> 烧录时屏幕下方出现connecting时按住boot按钮不放，直到烧录完成后松开boot按钮，此时，按一下复位按钮，程序就可以在单片机上正常运行了。<br>打开arduino IDE中的串口监视器，可以看到每秒都会收到一次单片机发送的helloworld.<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210524_1.png" ></p><h3 id="点灯程序"><a href="#点灯程序" class="headerlink" title="点灯程序"></a>点灯程序</h3><p>这块开发板上自带两个LED，其中红色的应该时电源指示灯，不受我们控制。<br>网上查询发现蓝色的LED，应该时接在GPIO2上，下面我们写一个驱动程序控制蓝色LED闪烁。<br>编写程序如下，并烧录到单片机中，可以看到LED正常闪烁。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;WiFi.h&gt;#define LED       2void setup() &#123;   pinMode(LED, OUTPUT);  &#125;void loop() &#123;  digitalWrite(LED, LOW);  delay(1000);  digitalWrite(LED, HIGH);  delay(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> esp32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博客的初心</title>
      <link href="2021/05/23/kai-bo-ke-de-chu-xin/"/>
      <url>2021/05/23/kai-bo-ke-de-chu-xin/</url>
      
        <content type="html"><![CDATA[<p>好多天没写博客了，今天开个新篇，反省一下。<br>做这个博客的初衷，是为了记录生活，记录学习，不是为了折腾各种乱七八糟的博客框架。<br>这么多天，搞过hexo,在github,gitee,vercel都搭建过服务，还折腾过图床和jsd加速。<br>动态的框架也尝试过typecho和wordpress。<br>折腾了一大堆，文章倒是好久没写了，不知不觉方向就走的有点偏了。<br>博客的框架，样式，音乐，其实并没有那么重要，只适合刚开始学框架图个新鲜罢了，内容才是博客的本质。<br>这么多框架，如果不是为了更好的写文章，而是沉迷于各种框架的细节，那就真的偏离自己的方向了。<br>所以接下来，还是明确一点，认真学技术，积极写文章。<br>平时少看各种无意义的东西，静下心来沉淀自己。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云何降伏其心</title>
      <link href="2021/05/17/yun-he-jiang-fu-qi-xin/"/>
      <url>2021/05/17/yun-he-jiang-fu-qi-xin/</url>
      
        <content type="html"><![CDATA[<p>人的欲望不满足就痛苦，满足了就无聊。<br>我们的一生，就像钟摆一样在痛苦和无聊之间徘徊，难以逃脱。<br>渴的不行的时候，才回想起白开水的滋润和甘甜，只要有一杯水放在眼前，就会感觉无比的幸福。<br>等到不渴的时候，再多的水放在自己面前也觉得乏味无比。<br>曾有一段时间，眼睛特别肿，眨下眼都难受，做什么事情都会想着眼睛，那时候才想起平时健康的时候生活有多么的快乐。<br>可等到眼睛好了，无所事事的时候又是枯燥和无聊，丝毫不记得曾经满心期待的快乐生活。<br>或许遗忘是人类的本能吧，总是不太长记性，痛苦的时候渴望平淡的生活，等生活平淡了又空虚无比，亟待刺激。<br>我们的心似乎总是躁动无比，安定不下来，总是需要寻求刺激来掩盖空虚，像是音乐，游戏，又或是需要痛苦来压制欲望，抽烟，喝酒，莫不是如此。</p><p>孔子云，食色性也。<br>生而为人，某些东西是刻在基因里的，谁也不可能做到无欲，所以一个很重要的问题就是如何面对自己的欲望。<br>吃好吃的，喝好喝的，玩好玩的，这都是我们的欲望，有欲也无可厚非，只要做到适度即可。</p><p>欲望可以适当满足，痛苦也可以合理规避，但还有一个问题确实很难解决的？<br>我们那什么来面对平凡的生活？那什么了面对内心的空虚和无聊？<br>金刚经有问，云何降伏其心？</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列和栈专题</title>
      <link href="2021/04/27/dui-lie-he-zhan-zhuan-ti/"/>
      <url>2021/04/27/dui-lie-he-zhan-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<p>写篇文章，总结一下栈和队列</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种特殊的线性表，遵循先进后出的原则，只可以对栈顶元素进行操作。<br>主要包括压栈，出栈，查看栈顶元素三种操作。</p><h4 id="C语言数组实现顺序栈"><a href="#C语言数组实现顺序栈" class="headerlink" title="C语言数组实现顺序栈"></a>C语言数组实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;数组实现顺序栈typedef struct zhan &#123;char data[100];int top;&#125;zhan;void initzhan(zhan *a)&#123;a-&gt;top &#x3D; -1;&#125;void push(zhan* a, char b) &#123;a-&gt;data[++a-&gt;top] &#x3D; b;&#125;char pop(zhan* a) &#123;return a-&gt;data[a-&gt;top--];&#125;char gettop(zhan* a) &#123;return a-&gt;data[a-&gt;top];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言指针实现顺序栈"><a href="#C语言指针实现顺序栈" class="headerlink" title="C语言指针实现顺序栈"></a>C语言指针实现顺序栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;指针实现顺序栈typedef struct stack &#123;int* top;int* base;&#125;stack;void initstack(stack* a) &#123;a-&gt;base &#x3D; (int*)malloc(sizeof(int)*100);&#x2F;&#x2F;最大空间为100a-&gt;top &#x3D; a-&gt;base;&#125;void pushstack(stack* a, int b)&#123;*a-&gt;top &#x3D; b;a-&gt;top++;&#125;int popstack(stack* a) &#123;a-&gt;top--;return *a-&gt;top;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C语言实现链栈"><a href="#C语言实现链栈" class="headerlink" title="C语言实现链栈"></a>C语言实现链栈</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;链栈的实现typedef struct stack &#123;int data;struct stack *next;&#125;stack;void initstack(stack*a) &#123;&#x2F;&#x2F;stack* p;&#x2F;&#x2F;a &#x3D; p &#x3D; (stack*)malloc(sizeof(stack));&#x2F;&#x2F;a-&gt;next &#x3D; NULL;&#125;void pushstack(stack* a,int b) &#123;stack* p;p &#x3D; (stack*)malloc(sizeof(stack));p-&gt;data &#x3D; b;p-&gt;next &#x3D; a-&gt;next;a-&gt;next &#x3D; p;&#125;int popstack(stack * a)&#123;stack* p;int b;p &#x3D; a-&gt;next;b&#x3D; p-&gt;data;a-&gt;next &#x3D; p-&gt;next;free(p);return b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="C-的栈"><a href="#C-的栈" class="headerlink" title="C++的栈"></a>C++的栈</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;stack&gt;初始化出栈压栈取栈顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="C-的队列"><a href="#C-的队列" class="headerlink" title="C++的队列"></a>C++的队列</h4><h3 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h3><p>来自leetcode的一道题目。<br>挺有启发性的，如何用两个队列实现一个栈。</p><pre class="line-numbers language-none"><code class="language-none">class MyStack &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    queue&lt;int&gt; queue1;    queue&lt;int&gt; queue2;    MyStack() &#123;         &#125;        &#x2F;** Push element x onto stack. *&#x2F;    void push(int x) &#123;       &#x2F;&#x2F;queue2做辅助队列，用来翻转queue1,同理，一个队列也可以实现       while(!queue1.empty())&#123;        int a&#x3D;queue1.front();        queue1.pop();        queue2.push(a);      &#125;      queue1.push(x);      while(!queue2.empty())&#123;        int a&#x3D;queue2.front();        queue2.pop();        queue1.push(a);      &#125;    &#125;        &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;    int pop() &#123;     int a&#x3D; queue1.front();     queue1.pop();     return a;    &#125;        &#x2F;** Get the top element. *&#x2F;    int top() &#123;     return queue1.front();    &#125;        &#x2F;** Returns whether the stack is empty. *&#x2F;    bool empty() &#123;   return queue1.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>来自leetcode的另一个题目，用两个栈实现一个队列。</p><pre class="line-numbers language-none"><code class="language-none">class MyQueue &#123;public:    &#x2F;** Initialize your data structure here. *&#x2F;    stack&lt;int&gt; a;    stack&lt;int&gt; b;    MyQueue() &#123;    &#125;        &#x2F;** Push element x to the back of queue. *&#x2F;    void push(int x) &#123;     while(!a.empty())&#123;         int c&#x3D;a.top();         a.pop();         b.push(c);     &#125;     a.push(x);     while(!b.empty())&#123;         int c&#x3D;b.top();         b.pop();         a.push(c);     &#125;    &#125;        &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;    int pop() &#123;        int c&#x3D;a.top();        a.pop();          return c ;    &#125;        &#x2F;** Get the front element. *&#x2F;    int peek() &#123;                 return a.top();    &#125;        &#x2F;** Returns whether the queue is empty. *&#x2F;    bool empty() &#123;      return a.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法总结</title>
      <link href="2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/"/>
      <url>2021/04/27/chang-yong-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>总结一些常用的排序算法。</p><p>先定义一个数组用来进行接下来的排序</p><pre class="line-numbers language-none"><code class="language-none">int num[] &#x3D; &#123; 4,9,7,15,67,89,97,123,468,12,34,76,8,9,4,1,80,100 &#125;;&#x2F;&#x2F;获取数组长度int length;length &#x3D; sizeof(num) &#x2F; sizeof(int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下皆为从小到大的排序</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length - 1; i++) &#123;for (int j &#x3D; 0; j &lt; length - 1-i; j++) &#123;if (num[j] &gt; num[j + 1]) &#123;int t &#x3D; num[j];num[j] &#x3D; num[j + 1];num[j + 1] &#x3D; t;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; length; i++) &#123;int min &#x3D; num[i];for (int j &#x3D; i; j &lt; length; j++) &#123;if (min &gt; num[j]) &#123;int t &#x3D; min;min &#x3D; num[j];num[j] &#x3D; t;&#125;&#125;num[i] &#x3D; min;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;先定义一个交换函数void exchange(int* p, int* q) &#123;int temp &#x3D; *p;*p &#x3D; *q;*q &#x3D; temp;&#125;int quaipai(int left, int right) &#123;&#x2F;&#x2F;双指针相遇，排序结束if (left &gt;&#x3D; right) &#123;return 0;&#125;int i,j, t;&#x2F;&#x2F;左右指针及基准i &#x3D; left;j &#x3D; right;t &#x3D; num[left];&#x2F;&#x2F;移动函数while (i !&#x3D; j) &#123;while (i &lt; j &amp;&amp; num[j] &gt;&#x3D; t) &#123;j--;&#125;exchange(&amp;num[i], &amp;num[j]);        while (i &lt; j &amp;&amp; num[i] &lt;&#x3D; t) &#123;i++;                                     &#125;exchange(&amp;num[i], &amp;num[j]);&#125;&#x2F;&#x2F;递归此过程quaipai(i + 1, right);quaipai(left, i - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL学习笔记</title>
      <link href="2021/04/27/c-stl-xue-xi-bi-ji/"/>
      <url>2021/04/27/c-stl-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>最近开始刷leetcode了，发现很多题目还是有现成的数据结构和相关方法比较好，c语言啥都自己造太费劲了。<br>Java有些东西太啰嗦了，自己也不是特别熟练，还是C/C++用的比较顺手，于是打算学学C++的STL模板库。<br>写个帖子，做一些记录。</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>见得最多的容器，还是数vector.<br>vector可以看做是一个动态的数组。</p><ul><li>常见用法<br>初始化<br>vector<int> a;<br>a.size();<br>a.empty();</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue<int> a;<br>a.pop();<br>a.push(x);<br>a.front();<br>a.empty();<br>a.size();</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack<int> a;<br>a.pop();<br>a.push(x);<br>a.top();<br>a.empty();<br>a.size();</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp8266通过串口发送http请求</title>
      <link href="2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/"/>
      <url>2021/04/26/esp8266-tong-guo-chuan-kou-fa-song-http-qing-qiu/</url>
      
        <content type="html"><![CDATA[<p>这两天在想如何使用esp8266发送一个http请求，于是上网查找有没有相关的库，后来查资料发现，在tcp透传模式下，可以直接自己模拟一个http的请求。<br>仔细想想也确实是这样，http协议本身就是基于tcp协议实现的，通过tcp手动模拟http是完全可行的。<br>不得不说，计算机网络的一些知识好久不用都忘的差不多了，有些东西果然还是要在实践中加强认识。</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p><h4 id="http请求头"><a href="#http请求头" class="headerlink" title="http请求头"></a>http请求头</h4><p>请求头包括四个部分：<br>请求行<br>请求首部<br>空行<br>请求正文</p><h4 id="http返回头"><a href="#http返回头" class="headerlink" title="http返回头"></a>http返回头</h4><p>返回头同样包括四个部分：<br>状态行<br>消息报头<br>空行<br>响应正文</p><h3 id="通过网络调试助手测试"><a href="#通过网络调试助手测试" class="headerlink" title="通过网络调试助手测试"></a>通过网络调试助手测试</h3><p>我们测试使用的api如下<br><a href="http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8">http://hn216.api.yesapi.cn/?s=App.Common_Weather.LiveWeather&amp;return_data=0&amp;city=%E9%95%BF%E6%B2%99&amp;app_key=7DD22AAA0953B916BA785C889640AA62&amp;sign=91C852984E53DF0E2DC87968E9EE32B8</a><br>这是果创云提供的一个天气查询的接口，通过发送get请求，可以得到对应城市的天气，返回的数据类型为json格式。<br>我们先使用浏览器访问一下这个接口<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_1.png" ><br>由于网络调试助手的限制，我们必须要知道api的服务器地址和端口号<br>在浏览器上点击检查网页，在network标签下的header标签中可以找到我们想要的信息</p><p>通过网络调试助手，输入刚刚查到的ip和端口号，建立一个tcp连接<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_2.png" ><br>发送相应格式的请求，可以看到，我们已经收到了api接口返回的数据<br>（这里由于调试助手编码格式的问题，中文会显示乱码）</p><h3 id="esp8266通过TCP透传发送http请求"><a href="#esp8266通过TCP透传发送http请求" class="headerlink" title="esp8266通过TCP透传发送http请求"></a>esp8266通过TCP透传发送http请求</h3><p>调试时遇到了挺大的bug,模块的硬件电路出了点莫名其妙的问题，串口连接模块后，发送任何指令都没有反应，后来拿电压表测了一下，模块上电后CH_PD居然是低电平，于是又自己把CH_PD拉到高电平，解决了这一问题。<br>esp8266连接串口之后，依次发送如下指令：<br><code>AT+RST</code><br>//复位模块<br><code>AT+CWMODE=1</code><br>//进入STA模式<br><code>AT+RST</code><br>//复位生效上一条命令<br><code>AT+CWJAP=”note”,”123456789” </code><br>//连接到wifi<br><code>AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.1.115&quot;,8080</code><br>//连接到tcp服务器<br><code>AT+CIPMODE=1</code><br>//开启透传模式<br><code>AT+CIPSEND</code><br>//进入透传</p><p>进入透传后，发送以下数据<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210502_3.png" ><br>可以看到，我们成功地收到了服务器返回的接口数据<br>（由于电脑编码格式问题，此处存在乱码）</p>]]></content>
      
      
      <categories>
          
          <category> esp8266 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android实现mqtt客户端</title>
      <link href="2021/04/25/android-shi-xian-mqtt-ke-hu-duan/"/>
      <url>2021/04/25/android-shi-xian-mqtt-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<p>这一篇文章我们主要讲如何在Android上实现一个mqtt的客户端。</p><h3 id="在gradle中添加依赖"><a href="#在gradle中添加依赖" class="headerlink" title="在gradle中添加依赖"></a>在gradle中添加依赖</h3><pre class="line-numbers language-none"><code class="language-none">implementation &#39;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0&#39;implementation &#39;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="添加相关的权限"><a href="#添加相关的权限" class="headerlink" title="添加相关的权限"></a>添加相关的权限</h3><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.WAKE_LOCK&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#x2F;&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p><code>&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot;&gt;&lt;/service&gt;</code></p><h3 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h3><ul><li>xml<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;zhuti&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的主题&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;neirong&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的内容&quot;        &#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;button&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;发送&quot;        &#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;textView&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>MainActivity.java<pre class="line-numbers language-none"><code class="language-none">import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;import org.eclipse.paho.client.mqttv3.MqttCallback;import org.eclipse.paho.client.mqttv3.MqttClient;import org.eclipse.paho.client.mqttv3.MqttConnectOptions;import org.eclipse.paho.client.mqttv3.MqttException;import org.eclipse.paho.client.mqttv3.MqttMessage;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;public class MainActivity extends AppCompatActivity &#123;    EditText zhuti;    EditText neirong;    Button fasong;    TextView jieshou;    MqttClient client;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F;App lianjie&#x3D;new App();        String subTopic &#x3D; &quot;test&quot;;        String pubTopic &#x3D; &quot;test&quot;;        String content &#x3D; &quot;Hello World&quot;;        int qos &#x3D; 2;        String broker &#x3D; &quot;tcp:&#x2F;&#x2F;49.235.68.28:1883&quot;;        String clientId &#x3D; &quot;emqx_test&quot;;        MemoryPersistence persistence &#x3D; new MemoryPersistence();        Log.i(&quot;aaa&quot;, &quot;运行中&quot;);        zhuti&#x3D;findViewById(R.id.zhuti);        neirong&#x3D;findViewById(R.id.neirong);        fasong&#x3D;findViewById(R.id.button);        jieshou&#x3D;findViewById(R.id.textView);        try &#123;             client &#x3D; new MqttClient(broker, clientId, persistence);            &#x2F;&#x2F; MQTT 连接选项            MqttConnectOptions connOpts &#x3D; new MqttConnectOptions();            connOpts.setUserName(&quot;emqx_test&quot;);            connOpts.setPassword(&quot;emqx_test_password&quot;.toCharArray());            &#x2F;&#x2F; 保留会话            connOpts.setCleanSession(true);            &#x2F;&#x2F; 设置回调            client.setCallback(new OnMessageCallback1());            &#x2F;&#x2F; 建立连接            Log.i(&quot;abc&quot;, &quot;Connecting to broker: &quot; + broker);            client.connect(connOpts);            Log.i(&quot;bcd&quot;, &quot;Connected&quot;);            Log.i(&quot;cde&quot;, &quot;Publishing message: &quot; + content);            &#x2F;&#x2F; 订阅            client.subscribe(subTopic);            &#x2F;&#x2F; 消息发布所需参数            MqttMessage  message &#x3D; new MqttMessage(content.getBytes());            message.setQos(qos);            client.publish(pubTopic, message);            Log.i(&quot;def&quot;, &quot;Message published&quot;);            &#x2F;&#x2F;client.disconnect();            &#x2F;&#x2F; Log.i(&quot;efg&quot;,&quot;Disconnected&quot;);            &#x2F;&#x2F; client.close();            &#x2F;&#x2F;System.exit(0);        &#125; catch (MqttException me) &#123;            Log.i(&quot;1&quot;, &quot;reason &quot; + me.getReasonCode());            Log.i(&quot;2&quot;, &quot;msg &quot; + me.getMessage());            Log.i(&quot;3&quot;, &quot;loc &quot; + me.getLocalizedMessage());            Log.i(&quot;4&quot;, &quot;cause &quot; + me.getCause());            Log.i(&quot;5&quot;, &quot;excep &quot; + me);            me.printStackTrace();        &#125;        fasong.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;            if(zhuti.getText().toString().equals(&quot;&quot;)||neirong.getText().toString().equals(&quot;&quot;))&#123;                Toast.makeText(MainActivity.this, &quot;请输入主题和内容&quot;, Toast.LENGTH_SHORT).show();            &#125;            else&#123;                try &#123;                    MqttMessage  message &#x3D; new MqttMessage(neirong.getText().toString().getBytes());                    message.setQos(qos);                    client.publish(zhuti.getText().toString(), message);                &#125; catch (MqttException e) &#123;                    e.printStackTrace();                &#125;&#125;            &#125;        &#125;);    &#125;&#x2F;&#x2F;回调函数 class OnMessageCallback1 implements MqttCallback &#123;    public void connectionLost(Throwable cause) &#123;        &#x2F;&#x2F; 连接丢失后，一般在这里面进行重连        Log.i(&quot;duankai&quot;,&quot;连接断开，可以做重连&quot;);    &#125;    public void messageArrived(String topic, MqttMessage message) throws Exception &#123;        &#x2F;&#x2F; subscribe后得到的消息会执行到这里面        Log.i(&quot;xiaoxi&quot;,&quot;接收消息主题:&quot; + topic);        Log.i(&quot;qos&quot;,&quot;接收消息Qos:&quot; + message.getQos());        Log.i(&quot;neirong&quot;,&quot;接收消息内容:&quot; + new String(message.getPayload()));        runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以        &#123;            public void run()            &#123;                &#x2F;&#x2F; TODO Auto-generated method stub               &#x2F;&#x2F; Toast.makeText(MainActivity.this, new String(message.getPayload()), Toast.LENGTH_SHORT).show();               jieshou.append(new String(message.getPayload())+&quot;\n&quot;);            &#125;        &#125;);    &#125;    public void deliveryComplete(IMqttDeliveryToken token) &#123;        Log.i(&quot;delivery&quot;,&quot;deliveryComplete---------&quot; + token.isComplete());    &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>模拟器与真机均测试通过<br>以下是模拟器测试的图片<br>app默认订阅了test主题，发送消息的主题可自己设置</li><li>app<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_7.png" width="60%" height="60%"></li><li>websocket(一个在线的mqtt客户端)<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_8.png" ></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/jqnl/p/12660824.html">MQTT协议实现Android中的消息收发</a><br><a href="https://docs.emqx.cn/broker/v4.3/development/java.html">EMQX开发文档</a></p>]]></content>
      
      
      <categories>
          
          <category> mqtt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> mqtt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mqtt服务器的搭建</title>
      <link href="2021/04/25/mqtt-fu-wu-qi-de-da-jian/"/>
      <url>2021/04/25/mqtt-fu-wu-qi-de-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。<br><em>(以上内容来自百度百科)</em></p><p>mqtt是一种基于发布/订阅的消息传输协议，客户端可以发送或接受某个主题的消息，而服务器则是用来为各个客户端推送消息的中间件，通常称为代理。</p><p>通俗地说，如果把我们每个人的qq账号看做是客户端，那么腾讯的服务器就类似于mqtt的代理，只有有了这个代理，各个客户端之间才能正常通信，所以说代理（mqtt服务器）是mqtt通信的重要组成部分。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下面直接进入正题，开始我们mqtt服务器的搭建。<br>常见的mqtt服务器软件有很多种，这里我们采用EMQX来进行我们mqtt服务器的搭建。<br>EMQX的使用文档如下:<br><a href="https://docs.emqx.cn/broker/v4.3/">EMQX</a></p><p>首先登陆自己购买的服务器的管理界面（我这里使用的是腾讯云的服务器），打开webshell连接到服务器。<br>在webshell中输入以下命令:<br><code>curl https://repos.emqx.io/install_emqx.sh | bash</code><br>如果显示权限不够，请切换到root用户执行该命令</p><ul><li>显示以下结果，则说明安装成功</li></ul><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_1.png" ><ul><li>最后，在shell中输入<code>emqx start</code>启动mqtt服务器</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>EMQ X 提供了 Dashboard 以方便用户管理设备与监控相关指标。通过 Dashboard，你可以查看服务器基本信息、负载情况和统计数据，可以查看某个客户端的连接状态等信息甚至断开其连接，也可以动态加载和卸载指定插件。除此之外，EMQ X Dashboard 还提供了规则引擎的可视化操作界面，同时集成了一个简易的 MQTT 客户端工具供用户测试使用。</p><p>我们可以通过ip:18083来访问dashboard.<br>如果访问失败，检查服务器的安全组规则是否放行该端口。<br>Dashboard的默认用户名是 admin，密码是 public。<br>在设置中可以将语言改成中文。<br>dashboard提供了一个websocket,可以作为一个在线的mqtt客户端来进行测试。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_2.png" ></li></ul><p>我们可以使用一个本地的mqtt客户端，来和websocket进行通信。<br>这里我们使用mqttx来进行测试，下载链接如下。<br><a href="https://mqttx.app/cn/">mqttx客户端</a></p><p>在websocket中订阅一个test主题，并在该主题下发布消息，可以看到，在下方的列表中显示了该主题下的消息。</p><ul><li>websocket<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_3.png" >使用本地的mqtt客户端连接到mqtt服务器</li><li>本地客户端连接到服务器<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_4.png" ></li><li>在本地mqtt客户端订阅test主题，并在test主题下发布消息“hello”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_5.png" ></li><li>在websocket订阅test主题，并在test主题下发布消息“hi”<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210425_6.png">可以看到，websocket和本地的mqtt客户端都收到了他们互相发布的消息，测试成功。同时，我们也可以看到，当客户端订阅一个主题的时候，即使主题下有一个消息是自己发布的，客户端也会收到这个消息。</li></ul><h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> mqtt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mqtt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言在函数中修改外部指针变量的值</title>
      <link href="2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/"/>
      <url>2021/04/18/c-yu-yan-zai-han-shu-zhong-xiu-gai-wai-bu-zhi-zhen-bian-liang-de-zhi/</url>
      
        <content type="html"><![CDATA[<p>最近又开始学数据结构了，总结一下之前写链表时遇到的一个问题。<br>如何在函数中修改一个外部指针变量的值，注意，是指针变量本身的值，而不是指针指向的变量的值，也就是说，我们要在函数中改变指针的指向。<br>先来看一个例子吧</p><ul><li>示例1<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在redirect函数中，s指向了b，但是p并未指向b,p中储存的仍然是a的地址。<br>这是为什么呢？<br>指针s并不是指针p本身，它仅仅是指针p的一个副本，储存了指针p的值，也就是说，指针s其实是另一个变量，它储存的地址和p储存的地址是一样的，但是改变s储存的地址，并不会改变p储存的地址。</li></ul><p>那我们怎么才能在函数中改变指针的指向呢？<br>我们知道，函数是默认传递值的，而不是传递地址，想要改变一个普通变量的值，我们就需要传递它的指针给函数。<br>那么，想要改变指针变量的值，我们就需要传递指针的指针给函数，没错，需要使用二级指针来改变指针的值。</p><ul><li>示例2<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">*</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，这时p已经指向了b,即我们成功地在函数中改变了指针p的值。</li></ul><p>此外，我们也可以通过引用在函数中改变指针的值。</p><ul><li>示例3：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">redirect</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p=%d,a=%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>输出：p<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，此时p也指向了b.</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>c语言在传递函数的参数时，传递给函数的，并不是变量本身，而是变量的一个拷贝。<br>只有在使用引用时，传递给函数的才是变量本身。<br>要想在函数中改变一个普通变量的值，我们需要使用指针来实现，那么要想在函数中改变一个指针变量的值，我们需要使用指针的指针，即二级指针来实现。<br>此外，也可以通过使用引用，传递变量本身来实现。</p>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSP432入门之流水灯实验</title>
      <link href="2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/"/>
      <url>2021/04/15/msp432-ru-men-zhi-liu-shui-deng-shi-yan/</url>
      
        <content type="html"><![CDATA[<p>最近在电赛培训网参加活动，中了一块TI的单片机开发板，具体型号为SimpleLink Ethernet MSP432E401Y Microcontroller LaunchPad。<br>这两天打算简单学一学这款单片机。<br>不得不说，网上关于MSP432单片机的资料是真的少，关于MSP432E4的资料更是少的可怜。<br>无奈只能从读TI官方给出的SDK和datasheet开始学习了。</p><h3 id="开发环境的选择"><a href="#开发环境的选择" class="headerlink" title="开发环境的选择"></a>开发环境的选择</h3><p>MSP432可以采用keil,ccs,iar来进行开发，这里我选择了官方主推的ccs来进行学习。<br>从ti的官网下载ccs和MSP432E4的SDK，并将ccs和SDK配置好，之后就可以进行我们的开发了。</p><h3 id="driverlib和tidriver"><a href="#driverlib和tidriver" class="headerlink" title="driverlib和tidriver"></a>driverlib和tidriver</h3><p>关于MSP432，官方的SDK中给出了两大类库，driverlib和tidriver.<br>driverlib更接近底层，能实现的功能也更加的丰富。<br>tidriver更加的抽象，也更容易理解和使用，更重要的是，tidriver可以采用图形化的操作来配置单片机的外设。<br>当然，tidriver的功能可能不是特别的完善，所以有时候也可以调用driverlib中的部分功能或者直接操作寄存器来实现某些功能，不过tidriver和driverlib的某些文件可能会产生冲突，这一点在使用时是需要注意的。</p><h3 id="流水灯实验"><a href="#流水灯实验" class="headerlink" title="流水灯实验"></a>流水灯实验</h3><p>SDK中提供了很多demo，我们可以直接通过导入demo的工程来进行开发，这里我们采用tidriver的工程来进行开发，对于初学者来说，图形化的外设配置相比于代码要容易好多。<br>首先我们打开css,导入一个tidriver库中的demo，随便挑选一个就可以。</p><ul><li>导入工程<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_1.png" ></li></ul><p>通过项目管理栏可以看出，工程中主要有两个c文件，main_nortos.c主要负责开发板的初始化启动，启动后跳转到gpiointerrupt.c中的mainThread函数中运行，这里我们不需要进行改动。</p><ul><li>mainnortos.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_2.png" ></li></ul><p>gpiointertupt.c文件中有一个mainThread函数，我们要在mainThread函数中书写我们需要的用户代码。</p><p>外设的配置<br>打开资源管理栏后缀名为syscfg的配置文件，在其中配置我们需要使用的设备。<br>这里我们配置4个LED灯就可以。</p><ul><li>图形化外设配置<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_3.png" ></li></ul><p>保存之后，我们对外设的配置都会保存到ti_driver_config.c(.h)文件中.</p><ul><li>ti_driver_config.h<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_4.png" ></li></ul><p>打开interrupt函数，删掉原有代码，编写我们需要的代码。</p><ul><li>interrupt.c<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_5.png" ></li></ul><p>点击导航栏进行编译和烧录</p><ul><li>编译和烧录<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_6.png" ></li></ul><p>之后，就可以看到板子上的4个LED轮流点亮和熄灭了。</p><ul><li>运行效果<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210417_7.jpg" ></li></ul><h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><p> void delay(){<br>        int i=0;<br>        for(i=0;i&lt;1000000;i++);<br>    }</p><p>void *mainThread(void <em>arg0)<br>{<br>    /</em> Call driver unit functions <em>/<br>    GPIO_init();<br>    /</em> Configure the LED and button pins */<br>    GPIO_setConfig(CONFIG_GPIO_1, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_2, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_3, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    GPIO_setConfig(CONFIG_GPIO_4, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_LOW);<br>    while(1){<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_1);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_2);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_3);<br>        delay();<br>        GPIO_toggle(CONFIG_GPIO_4);<br>    }<br>    return (NULL);<br>}</p>]]></content>
      
      
      <categories>
          
          <category> MSP432单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> MSP432 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD之PCB画板初探</title>
      <link href="2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/"/>
      <url>2021/04/15/ad-zhi-pcb-hua-ban-chu-tan/</url>
      
        <content type="html"><![CDATA[<p>最近由于选修课的要求，速成了一波AD，这两天完成了自己的第一个PCB板的绘制。</p><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><p>1.三个开关控制一盏灯<br>2.使用按钮实现开关的功能</p><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>1.三个开关控制一盏灯，算是比较基础的数电问题了，这里我采用了74LS86（异或门）来实现这一逻辑功能。</p><p>2.按钮实现开关的功能，这一点我上网查资料发现都是采用模拟电路实现的，采用电容充放电实现开关的功能，电路较为复杂，实现原理也较为复杂，这里就不讲了。</p><p>分享一篇文章，有兴趣的可以自己看看<a href="https://baijiahao.baidu.com/s?id=1603206971622118062&wfr=spider&for=pc&qq-pf-to=pcqq.group">点按式轻触开关如何实现自锁轻触开关带锁按键开关功能？</a><br>3.后来想了想，还是采用数字电路实现比较简单，通过JK触发器的电平翻转来实现电路开关的功能，最后通过带JK触发器的74LS109实现了这一功能。</p><h3 id="PCB绘制流程"><a href="#PCB绘制流程" class="headerlink" title="PCB绘制流程"></a>PCB绘制流程</h3><p>1.原理图库的绘制<br>由于官方封装库中的门电路芯片都是只显示部分的，所以这里我自己绘制了74LS86和74LS109芯片的原理图。</p><ul><li>74LS86<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li><li>74LS109<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_1.png" ></li></ul><p>2.原理图的绘制</p><ul><li>原理图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_4.png" ></li></ul><p><strong>ps:</strong> 经老师提醒，原理图中按钮部分存在问题，TTL芯片悬空时为高电平，所以芯片的CLK端口需要接一个下拉电阻。</p><p>3.PCB封装库的绘制<br>这里偷了点懒，直接采用了TI官方的封装库。</p><ul><li>D014_N封装<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_3.png" ></li></ul><p>4.PCB图的绘制</p><p>这一步才算是到了PCB绘制的核心部分。</p><h4 id="器件摆放"><a href="#器件摆放" class="headerlink" title="器件摆放"></a>器件摆放</h4><p>AD会将原理图中用到所有器件直接转移到PCB文件中，我们需要将各个器件以合适的位置摆放好。</p><h4 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h4><p>AD有自动布线功能，但还是推荐手动布线。<br>布线拐角采用钝角，降低电磁干扰。<br>多层板可能需要过孔，将各个板层进行电气连接。</p><h4 id="铺铜"><a href="#铺铜" class="headerlink" title="铺铜"></a>铺铜</h4><p>将没有导线的地方铺铜，提高抗干扰能力。</p><h4 id="丝印"><a href="#丝印" class="headerlink" title="丝印"></a>丝印</h4><p>添加需要的标记符号和个性化定制文字内容。</p><h4 id="版型设计"><a href="#版型设计" class="headerlink" title="版型设计"></a>版型设计</h4><p>对PCB板进行裁剪，打定位孔等操作，推荐矩形版型。</p><ul><li>最后贴上我的第一个PCB板<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210416_5.png" >(空白处有姓名等相关信息，已打码)</li></ul>]]></content>
      
      
      <categories>
          
          <category> PCB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
            <tag> 数字电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客域名大赏</title>
      <link href="2021/04/15/bo-ke-yu-ming-da-shang/"/>
      <url>2021/04/15/bo-ke-yu-ming-da-shang/</url>
      
        <content type="html"><![CDATA[<p>这个博客从最开始在gitee上搭建，到github上搭建，又到vercel上托管，前前后后变换了好几个平台，也搞出了好多个域名。<br>今天写个记录，记录一下这些域名。</p><h3 id="gitee-版"><a href="#gitee-版" class="headerlink" title="gitee 版"></a>gitee 版</h3><p>1.<a href="https://yeyuwenxi.gitee.io/">https://yeyuwenxi.gitee.io/</a><br>gitee的主要问题有两个，一是不能自动更新，而是首页图标的显示存在问题，与github双部署时无法同时正常显示</p><h3 id="github版"><a href="#github版" class="headerlink" title="github版"></a>github版</h3><p>2.<a href="https://yeyuwenxi.github.io/%EF%BC%88%E8%AE%BF%E9%97%AE%E6%97%B6%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B03%EF%BC%89">https://yeyuwenxi.github.io/（访问时自动跳转到3）</a><br>3.<a href="https://yeyuwenxi.xyz/%EF%BC%88%E4%B8%BB%E7%AB%99%E7%82%B9%EF%BC%89">https://yeyuwenxi.xyz/（主站点）</a></p><h3 id="vercel加速版"><a href="#vercel加速版" class="headerlink" title="vercel加速版"></a>vercel加速版</h3><p>4.<a href="https://yeyuwenxi.vercel.app/%EF%BC%88%E5%B7%B2%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B07%EF%BC%89">https://yeyuwenxi.vercel.app/（已重定向到7）</a><br>5.<a href="https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-2551676400-qqcom.vercel.app/</a><br>6.<a href="https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/">https://yeyuwenxi-github-io-git-master-2551676400-qqcom.vercel.app/</a><br>7.<a href="https://blog.yeyuwenxi.xyz/">https://blog.yeyuwenxi.xyz/</a><br>不得不说，vercel托管后，域名是真的多</p><h3 id="关于域名解析服务器"><a href="#关于域名解析服务器" class="headerlink" title="关于域名解析服务器"></a>关于域名解析服务器</h3><p>yeyuwenxi.xyz的域名服务器在腾讯云<br>blog.yeyuwenxi.xyz的域名服务器在vercel</p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>目前并没有感觉vercel比github pages快多少</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法学习笔记</title>
      <link href="2021/04/12/markdown-yu-fa-xue-xi-bi-ji/"/>
      <url>2021/04/12/markdown-yu-fa-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。<br>个人认为，Markdown可以看做xml,html的简化版，非常适合用来纯文本编辑。<br>好了，下面直接进入语法部分。</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>markdown使用#来表示标题,支持六级标题<br>示例：<br><code># 一</code><br><code>## 二</code><br><code>### 三</code><br><code>#### 四</code><br><code>##### 五</code><br><code>###### 六</code></p><p>显示效果：</p><h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><h5 id="五"><a href="#五" class="headerlink" title="五"></a>五</h5><h6 id="六"><a href="#六" class="headerlink" title="六"></a>六</h6><p>注意：#和文字之间要加1个空格</p><h3 id="2-超链接"><a href="#2-超链接" class="headerlink" title="2.超链接"></a>2.超链接</h3><p>示例：<br><code> [百度](baidu.com)</code><br>显示效果：<br><a href="baidu.com">百度</a></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;a href=&quot;baidu.com&quot;&gt;百度 &lt;/a&gt;</code><br>显示效果：<br><a href="baidu.com">百度 </a></p><h3 id="3-图片"><a href="#3-图片" class="headerlink" title="3.图片"></a>3.图片</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>示例：<br><code>![图片名称](https://www.baidu.com/img/flexible/logo/pc/result.png)</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png" alt="图片名称"></p><p><strong>此外，也可使用html风格的写法</strong><br>示例：<br><code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;&gt;</code><br>显示效果：<br><img src="https://www.baidu.com/img/flexible/logo/pc/result.png"></p><h4 id="3-2-设置图片的大小"><a href="#3-2-设置图片的大小" class="headerlink" title="3.2 设置图片的大小"></a>3.2 设置图片的大小</h4><p>示例：<code>&lt;img src=&quot;https://www.baidu.com/img/flexible/logo/pc/result.png&quot;      width=&quot;10%&quot; height=&quot;10%&quot;&gt;</code><br>显示效果：<img src="https://www.baidu.com/img/flexible/logo/pc/result.png" width="10%" height="10%" ></p><h4 id="3-3-设置图片居中显示"><a href="#3-3-设置图片居中显示" class="headerlink" title="3.3 设置图片居中显示"></a>3.3 设置图片居中显示</h4><h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h3><h4 id="4-1单行代码"><a href="#4-1单行代码" class="headerlink" title="4.1单行代码"></a>4.1单行代码</h4><p>使用英文反顿号”<code> </code>“表示单行代码<br>示例：<br>显示效果：123</p><h4 id="4-2多行代码"><a href="#4-2多行代码" class="headerlink" title="4.2多行代码"></a>4.2多行代码</h4>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab实现简单的语音信号处理</title>
      <link href="2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/"/>
      <url>2021/04/12/matlab-shi-xian-jian-dan-de-yu-yin-xin-hao-chu-li/</url>
      
        <content type="html"><![CDATA[<p>学习数字信号处理课程时做过的一个实验。</p><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>  1.学习并掌握数字信号处理的基本方法。<br>  2.学会使用MATLAB对语音信号进行处理。<br>  3.学习并掌握MATLAB设计滤波器的方法。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>   本次实验基于MATLAB R2019a完成，利用MATLAB对录制的语音信号进行了读取，播放，时域分析，频域分析以及滤波处理等操作。<br>   本次实验主要包括以下几个步骤：<br>1.音频的录制与导入<br>    使用手机自带的录音软件录制了格式为wav的一段语音信号。录音完成后，使用MATLAB的audioread函数对语音信号进行采样。<br>2.语音信号的时域分析和频域分析<br>    使用plot函数绘制语音信号的时域波形，对语音信号进行快速傅里叶变换，并绘制出语音信号的频域波形。<br>    <img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_1.jpg" width="60%" height="60%"><br>3.设计滤波器对语音信号进行处理<br>（1）低通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯低通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字低通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_2.jpg" width="60%" height="60%"><br>低通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_3.jpg" width="60%" height="60%"><br>（2）高通滤波器的设计<br>利用buttord和butter函数设计一个模拟巴特沃斯高通滤波器，并利用bilinear函数采用双线性变换法将该滤波器转换为数字高通滤波器。<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_4.jpg" width="60%" height="60%"><br>高通滤波器处理后的信号<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_5.jpg" width="60%" height="60%"><br>（3）陷波器的设计<br>根据陷波器的表达式配置参数，设计陷波器如下图所示<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_6.jpg" width="60%" height="60%"><br>使用陷波器处理后的频谱<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_7.jpg" width="60%" height="60%"><br>（4）对语音信号加噪<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210412_8.jpg" width="60%" height="60%"></p><h3 id="三、实验代码"><a href="#三、实验代码" class="headerlink" title="三、实验代码"></a>三、实验代码</h3><p>[x,fs]=audioread(‘yuyin.wav’);%录入语音信号<br>n=length(x);%获取语音信号的长度<br>x_p=fft(x,n);%利用FFT算法对语音信号进行离散傅里叶变换<br>f=fs*(0:n-1)/n;%频率的归一化<br>figure(1);%绘制时域和频域波形<br>subplot(2,1,1);<br>plot(x);<br>title(‘原始语音信号采样后的时域波形’);<br>xlabel(‘时间轴’)<br>ylabel(‘幅值A’)<br>subplot(2,1,2);<br>plot(f,abs(x_p));<br>title(‘原始语音信号采样后的频谱图’);<br>xlabel(‘频率Hz’);<br>ylabel(‘频率幅值’);<br>%噪声<br>% noise=0.2<em>randn(1,n);<br>% x_z=x+noise’;<br>% sound(x_z,fs);<br>% n=length(x);<br>% x_zp=fft(x_z,n);<br>% f=fs</em>(0:n/2-1)/n;<br>% figure(5);<br>% subplot(2,1,1);<br>% plot(x_z);<br>% title(‘加噪语音信号时域波形’);<br>% xlabel(‘时间轴’)<br>% ylabel(‘幅值A’)<br>% subplot(2,1,2);<br>% plot(f,abs(x_zp(1:n/2)));<br>% title(‘加噪语音信号频谱图’);<br>% xlabel(‘频率Hz’);<br>% ylabel(‘频率幅值’);<br>% %低通滤波器<br>fp=800;fs=1300;rs=35;rp=0.5;Fs=44100;<br>wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>[n,wn]=buttord(wp,ws,rp,rs,’s’);<br>[b,a]=butter(n,wn,’s’);<br>[num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>[h,w]=freqz(num,den,512,Fs);<br>% 512为点数 Fs为频率范围<br>figure(2)<br>plot(w,abs(h));<br>xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>title(‘巴特沃斯低通滤波器幅度特性’);<br>axis([0,5000,0,1.2]);<br>grid on;%网格线<br>%高通滤波器<br>% fp=3800;fs=3300;rs=3;rp=0.5;Fs=44100;<br>% wp=2<em>Fs</em>tan(2<em>pi</em>fp/(2<em>Fs));%预畸<br>% ws=2</em>Fs<em>tan(2</em>pi<em>fs/(2</em>Fs));<br>% [n,wn]=buttord(wp,ws,rp,rs,’s’);<br>% [b,a]=butter(n,wn,’high’,’s’);<br>% [num,den]=bilinear(b,a,Fs);%双线性变换法  模拟滤波器转数字滤波器<br>% [h,w]=freqz(num,den,512,Fs);<br>% % 512为点数 Fs为频率范围<br>% figure(2)<br>% plot(w,abs(h));<br>% xlabel(‘频率/Hz’);ylabel(‘幅值’);<br>% title(‘巴特沃斯高通滤波器幅度特性’);<br>% axis([0,5000,0,1.2]);<br>% grid on;%网格线<br>%陷波器<br>% f0=3000;Fs=44100;r=0.9;<br>% w0=2<em>pi</em>f0/Fs;<br>% num=[1 -2<em>cos(w0) 1];<br>% den=[1 -2</em>r<em>cos(w0) r</em>r];<br>% N=1024;<br>% [H,w]=freqz(num,den,N);<br>% plot(w/pi/2<em>Fs,abs(H));<br>% grid on;<br>% title(‘陷波器的幅频响应’);<br>% [s1,Fs]=audioread(‘yuyin.wav’);<br>% %x1=s1(:,1);%选取一个声道的数据<br>% x1=s1;<br>% %sound(x1,Fs);<br>% N1=length(x1);<br>% Y1=fft(x1,N1);<br>% f1=Fs</em>(0:N1-1)/N1;<br>% %t1=(0:N1-1)/Fs;<br>% figure(3)<br>% plot(f1,abs(Y1))<br>% xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>% title(‘原始信号频谱’);<br>% grid on;axis([0 50000 0 600])<br>y=filter(num,den,x);<br>%sound(y,Fs);<br>N2=length(y);<br>Y2=fft(y,N2);<br>f2=Fs*(0:N2-1)/N2;<br>%t2=(0:N2-1)/Fs;<br>figure(4)<br>plot(f2,abs(Y2))<br>xlabel(‘频率/Hz’);ylabel(‘幅度’);<br>title(‘过滤后信号的频谱’);<br>grid on;<br>axis([0 50000 0 600])</p><h3 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h3><p>分析语音信号的频谱图可以看出，有效的语音信号主要集中在0到4000Hz之间，根据奈奎斯特定理，最低的采样频率为8000Hz.观察滤波前后语音信号频谱的变化，可以看出滤波器按要求处理了语音信号，本次实验顺利完成。<br>总的来说，通过这次实验我收获了很多，对matlab有了更加深入的认识，了解到了如何利用matlab的各种函数对语音信号进行处理，这次实验也加深了我对离散傅里叶变换和滤波器设计的理解，巩固了课堂上所学到的知识，也让我看到了自己所学的知识在生活中的应用。</p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《嘉莉妹妹》</title>
      <link href="2021/04/12/du-jia-li-mei-mei/"/>
      <url>2021/04/12/du-jia-li-mei-mei/</url>
      
        <content type="html"><![CDATA[<p>大二时英文选修课写的一篇小论文，这里是中文版，内容有所删减。</p><p>西奥多·德莱塞，美国伟大的现实主义作家。他的父亲是贫苦的德国移民，家里有很多的孩子，一家人生活很是拮据。德莱赛一生的大部分时间从事新闻工作，他走遍芝加哥、匹兹堡、纽约等大城市，广泛深入地观察了解社会，对资本主义制度有了很深的认识，为日后的文学创作积累了丰富的素材。</p><p>《嘉莉妹妹》是德莱赛的第一部著作，描写了农村姑娘嘉莉来到大城市芝加哥寻找幸福，为摆脱贫困，出卖自己的贞操，先后与推销员和酒店经理同居，后又凭美貌与表演才能成为演员而后走红的故事。其中，嘉莉私奔的情节来源于德莱赛妹妹的真实生活经历，他的妹妹曾跟一个偷钱潜逃的酒店经理私奔。</p><p>嘉莉是一个年轻的，纯朴的，没有经验的农村小姑娘，为了追求幸福的生活来到了大城市芝加哥。</p><p>正如作者在开篇时所写到的，一个年轻的没有经验的来自乡下的小姑娘来到大城市时，通常只有两种可能，得到善良的帮助而成为更好的人，或者被物质的诱惑影响而堕落。</p><p>很遗憾，嘉莉没有遇到能够真正在精神上帮助她的人，她的姐姐以及她的两个情人都不是那样的人，他们所教给嘉莉的，只有对物欲和名利的追求，只有物质至上的幸福观。在他们的影响下，嘉莉对上层社会，充盈的物质生活有了极大的渴望，她要拼劲全力地挤进那个社会，去享受物质上的快感与愉悦。对物欲的追求，让嘉莉迷失了初心，虚荣感让她放弃了一个人身上最淳朴的品质，就这样，嘉莉为了富裕的生活而两次出卖自己的贞操。</p><p>在德莱赛的那个时代，在垄断资本主义盛行的社会背景下，很难出现那样能给嘉莉以正确引导的人，每个人都在为自己的各种欲望而奔波。</p><p>嘉莉早期求职的过程也充分说明，在那个充满压迫，充满剥削的时代里，一个底层的普通人，靠自己的努力和勤奋是难以实现梦想的，是没有真正意义上的出路的，残酷的生活压迫着每一个普通人。</p><p>嘉莉靠美貌和运气以及出卖贞操走向了成功，而许许多多的平凡的人却只能在社会的底层不断地挣扎，承受着这个社会带给他们的苦难。从另一方面来说，获得成功的嘉莉也没有拥有真正意义上的快乐，与她相伴的只有内心的孤苦与空虚。无论成功与否，嘉莉都是痛苦的，物质上的满足并没有带给嘉莉真正的幸福感。</p><p>嘉莉正是作者所处那个时代的一个缩影，作者借嘉莉的视角，展现了资本主义带给人的种种苦难，揭露了资本主义社会的弊端，批判了金钱至上，物欲横流的社会现状。</p><p>在一个病态的资本主义社会里，在物质至上的时代里，是没有真正的幸福可言的。我想，这正是作者想要告诉我们的东西，一个人哪怕有了物质上的充盈，也会因为精神上的匮乏而陷入空虚。这一点对现在的我们也是适用的，我们不能陷于物质的牢笼而忽略了那些精神上值得我们去追寻的东西，不能为了自己的虚荣与欲望而放弃那些珍贵的有价值的道德品质。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机温度、压力信息采集与电机控制系统</title>
      <link href="2021/04/11/dan-pian-ji-wen-du-ya-li-xin-xi-cai-ji-yu-dian-ji-kong-zhi-xi-tong/"/>
      <url>2021/04/11/dan-pian-ji-wen-du-ya-li-xin-xi-cai-ji-yu-dian-ji-kong-zhi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>本次单片机温度、压力信息采集与电机控制系统实验是基于模数转换，数模转换，LCD显示，键盘扫描，脉冲控制等知识的一个综合性的实验模块。<br>本次实验作品主要包括温度的采集与显示，压力的采集与显示，步进电机的驱动与控制三个模块。<br>温度的采集采用DS18B20模块，DS18B20采集温度后将温度转换为数字量并将数字量通过串行通信的方式发送给单片机。压力的采集采用称重传感器和HX711模块，HX711可将称重传感器的小信号放大并转换为数字量，最后再通过串行通信的方式将数字量传送给单片机。单片机处理完HX711和DS18B20的数据后，将压力值和温度值显示再LCD1602上。步进电机模块采用了一个四相五线的步进电机和一个ULN2003A驱动板，单片机连接驱动板，驱动板放大单片机的脉冲信号后驱动步进电机转动。<br>本次实验的硬件部分主要包括单片机最小系统，LCD1602显示屏，DS18B20测温模块，步进电机和驱动板以及称重传感器和HX711模块。</p><h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3><p>1.准备电路元器件及焊接工具：STC89C52RC芯片1个、IC插座、40p排针2个、12MHz晶振1个、30pF瓷片电容2个、10uF电解电容1个、排阻一个、电阻若干、LCD1602A显示屏1个、称重传感器1个、HX711模块1个、DS18B20模块1个、步进电机1个、ULN2003A驱动板1个、蜂鸣器1个、10*15cm洞洞板一个、电源线、杜邦线、下载器、电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接。<br>3.调试：下载程序，将单片机系统与各个模块相连，观察LCD是否正常显示压力、温度等信息，若正常显示，说明压力，温度模块正常，按动按键，观察步进电机是否随按键控制正常转动，若转动正常，说明步进电机模块正常。 </p><ul><li>焊接成果图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_12.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写。<br>2.设计仿真电路图：将电源、时钟电路、复位电路、51单片机、DS18B20模块、称重传感器模块、HX711模块及LCD1602显示屏正确连接。电源选用+5v，晶振选用12MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否能达到目标要求。</p><ul><li>编程<br>ORG 0000H<br>//接口初始化<br>DOUT EQU P2.2<br>SCK EQU P2.3</li></ul><p>RS EQU P2.5<br>RW EQU P2.6<br>E EQU P2.7 </p><p>DQ EQU P2.4<br>GEWEI1 EQU 35H<br>SHIWEI1 EQU 36H</p><p>QIAN EQU 31H<br>BAI EQU 32H<br>SHI EQU 33H<br>GEWEI EQU 34H</p><p>FENGMING EQU P3.7<br>LJMP MAIN</p><p>ORG 000BH<br>LJMP IT00 //中断入口<br>ORG 0100H<br>MAIN:<br>MOV P0,#00000001B<br>ACALL ENABLE<br>MOV P0,#00111000B<br>ACALL ENABLE<br>MOV P0,#00001100B<br>ACALL ENABLE<br>MOV P0,#00000110B<br>ACALL ENABLE<br>MOV P0,#80H<br>ACALL ENABLE<br>MOV P0,#’W’<br>ACALL WRITELCD</p><p>MOV P0,#’E’<br>ACALL WRITELCD</p><p>MOV P0,#’N’<br>ACALL WRITELCD</p><p>MOV P0,#’D’<br>ACALL WRITELCD</p><p>MOV P0,#’U’<br>ACALL WRITELCD</p><p>MOV P0,#’:’<br>ACALL WRITELCD<br>MOV P0,#0C0H<br>ACALL ENABLE</p><p>MOV P0,#’Y’<br>ACALL WRITELCD<br>MOV P0,#’A’<br>ACALL WRITELCD<br>MOV P0,#’L’<br>ACALL WRITELCD<br>MOV P0,#’I’<br>ACALL WRITELCD<br>MOV P0,#’:’<br>ACALL WRITELCD</p><p>MOV P0,#0C9H<br>ACALL ENABLE</p><p>MOV P0,#’g’<br>ACALL WRITELCD<br>MOV 40H,#00H</p><p>MOV TMOD,#01H<br>MOV TH0,#3CH<br>MOV TL0,#0B0H<br>SETB EA<br>SETB ET0<br>SETB TR0</p><p>ACALL DIANJI<br>LJMP MAIN<br>IT00:<br>INC 40H<br>MOV A,40H<br>CJNE A,#3AH,L11</p><p>L10: MOV 40H,#00H<br>ACALL AD</p><p>L11:MOV TH0,#3CH<br>MOV TL0,#0B0H<br>RETI<br>AD:<br>ACALL READTEM<br>ACALL YALI</p><p>ACALL XIANSHI</p><p>MOV P0,#86H<br>ACALL ENABLE<br>MOV P0,SHIWEI1<br>ACALL WRITELCD<br>MOV P0,#87H<br>ACALL ENABLE<br>MOV P0,GEWEI1<br>ACALL WRITELCD</p><p>CLR C<br>MOV A,#00H<br>SUBB A,GEWEI1<br>MOV A,#03H<br>SUBB A,SHIWEI1<br>JNC L12<br>CLR P3.7<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>ACALL DELAY1<br>SETB P3.7<br>L12:<br>MOV P0,#0C5H<br>ACALL ENABLE<br>MOV P0,QIAN<br>ACALL WRITELCD<br>MOV P0,#0C6H<br>ACALL ENABLE<br>MOV P0,BAI<br>ACALL WRITELCD<br>MOV P0,#0C7H<br>ACALL ENABLE<br>MOV P0,SHI<br>ACALL WRITELCD<br>MOV P0,#0C8H<br>ACALL ENABLE<br>MOV P0,GEWEI<br>ACALL WRITELCD</p><p>RET<br>//步进电机<br>DIANJI:<br>MOV 38H,#00H<br>JNB P3.0,START1<br>JNB P3.1,START2<br>JNB P3.2,START3</p><p>LJMP DIANJI<br>START1:<br>MOV DPTR,#TABLE1<br>LJMP LOOP<br>START2:<br>MOV DPTR,#TABLE2<br>LJMP LOOP<br>START3:<br>MOV DPTR,#TABLE3<br>LJMP LOOP<br>LOOP:<br>MOV A,38H<br>MOVC A,@A+DPTR<br>MOV P1,A<br>LCALL DELAY1<br>INC 38H<br>MOV A,38H<br>CJNE A,#08H,LOOP</p><p>JNB P3.0,L1<br>JNB P3.1,L1<br>JNB P3.2,L1<br>MOV 38H,#00H<br>LJMP LOOP<br>L1:<br>LJMP DIANJI<br>RET</p><p>DELAY1:MOV R5,#25  //步进电机的延时<br>DEL1:MOV R6,#50<br>     DJNZ R6,$<br>     DJNZ R5,DEL1<br>     RET<br>//步进电机码表<br>TABLE1:<br>DB 02H,06H,04H,0CH,08H,09H,01H,03H<br>TABLE2:<br>DB 03h,01H,09H,08H,0CH,04H,06H,02H<br>TABLE3:<br>DB 00H,00H,00H,00H,00H,00H,00H,00H</p><p>//温度传感器</p><p>READTEM:</p><p>ACALL RST</p><p>MOV R1,#30<br>DJNZ R1,$<br>MOV A,#0CCH<br>ACALL WRITE<br>MOV A,#44H<br>ACALL WRITE<br>ACALL RST<br>MOV R1,#30<br>DJNZ R1,$<br>MOV A,#0CCH<br>ACALL WRITE<br>MOV A,#0BEH<br>ACALL WRITE</p><p>ACALL READ<br>MOV 30H,A     ;读低八位<br>ACALL READ<br>MOV 31H,A       ;读高八位</p><p>ANL 30H,#0F0H<br>ANL 31H,#0FH<br>MOV A,30H<br>ORL A,31H<br>SWAP A</p><p>MOV R3,A</p><p>MOV B,#10<br>DIV AB<br>ADD A,#30H<br>MOV SHIWEI1,A<br>MOV A,B<br>ADD A,#30H<br>MOV GEWEI1,A<br>RET</p><p>RST:SETB DQ                       ;  总线释放<br>      NOP                           ;  保持高电平，延时<br>      CLR DQ                    ;  总线置 0，请求响应<br>      MOV R0,#0FBH<br>TSR1: DJNZ R0,TSR1                    ;  延时<br>      SETB DQ                        ;  再释放<br>      MOV R0,#25H<br>TSR2: JNB DQ,TSR3                    ;  改变为 0，则代表得到对应<br>      DJNZ R0,TSR2                ;  未得到则继续等待，判断<br>TSR3:                     ;  得到相应则标志位置 1，代表传感器正常存在<br>      MOV R0,#06BH<br>TSR4: DJNZ R0,TSR4                    ;  延时<br>      SETB DQ<br>RET</p><p>WRITE:MOV R0,#8<br>LOOP1:<br>CLR C<br>CLR DQ</p><p>RRC A<br>MOV R1,#6<br>DJNZ R1,$<br>MOV DQ,C<br>MOV R1,#23<br>DJNZ R1,$<br>SETB DQ<br>NOP</p><p>DJNZ R0,LOOP1<br>SETB DQ<br>MOV R1,#05<br>DJNZ R1,$<br>RET</p><p>READ:;<br>MOV R0,#8<br>LOOP2:<br>CLR C<br>SETB DQ<br>NOP<br>NOP<br>CLR DQ<br>NOP<br>NOP<br>NOP<br>SETB DQ<br>MOV R1,#7<br>DJNZ R1,$<br>MOV C,DQ<br>RRC A<br>MOV R1,#23<br>DJNZ R1,$</p><p>DJNZ R0,LOOP2<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY2<br>SETB E<br>RET<br>WRITELCD:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY2<br>SETB E<br>RET</p><p>DELAY2:<br>MOV R4,#200<br>D1:MOV R5,#200<br>D2:DJNZ R5,D2<br>DJNZ R4,D1<br>RET</p><p>//压力传感器<br>YALI:</p><p>CLR SCK<br>JB DOUT,$<br>MOV R0,#24<br>LOOP3:<br>SETB SCK<br>NOP<br>CLR SCK<br>MOV C,DOUT</p><p>XCH A,R4<br>RLC A<br>XCH A,R4        //低八位<br>XCH A,R3<br>RLC A<br>XCH A,R3      //中八位<br>XCH A,R2<br>RLC A<br>XCH A,R2  //高八位</p><p>DJNZ R0,LOOP3</p><p>SETB SCK<br>NOP<br>CLR SCK              ;采集部分到此结束</p><p>RET</p><p>ZHUANHUAN:<br>NDIV31:<br>    MOV A,R2<br>    MOV B,R7<br>    DIV AB<br>    PUSH ACC<br>    MOV R2,B<br>    MOV B,#10H<br>NDV311:<br>    CLR C<br>    MOV A,R4<br>    RLC A<br>    MOV R4,A<br>    MOV A,R3<br>    RLC A<br>    MOV R3,A<br>    MOV A,R2<br>    RLC A<br>    MOV R2,A<br>    MOV F0,C<br>    CLR C<br>    SUBB A,R7<br>    JB F0,NDV312<br>    JC NDV313<br>NDV312:<br>    MOV R2,A<br>    INC R4<br>NDV313:<br>    DJNZ B,NDV311<br>    POP ACC<br>    ;CLR OV<br>    JZ NDV314<br>    ;SETB OV<br>NDV314:<br>    XCH A,R2<br>    MOV R7,A<br>RET</p><p>XIANSHI:<br>MOV A,R2<br>XRL A,#80H<br>MOV R2,A</p><p>MOV R7,#40<br>LCALL ZHUANHUAN</p><p>MOV R7,#10<br>LCALL ZHUANHUAN//到此温度转换结束</p><p>//去皮，减去初始重量<br>MOV R0,#04H<br>L3:CLR C<br>MOV A,R4<br>SUBB A,#208<br>MOV R4,A<br>JC JIAN<br>LJMP L2<br>JIAN:DEC R3<br>L2:DJNZ R0,L3</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV GEWEI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV SHI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV BAI,A</p><p>MOV R7,#10<br>LCALL ZHUANHUAN<br>MOV A,R7<br>ADD A,#30H<br>MOV QIAN,A</p><p>RET</p><p>END</p><p>*Proteus 仿真电路图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_13.jpg" ></p><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3><p>相比于之前的几次实验，这次的实验难度明显要高出一个数量级。从拿到实验方案开始，每一步都充满了许多问题，光是确立实验的基本方案和实验器件的选取就花费了好长时间。经过反复的筛选、比较，温度传感器选择了12位精度的DS18B20，蜂鸣器选择了有源的蜂鸣器，最麻烦的还是压力传感器的选取了，在反复查找信息之后，我简单地罗列出了三套方案：<br>1.使用压片传感器加上一个电压转换模块和ADC0809来完成压力的测试。压片传感器将压力值转换为电阻值，电压转换模块再将电阻值转换为电压值，最后再由ADC0809将电压值转换为数字量，送交单片机处理。<br>2.使用称重传感器和小信号放大芯片以及ADC0809芯片来实现。称重传感器将压力值转换为一个电压值，信号放大芯片将这个电压值放大到ADC0809可以处理的状态，最后由ADC0809将数字量送交给单片机。<br>3.使用称重传感器加上一个HX711芯片来实现。HX711是一个自带增益的AD芯片，可以放大称重传感器产生的电压值并将它转换为数字量，最后HX711通过串行通信的方式将数字量传送给单片机。<br>反复考虑各个方案的实用性，精度，稳定性以及可实现性之后，我选择了第三个方案，通过HX711来实现本次的压力测量。<br>本次实验模块在硬件的焊接上并没有遇到太大的问题，最大的难点还是在程序的编写和仿真的实现上。<br>相对来说，步进电机的程序编写还是比较简单的，通过调制脉冲来驱动步进电机的转动，仿真的演示也没有遇到什么困难。但在进行实物制作的时候还是遇到了一些问题，明明仿真可以执行的程序，但在实物里步进电机就是无法转动，经过反复排查，发现原来是程序的延时存在问题，修改了延时之后，步进电机终于开始了转动。<br>DS18B20是一个具有12位精度的温度采集模块，DS18B20的时序相对来说比较复杂，在编写汇编程序的时候，我上网查找了很多资料，分析了好多时序图，也在这个过程中认识到了时序对于单片机程序的重要性。在DS18B20的实物实现时，也遇到了仿真时没有遇到的问题，后来发现原来是晶振的问题，更换晶振之后，DS18B20也终于正常读取显示了温度。<br>最麻烦的还是HX711模块的使用了，HX711模块是一个高精度的24位的自带增益的AD模块，可以将模拟量转换为数字量之后以串行通信的方式发送给单片机。由于51单片机一次只能处理8位数据，所以24位的数据必须读取到3个寄存器中来处理，而且HX711读取的的数值必须要做一个除法才能得到压力值，这样就特别的麻烦，我花时间最长的地方也是在这里，经过反复地查找资料，不断修改自己的程序，最后通过移位相减的方法把HX711的数据给处理了。最后做出的实物总有一个不为零的初始值，经过反复考虑，我觉得是传感器本身所造成的，最后通过把所有的压力值都减去这一个初始值，获得了真实的重量。</p><p>在三个模块都各自制作完毕，没有什么问题之后，我试着把这三个模块综合起来。温度和压力模块都通过不断扫描，反复执行的方法结合在了一起，但是在结合步进电机的时候遇到了麻烦，如果把温度和压力模块直接嵌入到步进电机的程序中，步进电机的转动就会产生问题。经过反复思索后，我写了一个定时中断的程序，把步进电机的程序放在了主程序中，而把温度和压力扫描的程序放在了中断中，这样每隔一段时间，单片机就会扫描显示一次温度和压力值，而在其他时间，都在扫描按键，执行步进电机的程序。最终，通过这样一个中断，终于把几个模块完美地结合在了一起。 </p><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p> 本次实验模块的设计与制作相比之前的三个实验确实难了好多，自己花费的时间也长了好多，在整个模块的制作过程中前前后后遇到了好多困难，但自己在不断克服困难的过程中也得到了很大的提高与成长。<br>从实验方案的设计，实验器件的选取，汇编语言的编写，到仿真的演示和实物的实现，每一步充满了各种挫折和困顿。第一次自己接到一个只有题目，没有例子的方案，从零开始设计制作，每一步都比之前的实验难了很多。中间好多时候都感到很沮丧，甚至都不太想做了，整个人状态就很不好，尤其是写代码的时候，反反复复，改来改去就是得不到想要的结果，甚至有时候都不想用汇编了，想之间拿c语言把这个程序给写了。但是自己还是逐渐地调整状态，慢慢地解决了一个又一个问题，最终用汇编语言完成了整个实验模块。最终完成的时候，看着整个四五百行的汇编程序，就觉得特别有成就感。<br>写代码和做实物的过程中虽然遇到过很多挫败，也有过很多心情沮丧的时候，但更多的是知识的成长以及心中不断燃烧的好奇与热情，我想正是在这样的热情和兴趣下，自己才能一步步克服障碍，完成了这次实验模块的制作。 尽管每一次遇到困难都很沮丧，但当自己战胜一个又一个困难，最后完成整个实验模块的时候，就感觉之前所有的沮丧都不值一提。<br>通过温度压力采集及步进电机的驱动系统设计与制作，自己的的确确学到了很多。从知识方面来看，自己认识到了温度、压力传感器的使用，还对串行通信有了更加深入的认识，看到了串行通信相对于并行通信的优势。另外，自己也对汇编语言有了更加深入而细致的认识，了解到了如何使用汇编语言经行加减运算，位操作以及数据处理，看到了汇编语言相对其他语言在单片机操作上的优势，看到了汇编语言的形象化与底层化。除此之外，自己通过这个过程，也收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。自己也十分期待在未来的学习和工作中，能够更加深入地学习单片机，并把这些知识和技能应用到未来的工作和生活中。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART实现51单片机双机串行通信</title>
      <link href="2021/04/11/uart-shi-xian-51-dan-pian-ji-shuang-ji-chuan-xing-tong-xin/"/>
      <url>2021/04/11/uart-shi-xian-51-dan-pian-ji-shuang-ji-chuan-xing-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>本次单片机双机通讯系统设计实验是通过单片机间的串行通讯控制两个单片机进行通信的设计与制作。一个单片机系统做为发送端，从键盘输入自己的班级和姓名同时显示在 LCD 显示屏上并发送给另外一个单片机，另一个单片机系统作为接收端，把接收到的信息显示在 LCD 显示屏上。通过判断两个单片机系统中LCD屏幕显示的信息是否相同即可判断双机系统之间的串行通讯是否正常进行。<br>本次双机通讯系统采用了串行口方式1进行通讯，一帧信息为10位，其中有一个起始位，8个数据位和1个停止位。通讯的波特率位2400波特，T1工作在定时器方式2，震荡频率选用11.0592MH，通过计算可得TH1=TL1=0F4H,PCON寄存器的SMOD位为0。<br>整个系统的硬件部分是由两个单片机最小系统，两个 LCD 显示屏以及一个矩阵键盘构成。</p><h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3><p>1.准备电路元器件及焊接工具：STC89C51RC芯片2个、IC插座、40p排针2个、11.0592MHz晶振2个、30pF瓷片电容4个、10uF电解电容2个、排阻一个、电阻若干、LCD1602A显示屏2个、10*15cm洞洞板一个、电源线、杜邦线、下载器、电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接。<br>3.调试：下载程序，将两个单片机系统进行连接，通过按键测试双机通讯能否正常进行，若通讯正常，则两个单片机西铜所连接的lcd屏幕将随着按键按下而显示相同的字符，若不显示或字符紊乱，则双机通讯存在故障。</p><ul><li>焊接成果图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_10.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写<br>2.设计仿真电路图：将电源、时钟电路、复位电路、51单片机、LED数码管及LCD1602显示屏正确连接。电源选用+5v，晶振选用11.0592MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容，LED数码管串联470Ω电阻接在P2引脚，电阻的作用为保护电路,防止led灯被击穿，将键盘矩阵接在P0口，LCD1602A的D0-D7接口接在P1口。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否能达到目标要求。</p><ul><li>编程</li><li>发送端程序<br>ORG 0000H<br>LJMP MAIN<br>MAIN:<br>RS EQU P3.7<br>RW EQU P3.6<br>E EQU P3.5<br>MOV P1,#00000001B    ;清屏<br>ACALL ENABLE<br>MOV P1,#00111100B    ;  功能设定<br>ACALL ENABLE<br>MOV P1,#00001100B     ; 开关控制<br>ACALL ENABLE<br>MOV P1,#00000110B     ;模式设置<br>ACALL ENABLE<br>MOV P1,#80H<br>ACALL ENABLE<br>MOV R2,#00H<br>MOV DPTR,#TABLE3<br>MOV R1,#00H<br>;OR0:MOV A,R1<br>;MOVC A,@A+DPTR<br>;MOV P2,A<br>;ACALL WRITE<br>;INC R1<br>;CJNE A,#00H,OR0<br>MOV P1,#80H<br>ACALL ENABLE</li></ul><p>ORI:MOV P0,#0FH<br>MOV A,P0<br>CJNE A,#0FH,ORII<br>LJMP ORI<br>ORII:<br>ACALL KEYSCAN<br>MOV A,30H</p><p>ASTART:CLR EA<br>MOV TMOD,#20H<br>MOV TH1,#0F4H<br>MOV TL1,#0F4H<br>MOV PCON,#00H<br>SETB TR1<br>MOV SCON,#50H<br>ALOOP1:MOV SBUF,#0E1H<br>JNB TI,$<br>CLR TI<br>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,#0E2H<br>JNZ ALOOP1</p><p>ALOOP2:MOV R0,#30H<br>;MOV R7,#01H<br>MOV R6,#00H<br>ALOOP3:MOV SBUF,@R0<br>MOV A,R6<br>ADD A,@R0<br>MOV R6,A<br>;INC R0<br>JNB TI,$<br>CLR TI<br>;DJNZ R7,ALOOP3<br>MOV SBUF,R6<br>JNB TI,$<br>CLR TI<br>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>JNZ ALOOP2<br>;RET</p><p>;MOV P2,#0C0H<br>;ACALL ENABLE<br>MOV A,30H<br>MOV DPTR,#TABLE1<br>MOVC A,@A+DPTR<br>MOV P1,A      ;lcd的显示<br>ACALL WRITE<br>INC R1;<br>CJNE R1,#04H,JISHU<br>MOV P1,#0C0H<br>ACALL ENABLE<br>MOV R1,#05H<br>JISHU:<br>ACALL DELAY</p><p>SJMP ORI</p><p>AJMP $<br>WRITE:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET<br>KEYSCAN:MOV P0,#0FH<br>        MOV A,P0<br>ANL A,#0FH<br>MOV R3,A<br>MOV P0,#0F0H<br>MOV A,P0<br>ANL A,#0F0H<br>ORL A,R3<br>CJNE A,#0FFH,KEYPRO<br>RET<br>KEYPRO:MOV R3,A      ;R3放键值<br>       MOV DPTR,#KEYVALUE<br>   MOV R4,#0FFH<br>KEY1:INC R4       ;从1到16查找键值<br>     MOV A,R4    ;R4放偏移量<br> MOVC A,@A+DPTR<br> MOV 31H,R3<br> CJNE A,31H,KEY1  ;判断是否与键值相等<br> MOV A,R4<br> MOV 30H,A<br> RET<br>DELAY:<br>MOV R4,#60<br>D1:MOV R5,#60<br>D2:MOV R6,#30<br>DJNZ R6,$<br>DJNZ R5,D2<br>DJNZ R4,D1<br>RET<br>KEYVALUE: DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH<br>TABLE: DB  30H, 31H, 32H, 33H ,34H ,35H ,36H, 37H, 38H, 39H ,41H, 42H, 43H, 44H, 45H, 46H<br>TABLE1:DB ‘1’,’8’,’0’,’3’,’P’,’E’,’N’,’G’,’C’,’H’,’E’,’N’,’L’,’I’,’A’,’G’<br>TABLE2:  DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH<br>TABLE3: DB “ PENG CHENLIANG “,00H<br>END</p><ul><li>接收端程序<br>ORG 0000H<br>RS EQU P3.7<br>RW EQU P3.6<br>E EQU P3.5<br>MOV P1,#00000001B    ;清屏<br>ACALL ENABLE<br>MOV P1,#00111100B    ;  功能设定<br>ACALL ENABLE<br>MOV P1,#00001100B     ; 开关控制<br>ACALL ENABLE<br>MOV P1,#00000110B     ;模式设置<br>ACALL ENABLE<br>MOV P1,#80H<br>ACALL ENABLE<br>MOV R1,#00H<br>BSTART:CLR EA<br>MOV TMOD,#20H<br>MOV TH1,#0F4H<br>MOV TL1,#0F4H<br>MOV PCON,#00H<br>SETB TR1<br>MOV SCON,#50H<br>BLOOP1:     JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,#0E1H<br>JNZ BLOOP1<br>MOV SBUF,#0E2H<br>JNB TI,$<br>CLR TI<br>MOV R0,#30H<br>;MOV R7,#01H<br>MOV R6,#00H</li></ul><p>BLOOP2:JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>MOV @R0,A<br>;INC R0<br>ADD A,R6<br>MOV R6,A</p><p>;DJNZ R7,BLOOP2</p><p>JNB RI,$<br>CLR RI<br>MOV A,SBUF<br>XRL A,R6</p><p>JZ END1<br>MOV SBUF,#0FFH<br>JNB TI,$<br>CLR TI<br>SJMP BLOOP1<br>END1:MOV SBUF,#00H    </p><p>;MOV P2,#0C0H<br>;ACALL ENABLE<br>MOV A,30H<br>MOV DPTR,#TABLE1<br>MOVC A,@A+DPTR<br>MOV P1,A      ;lcd的显示<br>ACALL WRITE<br>INC R1;<br>CJNE R1,#04H,JISHU<br>MOV P1,#0C0H<br>ACALL ENABLE<br>MOV R1,#05H</p><p>JISHU:LJMP BSTART</p><p>WRITE:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>DELAY:<br>MOV R4,#60<br>D1:MOV R5,#60<br>D2:MOV R6,#30<br>DJNZ R6,$<br>DJNZ R5,D2<br>DJNZ R4,D1<br>RET<br>KEYVALUE: DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH<br>TABLE: DB  30H, 31H, 32H, 33H ,34H ,35H ,36H, 37H, 38H, 39H ,41H, 42H, 43H, 44H, 45H, 46H<br>TABLE1:DB ‘1’,’8’,’0’,’3’,’P’,’E’,’N’,’G’,’C’,’H’,’E’,’N’,’L’,’I’,’A’,’G’<br>TABLE2:  DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH<br>TABLE3: DB “ PENG CHENLIANG “,00H<br>END</p><ul><li>Proteus 仿真电路图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_11.jpg"></li></ul><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3><p>本次制作的双机通讯系统是在键盘显示模块之后的又一个更加复杂的模块，不得不说双机通讯系统的设计确实比之前的两个模块难了很多难了很多。从发送端与接收端通讯协议的构建，到键盘扫描，键码获取和键码的发送与传输，每一步都存在很多问题，更加麻烦的是，如何把LCD的显示和通讯系统结合起来。<br>虽然硬件部分并没有遇到什么困难，但软件部分通讯协议的构建和通讯系统与LCD显示如何相结合的问题确实很让人困扰。经过反复思考后，在发送端的程序中，我把通讯信息发送的部分放在了键盘扫描的循环中，每按下一次键盘，系统就把扫描到的键码转换为键值，发送给接收端，并在发送端的LCD上把键值显示出来。而在接收端，我把LCD显示的程序放在了通讯接受的循环里，系统每接收到一个字符，就把字符显示到接收端的LCD上。由于每按下一次键盘只显示一个字符，故每次只发送一个字符即可。<br>在LCD显示时我还发现，两个LCDv0口需要的电压居然不一样，起初我还以为是两个LCD颜色不同，所以特性存在些许的差距，后来仔细检查后才发现，原来是两个单片机系统的GND没有接到一起，所以接在两个LCD的v0口接在同一个单片机系统的电位器上并不能正常运行。之后我把两个单片机系统的GND连到了一起，采用同一个电源供电，解决了这一问题。</p><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p> 本次实验模块的设计与制作确实比之前的复杂了很多，但我自己在这个过程中也得到了很大的提高与成长。<br>从通讯系统的构建，两个系统之间的应答，校验和的检验，到如何把键盘输入的字符正确地发送并正确地显示在LCD屏幕上，每一步充满了各种挫折和困顿。虽然硬件上利用了之前的系统，但软件上协议部分确实很让人头疼。写代码的过程中虽然遇到过很多挫败，也有过很多心情沮丧的时候，但更多的是知识的成长以及心中不断燃烧的好奇与热情，在这样的热情和兴趣下，自己一步步克服障碍，完成了双机通讯系统的设计制作。 虽然每一次看到bug是都很失落，但当最后看到自己的名字成功地显示到两个LCD的屏幕上时，就觉得所有的努力和付出都是值得的。<br>通过双机通讯系统的设计与制作，自己的的确确学到了很多。从知识方面来看，自己对通讯协议的构建有了初步的认识，了解到了如何在单片机之间进行串行通讯。另外，自己也对汇编语言有了更加深入而细致的认识，看到了汇编语言相对其他语言在单片机操作上的优势，看到了汇编语言的形象化与底层化。除此之外，自己通过这个过程，也收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。自己也十分期待下一次的实验模块制作，期待自己可以更好地运用所学的知识，制作出更好的作品。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵键盘控制数码管和LCD1602的显示</title>
      <link href="2021/04/11/ju-zhen-jian-pan-kong-zhi-shu-ma-guan-he-lcd1602-de-xian-shi/"/>
      <url>2021/04/11/ju-zhen-jian-pan-kong-zhi-shu-ma-guan-he-lcd1602-de-xian-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>本次实验模块将通过矩阵键盘来控制字符的显示输出，分别采用了LED数码显示管及LCD1602液晶显示屏这两种显示方式来显示从0到F的16个字符。<br>键盘显示模块整体划分为四个部分，一是单片机最小系统，用来提供本系统最基本的工作环境配置；二是一个4*4的矩阵键盘，通过线反转法进行扫描，从而控制单片机的运行，十六个按键对应输出的十六种字符；三是共阳极数码管及其串联的电阻，四是LCD1602A液晶显示屏和控制其对比度的电位器。</p><h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3><p>1.准备电路元器件及焊接工具：STC89C51RC芯片一个、IC插座、40p排针1个、11.0592MHz晶振一个、30pF瓷片电容2个、10uF电解电容一个、排阻一个、电阻若干、LED数码管一个、LCD1602A显示屏一个、10*15cm洞洞板一个、电源线、杜邦线、下载器、电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接<br>3.调试：下载程序，测试LED数码管和lcd显示屏是否能够正常闪烁。</p><ul><li>焊接成果图</li><li>正面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_7.jpg" width="60%" height="60%"></li><li>背面<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_8.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写<br>2.设计仿真电路图：将电源、时钟电路、复位电路、51单片机、LED数码管及LCD1602显示屏正确连接。电源选用+5v，晶振选用11.0592MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容，LED数码管串联470Ω电阻接在P2引脚，电阻的作用为保护电路,防止led灯被击穿，将键盘矩阵接在P0口，LCD1602A的D0-D7接口接在P1口。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否能达到目标要求。</p><ul><li>编程<br>ORG 0000H<br>LJMP MAIN<br>MAIN:<br>RS EQU P3.7<br>RW EQU P3.6<br>E EQU P3.5<br>MOV P1,#00000001B    ;清屏<br>ACALL ENABLE<br>MOV P1,#00111100B    ;  功能设定<br>ACALL ENABLE<br>MOV P1,#00001100B     ; 开关控制<br>ACALL ENABLE<br>MOV P1,#00000110B     ;模式设置<br>ACALL ENABLE<br>MOV P1,#80H<br>ACALL ENABLE<br>MOV R1,#00H<br>MOV DPTR,#TABLE3<br>OR0:MOV A,R1<br>MOVC A,@A+DPTR<br>MOV P1,A<br>ACALL WRITE<br>INC R1<br>CJNE A,#00H,OR0</li></ul><p>ORI:MOV P0,#0FH<br>MOV A,P0<br>CJNE A,#0FH,ORII<br>LJMP ORI</p><p>ORII:<br>ACALL KEYSCAN<br>MOV A,30H<br>MOV DPTR,#TABLE2<br>MOVC A,@A+DPTR<br>MOV P2,A   ;数码管的显示<br>ACALL DELAY<br>MOV P1,#0C0H<br>ACALL ENABLE<br>MOV A,30H<br>MOV DPTR,#TABLE<br>MOVC A,@A+DPTR<br>MOV P1,A      ;lcd的显示<br>ACALL WRITE<br>ACALL DELAY<br>SJMP ORI</p><p>AJMP $<br>WRITE:SETB RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET</p><p>ENABLE:CLR RS<br>CLR RW<br>CLR E<br>ACALL DELAY<br>SETB E<br>RET<br>KEYSCAN:MOV P0,#0FH<br>        MOV A,P0<br>        ANL A,#0FH<br>        MOV R3,A<br>        MOV P0,#0F0H<br>        MOV A,P0<br>        ANL A,#0F0H<br>        ORL A,R3<br>        CJNE A,#0FFH,KEYPRO<br>        RET<br>KEYPRO:MOV R3,A      ;R3放键值<br>       MOV DPTR,#KEYVALUE<br>       MOV R4,#0FFH<br>KEY1:INC R4       ;从1到16查找键值<br>     MOV A,R4    ;R4放偏移量<br>     MOVC A,@A+DPTR<br>     MOV 31H,R3<br>     CJNE A,31H,KEY1  ;判断是否与键值相等<br>     MOV A,R4<br>     MOV 30H,A<br>     RET<br>DELAY:<br>MOV R4,#60<br>D1:MOV R5,#60<br>D2:MOV R6,#30<br>DJNZ R6,$<br>DJNZ R5,D2<br>DJNZ R4,D1<br>RET<br>KEYVALUE: DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH<br>TABLE: DB  30H, 31H, 32H, 33H ,34H ,35H ,36H, 37H, 38H, 39H ,41H, 42H, 43H, 44H, 45H, 46H<br>TABLE2:  DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH<br>TABLE3: DB “ PENG CHENLIANG “,00H<br>END</p><ul><li>Proteus 仿真电路图<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_9.jpg" ></li></ul><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3><p>1.最开始使用汇编语言进行程序设计的时候，整合了数码管和LCD1602的显示程序，并使用查表法整合了数码管和LCD1602的键码，从而可以通过键盘来控制数码管和LCD的显示。整合完之后发现在有光标的显示模式下，LCD显示出的单个字符会不断闪烁，反复排查后发现，原来是写数据的操作在不断的循环执行。我通过判断键盘输入的电平是否有变化来跳出了这一循环。<br>2.焊接完整后导入程序发现数码管不能正常显示，仔细检查后发现自己把一个错误的程序导入了进去。，于是自己重新导入了新的程序，数码管和LCD也恢复了正常显示。<br>3.LCD的显示偏暗，而且存在略微的鬼影，通过调节电阻来控制V0口的电压，改善了这一现象。<br>4.在完成最基本的键盘显示操作后，我又自己研究了LCD的CGRAM，学会了如何自己使用字模来创造自定义的字符,并将字模导入到CGRAM。</p><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p>本次制作的键盘显示模块是继单片机最小系统之后的又一个模块，不得不说，键盘显示确实比单片机最小系统难了很多。从线反转的扫描方法，到数码管的动态显示，再到用键盘操控数码管和LCD，每一步充满了各种挫折和困顿。不光软件设计上很麻烦，硬件制作上也比单片机最小系统复杂了很多，更多的接口，更多的线路，要求更高的焊接，一个个困难阻碍着设计与制作。从电路设计到电路焊接整个过程，虽然遇到过很多挫败，也有过很多心情沮丧的时候，但更多的是知识的成长以及心中不断燃烧的好奇与热情，在这样的热情和兴趣下，自己一步步克服障碍，完成了键盘显示的设计制作，并在此基础上，自己尝试了自定义字符和电子表的制作。<br>通过键盘显示模块的设计与制作，自己的的确确学到了很多。从知识方面来看，自己不仅对数码管和LCD1602有了深入的认识，而且了解到了如何通过键盘来控制这两个显示模块。另外，自己也对汇编语言有了更加深入而细致的认识，看到了汇编语言相对其他语言在单片机操作上的优势，看到了汇编语言的形象化与底层化。除此之外，自己通过这个过程，也收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机最小系统</title>
      <link href="2021/04/11/51-dan-pian-ji-zui-xiao-xi-tong/"/>
      <url>2021/04/11/51-dan-pian-ji-zui-xiao-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-系统整体概述"><a href="#第一章-系统整体概述" class="headerlink" title="第一章 系统整体概述"></a>第一章 系统整体概述</h3><p>单片机最小系统就是能够使单片机正常工作的完整的最小的电路系统。构成80C51单片机最小系统包括电源电路、时钟电路、复位电路以及51单片机。<br>对单片机的I/O口读写操作是单片机最基本的使用方法。本次设计利用51单片机的I/O口驱动点亮LED灯，使LED灯闪烁。</p><ul><li>电源电路：80C51单片机常用的电源直流5v电源.选用电源时要选用波纹小，电压稳定的电源。</li><li>时钟电路：最小系统采用11.0592MHz晶振，30pF电容。</li><li>复位电路：复位是单片机的初始化操作。单片机运行时，都需要先复位，<br>使CPU和系统中其他部件处于一个确定的初始状态，并从这个状态开始工作。因而，复位是一个很重要的操作方式。当单片机稳定，RST保持两个机器周期以上的高电平时自动复位。但单片机本身是不能自动进行复位的，必须配合相应的外部电路才能实现。上电或开关复位要求电源接通后，单片机自动复位，并且在单片机运行期间，用开关操作也能使单片机复位。本次设计采用了外部电路进行上电复位，单片机供电时会自行复位。<h3 id="第二章-硬件设计与实现"><a href="#第二章-硬件设计与实现" class="headerlink" title="第二章 硬件设计与实现"></a>第二章 硬件设计与实现</h3></li></ul><p>1.准备电路元器件及焊接工具：STC89C51RC芯片一个、IC插座、40p排针1个、11.0592MHz晶振一个、30pF瓷片电容2个、10uF电解电容一个、1kΩ电阻一个、10kΩ电阻一个、LED灯一个、7*9cm洞洞板一个、电源线、下载器，电烙铁、焊锡丝等。<br>2.焊接电路板：按照设计好的原理图进行焊接<br>3.调试：下载程序，测试LED灯是否闪烁。</p><ul><li>自己焊接制作的电源<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_1.jpg" width="60%" height="60%"></li><li>单片机最小系统<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_2.jpg" width="60%" height="60%"></li></ul><h3 id="第三章-软件设计与编程"><a href="#第三章-软件设计与编程" class="headerlink" title="第三章 软件设计与编程"></a>第三章 软件设计与编程</h3><p>1.编写代码：利用keil软件进行编程，本次设计使用了汇编语言来进行编写<br>2.设计仿真电路图：参考书上给出的电路图并且适当修改，将电源、时钟电路、复位电路、51单片机、LED灯正确连接。电源选用+5v，晶振选用11.0592MHz，时钟电路选用30pF电容，复位电路选用10kΩ电阻、10uF电容，LED灯串联一个1kΩ电阻接在P1.0引脚，电阻的作用为保护电路,防止led灯被击穿。<br>3.仿真调试：用proteus进行仿真测试，将事先编好的程序导入51单片机中，以测试程序是否符合LED灯闪烁的要求。</p><ul><li>编程<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_3.jpg"></li><li>Proteus 仿真电路图<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_4.jpg"><h3 id="第四章-作品调试与分析"><a href="#第四章-作品调试与分析" class="headerlink" title="第四章 作品调试与分析"></a>第四章 作品调试与分析</h3></li></ul><p>1.用proteus进行仿真时出现了led灯不亮的情况，我反复检查自己编写的程序和设计的电路，都没有发现问题，最后重头做了一遍才发现原来时晶振的频率写成了11.0592Hz。<br>2.使用烧录程序进行烧录时，烧录软件显示握手失败，于是我更新了驱动和烧录软件的版本，最后成功地把程序烧录进了单片机。<br>3.第一次通电观测时，发现led灯闪烁过快，于是我修改了程序，将闪烁频率调低了一些。<br>4.在最小系统的基础上，我又自己焊接制作了利用单片机实现的流水灯。</p><ul><li>软件<br><img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_5.jpg"></li><li>硬件<img src="https://cdn.jsdelivr.net/gh/yeyuwenxi/images.github.io/20210411_6.jpg" width="60%" height="60%"></li></ul><h3 id="第五章-制作感受"><a href="#第五章-制作感受" class="headerlink" title="第五章 制作感受"></a>第五章 制作感受</h3><p>本次制作的51单片机最小系统是让单片机能正常工作并发挥其功能的时所必需的组成部分。从电路设计到电路焊接整个过程，我学会了Keil和proteus两个软件的基本使用方法，对汇编语言以及单片机的仿真有了初步认识。<br>第一次自己挑选购买元器件，第一次进行汇编语言的编程，第一次使用电烙铁进行焊接，第一次烧录单片机……整个实验过程都充满了新奇，充满了兴趣，更重要的是，自己通过这个过程，收获了更多新的技能，对单片机有了更加深入而全面的认识，为以后的理论学习和课程实践打下了一个稳健的基础。<br>虽然在整个设计制作中遇到了很多困难与挫折，自己也常常被一些小问题而困扰，但当自己从百思不得其解中顿悟时，所有的烦恼与困惑都变成了兴奋与激动，就觉得所有的努力和付出在看到自己的成果时都是值得的。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于心情日记</title>
      <link href="2021/04/08/guan-yu-xin-qing-ri-ji/"/>
      <url>2021/04/08/guan-yu-xin-qing-ri-ji/</url>
      
        <content type="html"><![CDATA[<p>2021年4月7日，第10天。<br>转眼心情日记这个分类已经写到第10天了，今天想做个阶段性的小总结，也重新规划一下接下来的目标和计划。<br>这10天写的一些东西，有比较触动自己的东西，也有很多挺水的部分。<br>怎么说呢？一个公开的博客平台，写一些倾向于个人日记的东西还是不太好的，我无法做到绝对的坦诚，也避免不了情绪化的碎碎念和说教，涉及隐私的一些东西我也不是特别敢写。<br>所以接下来，打算换个方向，多写一下技术方面的问题，记录一下自己学习的过程，真正地当做一个博客来写，至于心情日记这个分类，也暂时会留在这里，偶尔回来写一两句碎碎念。<br>当然，之后也不会像之前一样做日更了，太水的东西，总归是不合适的，我也不希望它会变成我每天的一个负担，至于转载和分享，也尽可能地少放在这里，努力地去写一些自己原创的东西。<br>加油。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互联网让我更快乐了吗</title>
      <link href="2021/04/05/hu-lian-wang-rang-wo-geng-kuai-le-liao-ma/"/>
      <url>2021/04/05/hu-lian-wang-rang-wo-geng-kuai-le-liao-ma/</url>
      
        <content type="html"><![CDATA[<p>2021年4月5日，第8天。<br>当你没事儿干的时候你会干什么？<br>对我来说，这个问题的答案是上网，每天的大部分时间，我都花费在了互联网上。<br>手机和电脑，几乎牢牢占据了我的空余时间，让我沉迷网络，难以自拔。<br>上网是为了什么？<br>娱乐，游戏，小说，视频，找乐子。<br>除了互联网，自己好像没有特别多的娱乐手段，而上网之外的娱乐手段，好像快感又太低，不如上网那么容易让人满足。<br>但上网真的让自己更快乐了吗？<br>答案似乎值得商榷，上网确实可以排解空虚和寂寞，可以带来即时的快感，但快乐和幸福感，好像真的没有。<br>也许我会为一个别致的短视频而兴奋，但转眼我便会滑到下一个视频，只是为了继续这份快感和满足感。<br>也许我会被一个独到的见解所打动，但来不及深思，我便会把它抛到脑后，因为拿着手机的我分分钟就会去阅读下一个观点。<br>互联网确实给自己带来了很多快感，但也让自己更加的焦虑和不安，浮躁充斥着每一个上网者，被巨量的信息淹没的我们，根本来不及思考和停留，只是匆匆忙忙地追着下一个热点。<br>相比于别致的视频和独到的观点，更多时候，我遇到的是各种恶搞，低俗，抄袭的视频视频，情绪化的议论，吵闹，谩骂，指责，各种对立，焦虑，精神暴力。<br>那些深邃的观点早就被情绪化的内容所淹没，我们也往往会被各种垃圾信息搞得愤怒，焦虑。<br>互联网，并没有让自己变得更快乐，自己打开它的方式似乎并不正确。<br>所以，今天在这里做个计划，以后没有明确的目的或事件，自己尽量少上网冲浪，没有必须要查的资料或学习的内容，尽量少上网浏览无意义的内容。<br>立贴为记。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日清明</title>
      <link href="2021/04/05/jin-ri-qing-ming/"/>
      <url>2021/04/05/jin-ri-qing-ming/</url>
      
        <content type="html"><![CDATA[<p>2021年4月4日，第7天。<br>说起来好多天没更了，惭愧惭愧。<br>今日清明，宜踏青折柳，思故人。<br>长沙的天气依旧如往常般阴云密布，时而下几场小雨。<br>没有课的日子悠闲而惬意，一觉睡到快中午，出去吃了顿午饭。<br>吃完饭到后湖转了转，来学校这么久，还是第一次去后湖。<br>风吹波纹，杨柳依依，木桥穿越湖中，一石桥临于湖上，典型的中式风格。<br>傍边的艺术园又很有现代特色，好多地方都还在装修，也没有特别印象深刻的地方。<br>总得来说，虽然草坪有点少，湖泊占了太大面积，环湖跑道只有一半，但也算是个饭后散步的好地方了。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于孤独</title>
      <link href="2021/04/05/guan-yu-gu-du/"/>
      <url>2021/04/05/guan-yu-gu-du/</url>
      
        <content type="html"><![CDATA[<p>2021年4月2日，第5天。</p><p>一直以来我好像都是一个比较孤独的人，甚至可以说有点孤僻。<br>长久以来，习惯了一个人吃饭，一个人上下课，一个人去图书馆，一个人出去散步……<br>我好像已经彻底习惯了一个人的生活，甚至有些时候有点沉浸于这种状态。<br>一个人的状态，好像也是一种舒适区，很多时候，自己不愿意被其他人或其他任务打乱自己的生活节奏。<br>但偶尔，有些时候，好像也会顾影自怜，真正聊得来的朋友没有几个，能在自己身边了解自己当下处境的就更少了。<br>一个人的自由并没有什么错，但自己也不应该太过于沉浸于这种状态。<br>我或许更应该试着去积极主动地和他人交流，主动地去做一些事情。<br>不希望因为自己一个人的状态，就丧失了走出去的勇气。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考研or工作</title>
      <link href="2021/04/01/kao-yan-or-gong-zuo/"/>
      <url>2021/04/01/kao-yan-or-gong-zuo/</url>
      
        <content type="html"><![CDATA[<p>2021年4月1日，第四天。<br>今天想聊聊一个比较重要的话题，工作还是考研？<br>起码对我来说，这个话题很重要，甚至显得有些沉重。<br>这篇博客估计也不是一两天能写完的，在写的过程中，我也在不断地思考，甚至很久以后，我还可能会回来，补上一两句话。</p><p>下面直接步入正题吧，分析一下考研和工作的利弊</p><h2 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h2><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我做了那么多改变</title>
      <link href="2021/03/31/wo-zuo-liao-na-me-duo-gai-bian/"/>
      <url>2021/03/31/wo-zuo-liao-na-me-duo-gai-bian/</url>
      
        <content type="html"><![CDATA[<p>2021年3月31日，第3天。<br>“我做了那么多改变，只是为了我心中不变”<br>今天早上去上课的路上听到这句歌词时，突然之间就被打动了。<br>从小到大，我一直坚定不移地相信的一句话就是，人是会变的。<br>这么多年，我又何尝没有改变过，但无论再如何改变，总有些内在的东西是没有变的。<br>比如一些信念，一些梦想，那些潜藏在内心深处没有改变的，才是真的决定自己是谁的东西，而我们所有的改变，也只是为了守护内心深处那些柔软而坚定的东西。<br>一天宛如一年，一年宛如一天，任时光流转，我还是我。</p><p>每次感叹时光的时候都会不自觉地想起刚上初中时的自己。<br>那一年，自己告别村里的小伙伴，一个人到县城的初中上学，虽然显得有些孤独，但更多的是内心的希望和信念，我要好好学习，我要证明自己的优秀，我要成为我想要成为的那种人。<br>那时的我，已经觉得自己俨然是个成熟的大人了，再也不是那些小学的小屁孩了，怎么会因为一个人的孤独而独自忧伤呢。<br>可越长大越发现，真正的成熟总比自己想象的要晚，少年时自以为的成熟不过是为赋新词强说愁罢了。<br>现在想起来，虽然有些可笑，但那段时光就是自己自我意识真正萌芽的开始。<br>满满的少年心气，单纯的梦想和渴望，虽然显得幼稚，却可能再也回不来了。<br>我再也不会下课风一般地冲向食堂，再也不会拿着一个条格作业本跟同桌下五子棋，再也不会拿着一个按键手机读网络小说到废寝忘食……</p><p>转眼间，已经快十年了，很多记忆都变得模糊，也有很多人都淡忘在记忆里，甚至连自己曾经的样子都变得有些模糊。<br>这么多年以来，我到底变成了一个什么样的人，当初的那个自己会想到今天自己的模样吗？<br>那时的自己，可以课间跟同学玩双杠和云梯到手掌结痂，现在的我除了体测却再也不愿碰单杠，那时的自己，可以上课边写作业边听讲，追着老师请教问题，现在的我上课却常常走神看着手机神游天外…<br>有些事情，随着长大，再也不会去做了，有些曾经以为自己不会做的，现在却一直不停的在做…<br>曾经以为上了大学可以生活规律，精神饱满，上了大学才发现，生活更加的不规律，每天仍然时常打盹…<br>那我还是我吗？就像那只特修斯之船，不断地更换零件，还是曾经的船吗？<br>走过那么多的路，经历越多，人就变得越复杂，各种想法和信念也随着经历在不断地改变。<br>那么那些我身上坚定不变的到底是什么，时光留下的又是什么？<br>害，谈论的太深就该研究哲学了？<br>这里就简单记录一下我自己的想法：<br>我想，我之所以是我，是因为我为人处世的原则和独一无二的经历，在什么面临抉择时会做什么选择，决定了我是谁。<br>这些年来，虽然我也改变了很多，但原则在那里，经历在那里，思维的连续性在那里，所以我还是我。<br>未完待续。。。</p><h2 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h2><h2 id="初心"><a href="#初心" class="headerlink" title="初心"></a>初心</h2>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈熬夜</title>
      <link href="2021/03/31/tan-tan-ao-ye/"/>
      <url>2021/03/31/tan-tan-ao-ye/</url>
      
        <content type="html"><![CDATA[<p>2021年3月30日，第二天。<br>今天想聊一聊熬夜这个话题。<br>上大学以来，自己好像就养成了熬夜习惯，尤其是大三以来，每天睡得比之前晚了好多，天天都要到12点之后才会睡觉，就算这样，每天睡前在床上还会玩好久的手机。<br>网上睡得晚，第二天难免没什么精力，早上又起的迟，第二天晚上该睡的时候还不困，不可避免地陷入了恶心循环。</p><h3 id="当我熬夜的时候我在干什么？"><a href="#当我熬夜的时候我在干什么？" class="headerlink" title="当我熬夜的时候我在干什么？"></a>当我熬夜的时候我在干什么？</h3><p>玩手机…<br>好像又回到昨天的那个话题了<a href="http://yeyuwenxi.github.io/2021/03/30/dang-wo-kan-shou-ji-de-shi-hou-wo-zai-kan-xie-shi-me/">当我看手机时我在看什么</a><br>说白了，熬夜的时候自己也没做什么正经事情，自己也从来都不是一个喜欢在夜晚工作的人，每天熬夜的原因只有一个–玩！<br>晚上躺在床上说着拿起手机只看一会儿，但每次一看就不知道要到几点钟，最后不知不觉就又熬了个大夜。</p><h3 id="熬夜真的快乐吗"><a href="#熬夜真的快乐吗" class="headerlink" title="熬夜真的快乐吗"></a>熬夜真的快乐吗</h3><p>一时熬夜一时爽，一直熬夜一直爽。<br>熬夜的快感是即时的，一旦沉浸于其中就难以自拔，但熬夜之后呢？第二天昏昏沉沉，做什么事情都没有精神，起得又晚，很多时候一个大早上就没了。<br>熬夜只是一时的快乐，摧残的确实长久的身心，严重地扰乱着自己的生活。</p><h3 id="到底为什么熬夜"><a href="#到底为什么熬夜" class="headerlink" title="到底为什么熬夜"></a>到底为什么熬夜</h3><p>熬到深夜的情况，无一例外都是在玩手机，躺在床上玩手机，有一种难以抵抗又极易获得的满足感。<br>因刷知乎而情绪化，因小说而沉迷，这好像都是自己与世界相处的一种方式，在这种情境下，特别容易忘记时间，忘记外界，一个人沉浸于自己的想象，不受外界干扰的想象。<br>但这又何尝不是逃避世界的一种方式呢？<br>白天的世界充满了真实和骨干，夜幕下的自己持续地用远方的世界麻木着自己，好像只有这样，才能真正地找到自己。</p><h3 id="这是我想要的吗？"><a href="#这是我想要的吗？" class="headerlink" title="这是我想要的吗？"></a>这是我想要的吗？</h3><p>貌似不是。<br>很多时候都是在习惯的趋势下不自觉地熬夜，我又何尝不想早点睡，好好休息，第二天精力满满呢？<br>所以在这里做个计划，以后没事儿干，晚上少玩手机，少上网，少看小说，早睡早起，不再被短暂的快感所羁绊而陷入生活的泥沼无法自拔。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android实例之必应每日一图</title>
      <link href="2021/03/30/android-shi-li-zhi-bi-ying-mei-ri-yi-tu/"/>
      <url>2021/03/30/android-shi-li-zhi-bi-ying-mei-ri-yi-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="Android实现每天更新一张图片"><a href="#Android实现每天更新一张图片" class="headerlink" title="Android实现每天更新一张图片"></a>Android实现每天更新一张图片</h2><p>第一次写博客，记录一下自己学习android过程中做过的一些实例。</p><p>必应官网每天都会更新一张图片，我们可以通过这张图片的链接来获取这张图片，并让其显示在android app中。</p><h3 id="一、图片的获取"><a href="#一、图片的获取" class="headerlink" title="一、图片的获取"></a>一、图片的获取</h3><p>必应提供了一个图片的接口，我们可以通过访问这个接口来获取每日更新的图片，接口链接如下所示：<code>https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1</code><br>通过浏览器访问该链接可以得到以下所示数据</p><blockquote><p>{“images”:[{“startdate”:”20210124”,”fullstartdate”:”202101241600”,”enddate”:”20210125”,<strong>“url”:”/th?id=OHR.ChurchRock_ZH-CN6926315999_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp”</strong>,”urlbase”:”/th?id=OHR.ChurchRock_ZH-CN6926315999”,”copyright”:”红石公园教堂岩附近的雷击，新墨西哥州 (© Tim Fitzharris/Minden Pictures)”,”copyrightlink”:”<a href="https://www.bing.com/search?q=%E7%BA%A2%E7%9F%B3%E5%85%AC%E5%9B%AD%E6%95%99%E5%A0%82&amp;form=hpcapt&amp;mkt=zh-cn&quot;,&quot;title&quot;:&quot;&quot;,&quot;quiz&quot;:&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20210124_ChurchRock%22&amp;FORM=HPQUIZ&quot;,&quot;wp&quot;:true,&quot;hsh&quot;:&quot;cdae6c57dbb4fe473dfd4f93b7870b8b&quot;,&quot;drk&quot;:1,&quot;top&quot;:1,&quot;bot&quot;:1,&quot;hs&quot;:%5B%5D%7D%5D,&quot;tooltips&quot;:%7B&quot;loading&quot;:&quot;%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD...&quot;,&quot;previous&quot;:&quot;%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F&quot;,&quot;next&quot;:&quot;%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F&quot;,&quot;walle&quot;:&quot;%E6%AD%A4%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E7%94%A8%E4%BD%9C%E5%A3%81%E7%BA%B8%E3%80%82&quot;,&quot;walls&quot;:&quot;%E4%B8%8B%E8%BD%BD%E4%BB%8A%E6%97%A5%E7%BE%8E%E5%9B%BE%E3%80%82%E4%BB%85%E9%99%90%E7%94%A8%E4%BD%9C%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E3%80%82&quot;%7D%7D">https://www.bing.com/search?q=%E7%BA%A2%E7%9F%B3%E5%85%AC%E5%9B%AD%E6%95%99%E5%A0%82&amp;form=hpcapt&amp;mkt=zh-cn&quot;,&quot;title&quot;:&quot;&quot;,&quot;quiz&quot;:&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20210124_ChurchRock%22&amp;FORM=HPQUIZ&quot;,&quot;wp&quot;:true,&quot;hsh&quot;:&quot;cdae6c57dbb4fe473dfd4f93b7870b8b&quot;,&quot;drk&quot;:1,&quot;top&quot;:1,&quot;bot&quot;:1,&quot;hs&quot;:[]}],&quot;tooltips&quot;:{&quot;loading&quot;:&quot;正在加载...&quot;,&quot;previous&quot;:&quot;上一个图像&quot;,&quot;next&quot;:&quot;下一个图像&quot;,&quot;walle&quot;:&quot;此图片不能下载用作壁纸。&quot;,&quot;walls&quot;:&quot;下载今日美图。仅限用作桌面壁纸。&quot;}}</a></p></blockquote><p>其中，url标签后的内容即为我们所需图片的地址，通过访问<code>http://cn.bing.com+该地址</code>就可以得到我们想要的图片，例如，上面得到的url为<br><code> /th?id=OHR.ChurchRock_ZH-CN6926315999_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp</code><br>那我们访问</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;cn.bing.com&#x2F;th?id&#x3D;OHR.ChurchRock_ZH-CN6926315999_1920x1080.jpg&amp;rf&#x3D;LaDigue_1920x1080.jpg&amp;pid&#x3D;hp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以得到我们想要的图片。</p><h3 id="二、在android上获取并显示图片"><a href="#二、在android上获取并显示图片" class="headerlink" title="二、在android上获取并显示图片"></a>二、在android上获取并显示图片</h3><p>由于android自身的限制，网络操作只能在子线程中完成，这一点是我们写代码中特别需要注意的。因此我们要把访问api接口的代码写在子线程中。此外，在android中，与UI有关的操作只能在主线程或UI线程中完成，所以我们加载图片上要记得更换线程。</p><h4 id="1-访问api接口"><a href="#1-访问api接口" class="headerlink" title="1.访问api接口"></a>1.访问api接口</h4><p>这里我们通过android自带的httpurlconnection来访问，并将访问得到的json返回文件存储到字符串response中。</p><pre class="line-numbers language-none"><code class="language-none">private void sendRequestWithHttpURLConnection() &#123;        &#x2F;&#x2F; 开启线程来发起网络请求        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                HttpURLConnection connection &#x3D; null;                BufferedReader reader &#x3D; null;                try &#123;                    URL url &#x3D; new URL(&quot;https:&#x2F;&#x2F;cn.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;1&quot;);                    connection &#x3D; (HttpURLConnection) url.openConnection();                    connection.setRequestMethod(&quot;GET&quot;);                    connection.setConnectTimeout(8000);                    connection.setReadTimeout(8000);                    InputStream in &#x3D; connection.getInputStream();                    &#x2F;&#x2F; 下面对获取到的输入流进行读取                    reader &#x3D; new BufferedReader(new InputStreamReader(in));                    StringBuilder response &#x3D; new StringBuilder();                    String line;                    while ((line &#x3D; reader.readLine()) !&#x3D; null) &#123;                        response.append(line);                    &#125;                    parseJSONWithJSONObject(response.toString());                   &#x2F;&#x2F; showResponse(response.toString());                    &#x2F;&#x2F;Ui线程                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    if (reader !&#x3D; null) &#123;                        try &#123;                            reader.close();                        &#125; catch (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    if (connection !&#x3D; null) &#123;                        connection.disconnect();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-json的解析"><a href="#2-json的解析" class="headerlink" title="2.json的解析"></a>2.json的解析</h4><p>这里我们直接通过android自带的JSONArray和JSONObject来进行json的解析，并将解析到的结果和<code>http://cn.bing.com</code>拼接起来，得到我们想要的图片的链接，并将其存储在字符串url1中。</p><pre class="line-numbers language-none"><code class="language-none">private void parseJSONWithJSONObject(String jsonData) &#123;        try &#123;           &#x2F;&#x2F; JSONArray jsonArray &#x3D; new JSONArray(jsonData);            JSONArray jsonArray &#x3D; new JSONObject(jsonData).getJSONArray(&quot;images&quot;);            for (int i &#x3D; 0; i &lt; jsonArray.length(); i++) &#123;                JSONObject jsonObject &#x3D; jsonArray.getJSONObject(i);                String url &#x3D; jsonObject.getString(&quot;url&quot;);                Log.d(&quot;MainActivity&quot;, &quot;url is &quot; + url);String url1&#x3D;&quot;http:&#x2F;&#x2F;cn.bing.com&quot;+url;                showResponse(url1);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-图片的加载"><a href="#3-图片的加载" class="headerlink" title="3.图片的加载"></a>3.图片的加载</h4><p>利用开源框架Glide进行图片的加载。<br>注意，图片的加载要写在UI线程中。</p><pre class="line-numbers language-none"><code class="language-none">private void showResponse(final String response) &#123;        runOnUiThread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 在这里进行UI操作，将结果显示到界面上                Glide.with(MainActivity.this).load(response).into(img);              &#x2F;&#x2F;  text.setText(response);                Log.i(&quot;123&quot;,response);            &#125;        &#125;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、演示效果"><a href="#三、演示效果" class="headerlink" title="三、演示效果"></a>三、演示效果</h3><p><img src="https://img-blog.csdnimg.cn/20210125151637243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54aWhhbmh1aQ==,color_FFFFFF,t_70" alt="演示效果"></p><h3 id="四、源代码"><a href="#四、源代码" class="headerlink" title="四、源代码"></a>四、源代码</h3><p><strong>1.xml</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:orientation&#x3D;&quot;vertical&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;&lt;ImageView    android:id&#x3D;&quot;@+id&#x2F;img&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;&#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这部分代码比较简单，就是线性布局中加了一个imageview.</p><p><strong>2.activity</strong></p><pre class="line-numbers language-none"><code class="language-none">public class MainActivity extends AppCompatActivity &#123;    TextView text;    ImageView img;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F; text&#x3D;findViewById(R.id.text);       img&#x3D;findViewById(R.id.img);        sendRequestWithHttpURLConnection();    &#125;    private void sendRequestWithHttpURLConnection() &#123;        &#x2F;&#x2F; 开启线程来发起网络请求        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                HttpURLConnection connection &#x3D; null;                BufferedReader reader &#x3D; null;                try &#123;                    URL url &#x3D; new URL(&quot;https:&#x2F;&#x2F;cn.bing.com&#x2F;HPImageArchive.aspx?format&#x3D;js&amp;idx&#x3D;0&amp;n&#x3D;1&quot;);                    connection &#x3D; (HttpURLConnection) url.openConnection();                    connection.setRequestMethod(&quot;GET&quot;);                    connection.setConnectTimeout(8000);                    connection.setReadTimeout(8000);                    InputStream in &#x3D; connection.getInputStream();                    &#x2F;&#x2F; 下面对获取到的输入流进行读取                    reader &#x3D; new BufferedReader(new InputStreamReader(in));                    StringBuilder response &#x3D; new StringBuilder();                    String line;                    while ((line &#x3D; reader.readLine()) !&#x3D; null) &#123;                        response.append(line);                    &#125;                    parseJSONWithJSONObject(response.toString());                   &#x2F;&#x2F; showResponse(response.toString());                    &#x2F;&#x2F;Ui线程                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    if (reader !&#x3D; null) &#123;                        try &#123;                            reader.close();                        &#125; catch (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    if (connection !&#x3D; null) &#123;                        connection.disconnect();                    &#125;                &#125;            &#125;        &#125;).start();    &#125;    private void showResponse(final String response) &#123;        runOnUiThread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 在这里进行UI操作，将结果显示到界面上                Glide.with(MainActivity.this).load(response).into(img);              &#x2F;&#x2F;  text.setText(response);                Log.i(&quot;123&quot;,response);            &#125;        &#125;);    &#125;    private void parseJSONWithJSONObject(String jsonData) &#123;        try &#123;           &#x2F;&#x2F; JSONArray jsonArray &#x3D; new JSONArray(jsonData);            JSONArray jsonArray &#x3D; new JSONObject(jsonData).getJSONArray(&quot;images&quot;);            for (int i &#x3D; 0; i &lt; jsonArray.length(); i++) &#123;                JSONObject jsonObject &#x3D; jsonArray.getJSONObject(i);                String url &#x3D; jsonObject.getString(&quot;url&quot;);                Log.d(&quot;MainActivity&quot;, &quot;url is &quot; + url);String url1&#x3D;&quot;http:&#x2F;&#x2F;cn.bing.com&quot;+url;                showResponse(url1);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android实现TCP客户端</title>
      <link href="2021/03/30/android-shi-xian-tcp-ke-hu-duan/"/>
      <url>2021/03/30/android-shi-xian-tcp-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-添加相关权限，使得android-app可以访问网络"><a href="#1-添加相关权限，使得android-app可以访问网络" class="headerlink" title="1.添加相关权限，使得android app可以访问网络"></a>1.添加相关权限，使得android app可以访问网络</h2><p>在AndroidManiffest.xml中添加</p><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-socket的连接"><a href="#2-socket的连接" class="headerlink" title="2.socket的连接"></a>2.socket的连接</h2><p>由于android平台的限制，与网络相关的操作只能在子线程中进行，所以这里我们单独建立一个线程用于socket的连接</p><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;子线程中进行网络相关操作    class connectthread extends Thread &#123;        OutputStream outputStream&#x3D;null;        InputStream inputStream&#x3D;null;        @Override        public void run() &#123;            &#x2F;&#x2F;连接            try &#123;                socket&#x3D;new Socket(a, b);                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接成功&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);            &#125; catch (UnknownHostException e) &#123;                &#x2F;&#x2F; TODO Auto-generated catch block                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接失败&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);                e.printStackTrace();            &#125;catch (IOException e) &#123;                e.printStackTrace();                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接失败&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>socket=new socket(a,b)这一方法可以建立一个tcp连接,其中，a为ip地址，b为端口号<br>如果连接成功，我们及通过Toast在屏幕中显示“连接成功”，若连接失败，则会转到异常中，我们通过Toast显示“连接失败”。</p><h2 id="3-通过输出流发送消息"><a href="#3-通过输出流发送消息" class="headerlink" title="3.通过输出流发送消息"></a>3.通过输出流发送消息</h2><p>在子线程中添加以下代码，获取socket的输出流对象<br>并通过输出流对象的write()方法向服务器发送“123”</p><pre class="line-numbers language-none"><code class="language-none">try &#123;               outputStream&#x3D;socket.getOutputStream();               outputStream.write(123);           &#125; catch (IOException e) &#123;               e.printStackTrace();           &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是最简单的消息发送，下面我们通过edittext获取输入的内容，并将输入的内容发送给服务器</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;发送      send.setOnClickListener(new View.OnClickListener() &#123;          @Override          public void onClick(View v) &#123;              &#x2F;&#x2F;子线程中进行网络操作  new Thread(new Runnable() &#123;      @Override      public void run() &#123;          if(socket!&#x3D;null)&#123;          try &#123;              String text&#x3D;out.getText().toString();              lianjie.outputStream.write(text.getBytes());          &#125; catch (UnknownHostException e) &#123;              &#x2F;&#x2F; TODO Auto-generated catch block              e.printStackTrace();          &#125;catch (IOException e) &#123;              e.printStackTrace();          &#125;&#125;else&#123;              runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以              &#123;                  public void run()                  &#123;                      &#x2F;&#x2F; TODO Auto-generated method stub                      Toast.makeText(MainActivity.this,&quot;请先建立连接&quot;,Toast.LENGTH_SHORT).show();                  &#125;              &#125;);          &#125;      &#125;  &#125;).start();          &#125;      &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，发送的操作需要在子线程中进行，所以这里我又建立了一个线程来进行发送的操作，在线程中获取socket的输出流对象即可进行内容的发送。<br>在这里我加了一个提示信息，如果socket为空的话，则提示“请先建立连接”。</p><h2 id="4-通过输入流获取消息"><a href="#4-通过输入流获取消息" class="headerlink" title="4.通过输入流获取消息"></a>4.通过输入流获取消息</h2><p>在子线程中建立一个死循环，时刻监听输入流，读取服务器发送来的消息</p><pre class="line-numbers language-none"><code class="language-none">try&#123;               while (true)               &#123;                   final byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F;创建接收缓冲区                   inputStream &#x3D; socket.getInputStream();                   final int len &#x3D; inputStream.read(buffer);&#x2F;&#x2F;数据读出来，并且返回数据的长度                   runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                   &#123;                       public void run()                       &#123;                           &#x2F;&#x2F; TODO Auto-generated method stub                           receive.append(new String(buffer,0,len)+&quot;\r\n&quot;);                       &#125;                   &#125;);               &#125;           &#125;           catch (IOException e) &#123;       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5.测试结果"></a>5.测试结果</h2><p>客户端<br><img src="https://img-blog.csdnimg.cn/20210321163105573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54aWhhbmh1aQ==,size_10,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>服务器<br><img src="https://img-blog.csdnimg.cn/202103211631546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54aWhhbmh1aQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>经过测试，服务器和客户端之间可以正常的发送和接收信息。</p><h2 id="6-源代码"><a href="#6-源代码" class="headerlink" title="6.源代码"></a>6.源代码</h2><p>xml</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;ip&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;ip&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;port&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;port&quot;        &#x2F;&gt;    &lt;EditText        android:id&#x3D;&quot;@+id&#x2F;out&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:hint&#x3D;&quot;请输入要发送的内容&quot;        &#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;connect&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;连接&quot;&#x2F;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;send&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;发送&quot;&#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;receive&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mainactivity</p><pre class="line-numbers language-none"><code class="language-none">public class MainActivity extends AppCompatActivity &#123;    String a;    int b;    connectthread lianjie;    TextView receive;    Socket socket&#x3D;null;    Button connect;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        EditText ip&#x3D;findViewById(R.id.ip);        EditText port&#x3D;findViewById(R.id.port);        EditText out&#x3D;findViewById(R.id.out);         receive&#x3D;findViewById(R.id.receive);         connect&#x3D;findViewById(R.id.connect);        Button send&#x3D;findViewById(R.id.send);        connect.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                a&#x3D;ip.getText().toString();                String c&#x3D;port.getText().toString();                if(&quot;&quot;.equals(a)||&quot;&quot;.equals(c))&#123;                    Toast.makeText(MainActivity.this,&quot;请输入ip和端口号&quot;,Toast.LENGTH_SHORT).show();                &#125;                else&#123;b&#x3D;Integer.valueOf(c);                 lianjie&#x3D;new connectthread();                lianjie.start();&#125;            &#125;        &#125;);        &#x2F;&#x2F;发送        send.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                &#x2F;&#x2F;子线程中进行网络操作    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            if(socket!&#x3D;null)&#123;            try &#123;                String text&#x3D;out.getText().toString();                lianjie.outputStream.write(text.getBytes());            &#125; catch (UnknownHostException e) &#123;                &#x2F;&#x2F; TODO Auto-generated catch block                e.printStackTrace();            &#125;catch (IOException e) &#123;                e.printStackTrace();            &#125;&#125;else&#123;                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;请先建立连接&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);            &#125;        &#125;    &#125;).start();            &#125;        &#125;);    &#125;    &#x2F;&#x2F;子线程中进行网络相关操作    class connectthread extends Thread &#123;        OutputStream outputStream&#x3D;null;        InputStream inputStream&#x3D;null;        @Override        public void run() &#123;            &#x2F;&#x2F;连接            try &#123;                socket&#x3D;new Socket(a, b);                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接成功&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);            &#125; catch (UnknownHostException e) &#123;                &#x2F;&#x2F; TODO Auto-generated catch block                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接失败&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);                e.printStackTrace();            &#125;catch (IOException e) &#123;                e.printStackTrace();                runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                &#123;                    public void run()                    &#123;                        &#x2F;&#x2F; TODO Auto-generated method stub                        Toast.makeText(MainActivity.this,&quot;连接失败&quot;,Toast.LENGTH_SHORT).show();                    &#125;                &#125;);            &#125;           if(socket!&#x3D;null)&#123;            &#x2F;&#x2F;获取输出流对象            try &#123;                outputStream&#x3D;socket.getOutputStream();                outputStream.write(123);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try&#123;                while (true)                &#123;                    final byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F;创建接收缓冲区                    inputStream &#x3D; socket.getInputStream();                    final int len &#x3D; inputStream.read(buffer);&#x2F;&#x2F;数据读出来，并且返回数据的长度                    runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                    &#123;                        public void run()                        &#123;                            &#x2F;&#x2F; TODO Auto-generated method stub                            receive.append(new String(buffer,0,len)+&quot;\r\n&quot;);                        &#125;                    &#125;);                &#125;            &#125;            catch (IOException e) &#123;        &#125;&#125;    &#125;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7.参考文章"></a>7.参考文章</h2><p><a href="https://blog.csdn.net/lyndon_li/article/details/82263172?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160611526819725225053660%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160611526819725225053660&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82263172.first_rank_ecpm_v3_pc_rank_v2&utm_term=android%20tcp%E5%AE%A2%E6%88%B7%E7%AB%AF&spm=1018.2118.3001.4449">Android 一步步实现TCP客户端</a><br><a href="https://blog.csdn.net/pingping_010/article/details/86527609">Android网络编程之–Socket编程</a><br><a href="https://blog.csdn.net/qq_39400113/article/details/108183449?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161579882416780271565422%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161579882416780271565422&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108183449.first_rank_v2_pc_rank_v29&utm_term=android%20tcp%E5%AE%A2%E6%88%B7%E7%AB%AF">android 之TCP客户端编程</a><br><a href="https://blog.csdn.net/weixin_48848716/article/details/107429683?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161579882416780271525479%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161579882416780271525479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-16-107429683.first_rank_v2_pc_rank_v29&utm_term=android%20tcp%E5%AE%A2%E6%88%B7%E7%AB%AF">Android Studio TCP客户端实现</a><br><a href="https://blog.csdn.net/ASWaterbenben/article/details/90172103?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328642.52964.16157988951892531&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Android的SocketTCP客户端发送信息</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android实现TCP服务器</title>
      <link href="2021/03/30/android-shi-xian-tcp-fu-wu-qi/"/>
      <url>2021/03/30/android-shi-xian-tcp-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取本机ip地址"><a href="#1-获取本机ip地址" class="headerlink" title="1.获取本机ip地址"></a>1.获取本机ip地址</h2><p>建立socket连接之前，我们首先要获取本地的ip地址，这样，才能让客户端通过ip地址连接到服务器</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**获得IP地址，分为两种情况，一是wifi下，二是移动网络下，得到的ip地址是不一样的*&#x2F;   String getIPAddress() &#123;      Context context&#x3D;MainActivity.this;      NetworkInfo info &#x3D; ((ConnectivityManager) context              .getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();      if (info !&#x3D; null &amp;&amp; info.isConnected()) &#123;          if (info.getType() &#x3D;&#x3D; ConnectivityManager.TYPE_MOBILE) &#123;&#x2F;&#x2F;当前使用2G&#x2F;3G&#x2F;4G网络              try &#123;                  &#x2F;&#x2F;Enumeration&lt;NetworkInterface&gt; en&#x3D;NetworkInterface.getNetworkInterfaces();                  for (Enumeration&lt;NetworkInterface&gt; en &#x3D; NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123;                      NetworkInterface intf &#x3D; en.nextElement();                      for (Enumeration&lt;InetAddress&gt; enumIpAddr &#x3D; intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123;                          InetAddress inetAddress &#x3D; enumIpAddr.nextElement();                          if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123;                              return inetAddress.getHostAddress();                          &#125;                      &#125;                  &#125;              &#125; catch (SocketException e) &#123;                  e.printStackTrace();              &#125;          &#125; else if (info.getType() &#x3D;&#x3D; ConnectivityManager.TYPE_WIFI) &#123;&#x2F;&#x2F;当前使用无线网络              WifiManager wifiManager &#x3D; (WifiManager) context.getSystemService(Context.WIFI_SERVICE);              WifiInfo wifiInfo &#x3D; wifiManager.getConnectionInfo();              &#x2F;&#x2F;调用方法将int转换为地址字符串              String ipAddress &#x3D; intIP2StringIP(wifiInfo.getIpAddress());&#x2F;&#x2F;得到IPV4地址              return ipAddress;          &#125;      &#125; else &#123;          &#x2F;&#x2F;当前无网络连接,请在设置中打开网络      &#125;      return null;  &#125;  &#x2F;**   * 将得到的int类型的IP转换为String类型   * @param ip   * @return   *&#x2F;   String intIP2StringIP(int ip) &#123;      return (ip &amp; 0xFF) + &quot;.&quot; +              ((ip &gt;&gt; 8) &amp; 0xFF) + &quot;.&quot; +              ((ip &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; +              (ip &gt;&gt; 24 &amp; 0xFF);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，我们要添加以下几个权限<br>使得app可以访问网络状态</p><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot; &#x2F;&gt;    &lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;    &lt;uses-permission android:name&#x3D;&quot;android.permission.CHANGE_WIFI_STATE&quot;&#x2F;&gt;    &lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_WIFI_STATE&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-建立socket连接"><a href="#2-建立socket连接" class="headerlink" title="2.建立socket连接"></a>2.建立socket连接</h2><p>建立一个子线程，在子线程中建立socket连接</p><pre class="line-numbers language-none"><code class="language-none">class ConnectThread extends Thread&#123;        OutputStream os;        Socket socket;        @Override        public void run() &#123;            try &#123;                               &#x2F;&#x2F; 1.新建ServerSocket对象，创建指定端口的连接                ServerSocket serverSocket &#x3D; new ServerSocket(10000);                &#x2F;&#x2F; 2.进行监听                socket &#x3D; serverSocket.accept();&#x2F;&#x2F; 开始监听10000端口，并接收到此套接字的连接。&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-通过输入流接收消息"><a href="#3-通过输入流接收消息" class="headerlink" title="3.通过输入流接收消息"></a>3.通过输入流接收消息</h2><p>建立一个死循环，监听输入流来自客户端的消息</p><pre class="line-numbers language-none"><code class="language-none">while (true)                &#123;                    final byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F;创建接收缓冲区                   InputStream inputStream &#x3D; socket.getInputStream();                    final int len &#x3D; inputStream.read(buffer);&#x2F;&#x2F;数据读出来，并且返回数据的长度                    runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                    &#123;                        public void run()                        &#123;                            &#x2F;&#x2F; TODO Auto-generated method stub                            text1.append(new String(buffer,0,len)+&quot;\r\n&quot;);                        &#125;                    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-通过输出流发送消息"><a href="#4-通过输出流发送消息" class="headerlink" title="4.通过输出流发送消息"></a>4.通过输出流发送消息</h2><p>  通过输出流的write()方法将消息发送到客户端</p><pre class="line-numbers language-none"><code class="language-none">os &#x3D; socket.getOutputStream();                String text&#x3D;&quot;我是服务器&quot;;                os.write(text.getBytes());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面实现通过Edittext发送输入的内容</p><pre class="line-numbers language-none"><code class="language-none">fasong.setOnClickListener(new View.OnClickListener() &#123;           @Override           public void onClick(View v) &#123;               if(connectThread.socket!&#x3D;null)&#123;               String a&#x3D;fasong_text.getText().toString();               new Thread(new Runnable() &#123;                   @Override                   public void run() &#123;                       try &#123;                           connectThread.os.write(a.getBytes());                       &#125; catch (IOException e) &#123;                           e.printStackTrace();                       &#125;                   &#125;               &#125;).start();           &#125;else&#123;                   Toast.makeText(MainActivity.this,&quot;请先建立连接&quot;,Toast.LENGTH_SHORT).show();               &#125;&#125;       &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p><strong>注意，由于模拟器的原因，模拟器ip无法作为tcp服务器被访问，所以这一部分测试只能在真机上进行。</strong><br>经过测试，服务器可以正常地和客户端进行通信。<br>这里偷点懒，放一张界面图，懒得再截真机测试的图片了。<br><img src="https://img-blog.csdnimg.cn/20210321165721149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54aWhhbmh1aQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="6-源代码"><a href="#6-源代码" class="headerlink" title="6.源代码"></a>6.源代码</h2><p>xml</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:context&#x3D;&quot;.MainActivity&quot;&gt;   &lt;EditText       android:id&#x3D;&quot;@+id&#x2F;fasong_text&quot;       android:hint&#x3D;&quot;请输入要发送的内容&quot;       android:layout_width&#x3D;&quot;wrap_content&quot;       android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;    &lt;Button        android:text&#x3D;&quot;发送&quot;        android:id&#x3D;&quot;@+id&#x2F;fasong&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;    &lt;TextView        android:id&#x3D;&quot;@+id&#x2F;text1&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;\n&quot;        app:layout_constraintBottom_toBottomOf&#x3D;&quot;parent&quot;        app:layout_constraintLeft_toLeftOf&#x3D;&quot;parent&quot;        app:layout_constraintRight_toRightOf&#x3D;&quot;parent&quot;        app:layout_constraintTop_toTopOf&#x3D;&quot;parent&quot; &#x2F;&gt;&lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Mainactivity</p><pre class="line-numbers language-none"><code class="language-none">public class MainActivity extends AppCompatActivity &#123;    TextView text1;    EditText fasong_text;    ConnectThread connectThread;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        &#x2F;&#x2F;Toast.makeText(MainActivity.this,&quot;123&quot;,Toast.LENGTH_SHORT).show();        text1&#x3D;findViewById(R.id.text1);        fasong_text&#x3D;findViewById(R.id.fasong_text);        Button fasong&#x3D;findViewById(R.id.fasong);         connectThread&#x3D;new ConnectThread();        connectThread.start();   &#x2F;&#x2F;获取本地ip地址        text1.append(&quot;本地ip地址为：&quot;+getIPAddress()+&quot; 端口号为10000&quot;);        text1.append(&quot;\n&quot;);        fasong.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                if(connectThread.socket!&#x3D;null)&#123;                String a&#x3D;fasong_text.getText().toString();                new Thread(new Runnable() &#123;                    @Override                    public void run() &#123;                        try &#123;                            connectThread.os.write(a.getBytes());                        &#125; catch (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;).start();            &#125;else&#123;                    Toast.makeText(MainActivity.this,&quot;请先建立连接&quot;,Toast.LENGTH_SHORT).show();                &#125;&#125;        &#125;);    &#125;    &#x2F;**获得IP地址，分为两种情况，一是wifi下，二是移动网络下，得到的ip地址是不一样的*&#x2F;     String getIPAddress() &#123;        Context context&#x3D;MainActivity.this;        NetworkInfo info &#x3D; ((ConnectivityManager) context                .getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();        if (info !&#x3D; null &amp;&amp; info.isConnected()) &#123;            if (info.getType() &#x3D;&#x3D; ConnectivityManager.TYPE_MOBILE) &#123;&#x2F;&#x2F;当前使用2G&#x2F;3G&#x2F;4G网络                try &#123;                    &#x2F;&#x2F;Enumeration&lt;NetworkInterface&gt; en&#x3D;NetworkInterface.getNetworkInterfaces();                    for (Enumeration&lt;NetworkInterface&gt; en &#x3D; NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123;                        NetworkInterface intf &#x3D; en.nextElement();                        for (Enumeration&lt;InetAddress&gt; enumIpAddr &#x3D; intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123;                            InetAddress inetAddress &#x3D; enumIpAddr.nextElement();                            if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123;                                return inetAddress.getHostAddress();                            &#125;                        &#125;                    &#125;                &#125; catch (SocketException e) &#123;                    e.printStackTrace();                &#125;            &#125; else if (info.getType() &#x3D;&#x3D; ConnectivityManager.TYPE_WIFI) &#123;&#x2F;&#x2F;当前使用无线网络                WifiManager wifiManager &#x3D; (WifiManager) context.getSystemService(Context.WIFI_SERVICE);                WifiInfo wifiInfo &#x3D; wifiManager.getConnectionInfo();                &#x2F;&#x2F;调用方法将int转换为地址字符串                String ipAddress &#x3D; intIP2StringIP(wifiInfo.getIpAddress());&#x2F;&#x2F;得到IPV4地址                return ipAddress;            &#125;        &#125; else &#123;            &#x2F;&#x2F;当前无网络连接,请在设置中打开网络        &#125;        return null;    &#125;    &#x2F;**     * 将得到的int类型的IP转换为String类型     * @param ip     * @return     *&#x2F;     String intIP2StringIP(int ip) &#123;        return (ip &amp; 0xFF) + &quot;.&quot; +                ((ip &gt;&gt; 8) &amp; 0xFF) + &quot;.&quot; +                ((ip &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; +                (ip &gt;&gt; 24 &amp; 0xFF);    &#125;    class ConnectThread extends Thread&#123;        OutputStream os;        Socket socket;        @Override        public void run() &#123;            try &#123;                &#x2F;&#x2F; 1.新建ServerSocket对象，创建指定端口的连接                ServerSocket serverSocket &#x3D; new ServerSocket(10000);                &#x2F;&#x2F; 2.进行监听                socket &#x3D; serverSocket.accept();&#x2F;&#x2F; 开始监听10000端口，并接收到此套接字的连接。                &#x2F;&#x2F; 3.拿到输入流（客户端发送的信息就在这里）                Log.i(&quot;a&quot;,&quot;连接成功&quot;);                 os &#x3D; socket.getOutputStream();                String text&#x3D;&quot;我是服务器&quot;;                os.write(text.getBytes());                while (true)                &#123;                    final byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F;创建接收缓冲区                   InputStream inputStream &#x3D; socket.getInputStream();                    final int len &#x3D; inputStream.read(buffer);&#x2F;&#x2F;数据读出来，并且返回数据的长度                    runOnUiThread(new Runnable()&#x2F;&#x2F;不允许其他线程直接操作组件，用提供的此方法可以                    &#123;                        public void run()                        &#123;                            &#x2F;&#x2F; TODO Auto-generated method stub                            text1.append(new String(buffer,0,len)+&quot;\r\n&quot;);                        &#125;                    &#125;);&#125;                &#x2F;&#x2F; 关闭输入流               &#x2F;&#x2F; socket.shutdownInput();                &#x2F;*os.flush();                &#x2F;&#x2F; 关闭输出流                socket.shutdownOutput();                os.close();                &#x2F;&#x2F; 关闭IO资源                bufReader.close();                reader.close();                is.close();                socket.close();&#x2F;&#x2F; 关闭socket                serverSocket.close();&#x2F;&#x2F; 关闭ServerSocket*&#x2F;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7.参考文章"></a>7.参考文章</h2><p><a href="https://blog.csdn.net/chenxihanhui/article/details/115050849">Android实现TCP客户端</a><br><a href="https://blog.csdn.net/pingping_010/article/details/86527609">Android网络编程之–Socket编程</a><br><a href="https://www.jb51.net/article/153245.htm">Android获得设备状态信息、Mac地址、IP地址的方法</a><br><a href="https://blog.csdn.net/lyndon_li/article/details/82263172?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160611526819725225053660%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160611526819725225053660&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-82263172.first_rank_ecpm_v3_pc_rank_v2&utm_term=android%20tcp%E5%AE%A2%E6%88%B7%E7%AB%AF&spm=1018.2118.3001.4449">Android 一步步实现TCP客户端</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读《偷影子的人》</title>
      <link href="2021/03/30/du-tou-ying-zi-de-ren/"/>
      <url>2021/03/30/du-tou-ying-zi-de-ren/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自己很久以前写的一篇文章。</p></blockquote><p>#《偷影子的人》:你是否真正地找到了自己</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>有这样一个人，他没有独特的名字，却拥有一种独特的能力，他能够偷得到别人的影子，并能够与影子对话，从而听到人们内心深处的不安，疑惑以及他们不为人知的梦想。</p><p>然而在他长大以后，他所具有的这种能力慢慢地变弱，他不有那样强烈的意愿，不在有那样强的好奇心，不再那样认真而真诚的去倾听，去关心我们所在乎与在乎我们的人。</p><p>虽然他因为童年的愿望而成为了一名医生，然而他不再能够如当初一般，能够听得到别人的心声，他是否还能和当初一样地认真而真诚地对待周边的人？</p><p>在这样的过程里，他慢慢的接受了亲情，友情以及爱情的一场场考验，在这样的考验里一点点地成长，并在最终找到了真正对自己来说重要的东西，成为了他自己，成为了一个真正意义上的人。</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>每个人都有自己的独特性，这种独特性可能会让你鹤立鸡群，可能会让你昂扬得意，也可能会让你被数落，被嘲讽，被践踏，但恰恰是这种独特性让你成为了你自己，而不是其他任何人。</p><p>偷影子的人正拥有这样一种独特的能力:他能偷得到别人的影子，并能与影子对话，能听得到别人内心深处那些不为人知的，不想说出秘密与梦想以及那些不想说出口的心里话。</p><p>起初，这种能力让他恐惧，他不愿意去偷听别人的秘密，不愿意去偷别人的影子，也害怕自己这种独特的能力被别人发现，从而被视为异类，被孤立，被别人打击，欺负，嘲讽。</p><p>但慢慢地，他开始试着接受这种能力，并积极地与影子交流，去帮助每一个影子的主人，去点亮他们生命中的小小光芒，帮助他们实现自己内心深处的梦想，给予他们最真诚的关注。</p><p>在帮助别人的过程里，他也慢慢地明白，原来有那么多的人都在说谎，而且他们的谎言一旦开始就不能停下，尽管这些谎言都是善意的谎言。原来有那么多的人，都把梦想深深地埋藏在心底，不愿意去向别人倾诉。</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>他也试着去帮助最好的朋友，实现他内心深处的梦想，帮助他成为医生，而不想让他像他父亲一样，一辈子做个面包师。</p><p>他的朋友不愿意放弃现在的生活，不愿意放下他的家人，去实现自己的梦想。所以他直接去找了朋友的父亲，讲述了朋友的梦想，朋友的父亲赶走了他，却也在后来的日子里赶走了朋友。父亲让朋友去实现自己的梦想，并告诉朋友，如果想回来的话，他会教给朋友如何成为一个优秀的面包师。</p><p>朋友离开家乡，开始去学习，学习如何成为一个医生，然后很好地造福他人，实现自己的梦想，但在后来的日子里，他发现，他并不适合成为一个医生。做一个医生，他没有想象中那般快乐，相反的，做一个像父亲那样的面包师，更能让自己快乐，自己喜欢看到面包出炉时的画面，喜欢看到人们拿到面包时的那种满足感，尽管自己不能成为一个优秀的医生，但自己可以去成为一个优秀的面包师！</p><p>所以朋友离开了医院，再一次地回到家中开始学做面包，去体验真正属于自己的生活，去经历真正属于自己的精彩，也真正地成为自己！</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>在爱情上，偷影子的人遇见过三个重要的女孩，班级里的伊丽莎白，沙滩上有着大提琴般笑声的克莱儿，以及同为医学生的苏菲。</p><p>伊丽莎白是童年时的倾慕，却没有成为真正的爱情，最终只成为了一种报复，一种虚荣。</p><p>长大以后遇到的苏菲，尽管很努力地维持两人的关系，却也难以真正地走入对方的心扉，最后只能不了了之。</p><p>只有那个沙滩上遇到的克莱儿，那个有着青梅竹马记忆的女孩，那个曾经许下诺言来年再见的女孩，那个用风筝写下我想你的女孩，才是自己埋藏在心底里喜欢的人。</p><p>在母亲去世之后，偷影子的人终于意识到，最美好的回忆就在当下，他应该趁着曾经的回忆还未消散，去做点什么，他去曾经的沙滩上找到了克蕾儿的消息，又多方打听找到了她，并用风筝唤回了她的记忆，两个人终于又一次地拥抱在一起。</p><p>他也终于找到了那份属于自己的温暖！</p><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>我一直相信，每个人都是与众不同的，每个人都有理由成为他自己。然而在这个缤纷多彩的大千世界里，总有那么多的人想要成为别人，想成为跟别人一模一样的人。</p><p>他们在生活里，在成长的过程中，慢慢的放弃着自己的独特性，慢慢的磨灭着自己所有与众不同的棱角，从而慢慢的融入大众，融入人群，变成了无数的江河湖海里，无数水滴中不再独特的一滴小水滴。</p><p>确实，融入大众可以让人获得一种安全感，让人不再被嘲笑，不再被讽刺，不再被针对。然而，他们却忘记了，成长的目的以及意义并不是为了让一个人放弃所有的棱角，而是为了让一个人去寻找，去探索，去在多种多样的生活里，去在夜深人静，梦的远方里，慢慢的寻找那些自己所热爱的与属于自己的东西，找到那一片真正属于自己的天空。</p><p>我并不是说归于平凡不好，只是所有的人不应当变的一模一样，世界不需要那么多标准化的人，我们应该有一点理想主义，试着去追求自己的梦想，与寻找那些年少时内心的希望与感动，试着去追寻一下自己的初心，成为一个真正意义上有灵魂，有思想的不可替代的人，也成为独特的自己！</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈《人生》</title>
      <link href="2021/03/30/du-ren-sheng/"/>
      <url>2021/03/30/du-ren-sheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自己很久以前写的一篇文章了。</p></blockquote><h1 id="《人生》-命运与个人的抉择"><a href="#《人生》-命运与个人的抉择" class="headerlink" title="《人生》:命运与个人的抉择"></a>《人生》:命运与个人的抉择</h1><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><p>放假在家，又捧起了路遥的《人生》。</p><p>记得第一次遇到这本书的时候，大概是两年前，在书店里瞎逛，因为“路遥”二字而取下了这本书。</p><p>在学校用不到一个星期就读完了这本书，或许是因为读过《平凡的世界》的缘故，感觉相比而言，这本书着眼点有些狭窄，只描写了生活中的一个片段，显得有些短暂，没有我想象的那般大气，似乎配不上人生这个书名。</p><p>现如今的我，经历了高考的抉择，也渐渐地明白了柳青所写的那句话:人生的道路虽然漫长，但紧要处却常常只有几步。而这几处抉择却往往可以决定你很长一个时期甚至是一生的道路。</p><p>人的生活，整体上来说是平淡的，也是平凡的，就像行走在乡间的小路上，碰到岔路口，需要选择的时候，才能真正的展现一个人的与众不同，也能真正地考量一个人的品性。</p><p>从这方面来说，路遥的《人生》，虽描写的面并不够广阔，但却用一个片段反应了高加林以及他周边人的品性和他们那广阔的生活，也展现了时代与命运给人带来的抉择。</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>整个故事并不太长，也不复杂，主要讲述了改革开放初期，做教师的高加林被村长的儿子替换下后，陷入了生活的困境，然而就在这时，村子里最漂亮却大字不识几个的巧珍向这位落魄的先生表达了爱意。教书先生迫于生计下地抡起了撅头，而与巧珍的爱情却给了他生活的希望与热情。</p><p>如果就这样下去，或许他们能结婚生子，平静地生活下去。然而高加林在军区的叔叔被调到了地方做了领导，村镇里的公职人员为了讨好这位领导，走后门把高加林弄回了县城，让他做了当地的记者。</p><p>高加林到了县城后，遇到了他的中学同学黄亚萍。黄亚萍欣赏高加林的个人品质，为他的才气，性格所吸引，甩掉了当前的对象张克南，主动向高加林表明了心意。高加林犹犹豫豫，最终在巧珍与黄亚萍之间选择了城镇中的女孩黄亚萍。</p><p>巧珍受到了刺激，但她并没有选择轻生，也没有疯癫，（在当时这是一件非常大的事情，巧珍的名誉受到了损失，村民们认为她会轻生或疯掉），而是选择了继续热情地生活，并与来提亲的马栓结了婚。</p><p>高加林与黄亚萍在县城里享受着生活，并计划迁居南京。但是生活又一次给他开了个玩笑，给了他一次沉重的打击。黄亚萍的前男友的妈妈向纪委举报了高加林，高加林又要被迫地回到农村。黄亚萍喜欢高加林，但她又不喜欢高加林做农民，最后迫于现实，他们无奈地分了手。他与黄亚萍之间的爱情来的突然，去的也突然，就像一场梦一样，他们之间终究还是有一道鸿沟难以跨越。</p><p>高加林又突然想起了巧珍，他发觉他还是爱着巧珍的，他感到了深深地愧疚。得知巧珍已经结婚后，高加林又感到了深深的后悔。他想轻生，但村民们的热情与真诚以及德顺老汉的劝说又让高加林感受到了生活的美好与希望。</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>从民办教师掉到黄土地里去，这是命运给他的挫折与考验。在人生的路口，巧珍的温情，给了他生活的热情，但高加林却并不甘心就这样在农村里待下去，他上过学，有些文化，有着与一般农民不一样的想法与眼界，有着年轻人的志向与傲气，他任然渴望着有朝一日能够走出去，去看看诗与远方。</p><p>而调到县城做通讯干事，无疑又给了他施展才华的机会。他也确实没有辜负这个职位，写出了一些好文章。</p><p>他的老同学黄亚萍在读到他的文章时，又突然意识到，她还是爱着他的。于是她大胆地甩掉了当前的对象，向高加林倾诉爱意。</p><p>高加林陷入了内心的斗争，他知道，他正在进行一场非常严重的抉择。</p><p>黄亚萍与刘巧珍放在一起比较，不平衡是显而易见的，他渴望和亚萍在一起，渴望外面更加精彩的生活，不愿意在一眼就能望到未来的黄土地上埋葬自己的一生。</p><p>但他的良心感到不安，他不是一个十恶不赦的坏蛋，他还是在乎巧珍的。后来，他强迫自己使心肠变硬，为了他的远大前途，必须做出牺牲。</p><p>就这样高加林做出了关乎他一生的重要决定，得知消息的巧珍痛不欲生，很快便嫁为人妇。高加林与黄亚萍则开始享受他们的二人世界，似乎他们能够永远这样的生活下去。</p><p>但命运总是不尽人意的，高加林受到了举报，必须回到农村。黄亚萍喜欢高加林，但她不喜欢做农民的高加林，现在，他们又不得不分开。</p><p>高加林得到之后又失去，丢掉了巧珍，丢掉了良心，现在又失去了黄亚萍与他的远大前程，不得不丢人地回到村中。</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><p>整个故事中高加林失去，得到最后又失去，几经起伏，最后造成了自己以及两个女子的悲剧。</p><p>高加林有知识，有文化，也有才气，有能力，最后却失去了一切所追求的事物，也丢掉了良心。</p><p>命运或许给了他许多苦难，但真正酿成自己的悲剧的，还是高加林自己。为了功名，为了虚荣，为了利益，为了所谓的自己想要的生活，高加林背弃了诺言，辜负了巧珍，放弃了一个人应当坚持的原则。</p><p>事实证明，高加林的生活哲学是错误的，他昧了良心，抛弃了巧珍，却没有得到自己想要的，最后两手空空，伤害了自己，也伤害了他人，造成了无可挽回的悲剧。<br>###05</p><p>其实并没有什么命运，一个人的命运终究还是由自己创造的，你的每一个决定，每一个习惯，都在慢慢地铸造着自己的命运。</p><p>时代或许会给每一个人带来许多痛苦，但这也并不是深渊，并不是令人绝望的困境，恰恰相反，它是磨刀石，会让你在痛苦的过程中，一次又一次地改变自己，提高自己，持续地抛弃那些不正确的习惯，方法，思想。</p><p>时代的抉择，对个人来说是痛苦的，但它是有价值的，他让每一个人与时代一起进步，一起成长。</p><p>而在时代的抉择中，裹挟着无数艰难的，无奈的个人的抉择，对个人来说，这些抉择是至关重要的，是关乎一生的，每一个决定，都有可能彻底地改变或影响自己的决定。</p><p>在人生紧要的那几步，需要每一个人自己去抉择，这些抉择，考验着每一个人的心性，能力，思想，需要一个人认认真真地去选择，绝不能背弃自己的原则，忘却自己的初心。</p><blockquote><p>愿将来有一天，当我们轻声叹息将往事回顾的时候，可以骄傲的说，当年选择了这条路，我不后悔，也没有遗憾！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>当我看手机的时候我在看些什么</title>
      <link href="2021/03/30/dang-wo-kan-shou-ji-de-shi-hou-wo-zai-kan-xie-shi-me/"/>
      <url>2021/03/30/dang-wo-kan-shou-ji-de-shi-hou-wo-zai-kan-xie-shi-me/</url>
      
        <content type="html"><![CDATA[<p>2021年3月29日，第1天。</p><p>今天想谈谈手机，自己似乎花费了太多时间在手机上，但好像又什么事情都没有做。<br>往往只是刷着一些毫无意义的信息，自以为在学习，实则什么都没有收获。<br>只有当屏幕亮着时，自己才会跟着网上的段子，奇闻趣事，傻傻地乐一乐，每当屏幕熄灭，自己又能记住什么，总想着做有意义的事情，但这样碎片化地看一些纷繁杂乱的信息，真的对自己有意义吗？手机灭屏之后，乐过的段子，笑过的笑话，也都随之而去，留给自己的，只有身体的疲惫和精神的空虚。<br>每天深夜，在睡前，总会拿着手机上网毫无目的漫游，仿佛只有这样，自己才能得到心灵的宁静与放松，可每天夜晚一刷起来就不知道要到什么时候才会停止，最后得到的往往不是心灵的宁静，而是身心的疲惫，然后在疲惫中关上屏幕，闭上干涩、肿胀的双眼，最后昏昏沉沉地睡去，第二天再无精打采地起来。<br><strong>毫无克制地刷手机，带给自己的只是一时的安慰和舒适，留下的确是杂乱的生活和疲惫不堪的身心。</strong><br>当我看手机时我在看些什么，又在追求些什么？<br>看了一下今天的手机屏幕使用时间，6小时39分，在最近几天里不算是比较多的，平均每天，自己使用手机的时间都在7小时以上，那么当我看手机的时候我在看些什么呢？<br>分析了一下上一周手机屏幕的使用时间，具体如下：</p><blockquote><p>微信读书：14时42分<br>王者荣耀：10时47分<br>知乎：7时34分<br>QQ:6时24分<br>微信：6时13分<br>抖音：5时1分<br>学习强国：2时54分<br>百度贴吧：2时40分<br>低于2小时的未列出</p></blockquote><p>这只是最近一周的数据，或许每周使用情况不太一样，但这些数据还是有很有的代表性的。<br>自己玩手机的时间基本上花在了聊天社交、图书阅读和游戏上，下面依次分析一下这几项。<br><strong>聊天社交</strong><br>无论是在自己看来还是在别人看来，自己从来都不是一个热爱社交的人，但在聊天社交这一项花的时间确实那么长。<br>微信、QQ用了那么久，自己真的是在跟人聊天吗？<br>好像不是的，大部分时间都是在刷朋友圈，毫无目的地随便看一看，自己根本就没有那么多的时间用在聊天上，这似乎早就不是真正的社交了，更多的是排解无聊与空虚的无意义行为，行为过后，带来的是更多的空虚与无聊，然后就在这个陷阱里反反复复。<br>朋友圈真的有那么好看吗？<br>这个时代，我们似乎都太过于在乎别人的生活，而往往忘记了自己真正的生活所在。<br>关注别人再多，又对自己的生活有什么好处呢？<br>这样的事情，并没有拉近自己与朋友的距离，反而会在朋友圈被包装的信息下，变得越来越陌生。<br>偶尔刷一刷，获取一些信息，了解一下朋友的最新动态，这无可厚非，但把太多的时间花在朋友圈上，就有过之而无不及了。<br>同样的，知乎也是如此，刷知乎或许在某种程度上让自己获取到了一些信息，但更多的，是信息背后无止尽的焦虑，刷知乎，并不能让自己成长，能让自己真正成长的是关闭知乎后深刻的思索和内省。<br><strong>图书阅读</strong><br>这一点就不多说什么了，最近正在培养阅读的习惯，希望接下来能坚持下去，读一些经典之作。<br><strong>游戏</strong><br>最近这一年，打的最多的游戏就是王者荣耀了，从去年春天疫情在家开始，到今年春天，自己入坑王者1年出头了。<br>自己以前一直是个不怎么打游戏的人，王者荣耀也是自己游戏时长最长的游戏了。<br>打王者这一年，自己收获了些什么呢？<br>最初打王者，是为了排解无聊，加强与朋友之间的联系，但一年以来，这一点似乎并没有做到自己想象的样子，自己更多的时间是一个人沉迷于游戏中，打王者，并没有让自己变得更会社交，更加不无聊，反而更加的空虚，更加的因为游戏中的各种逆风而情绪化。<br>打王者，早就违背了自己最开始的初衷。<br>所以，我决定卸载这个游戏，开始自己新的生活。<br><strong>结语</strong><br>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于《灵山》</title>
      <link href="2021/03/30/guan-yu-ling-shan/"/>
      <url>2021/03/30/guan-yu-ling-shan/</url>
      
        <content type="html"><![CDATA[<p>之前写了关于神游的一些东西，现在谈谈灵山，记录一些印象深刻的观点。<br>灵山和神游是一脉相成的，核心的价值观和思想是一致的，在关于神游中谈过的一些东西，这里就不再写了。<br>灵山是徐公子仙侠世界的集大成者，不仅描述了一个仙气飘飘的修行世界，更向我们展示了为什么现实世界看不到仙，为什么仙人永隔。</p><h3 id="修行发愿"><a href="#修行发愿" class="headerlink" title="修行发愿"></a>修行发愿</h3><p>没有作恶的菩萨。<br>如果有，那他就配不上菩萨的道果。<br>徐公子的修行世界是讲究愿心的，违背愿心，修行境界也会自然丧失。<br>同样的做人也是如此，违背了做人的原则，那就不是一个真正的人。</p><h3 id="所行即所愿，应为即愿为。"><a href="#所行即所愿，应为即愿为。" class="headerlink" title="所行即所愿，应为即愿为。"></a>所行即所愿，应为即愿为。</h3><p>特别喜欢徐公子的这一句话。<br>每个人做的事情，其实都是他愿意做的，每个人应当做的事情，也都是他愿意做的。<br>做自己想做的事情，才是真的做自己，也正是自己做的这些事情，决定了自己是谁。<br>有人会说，每个人都有被迫做自己不愿意做的事情的时候，但其实所谓的被迫，也只不过是权衡利弊的选择而已，在世人看来，这就是你愿意做的事情。<br>做自己愿意做的事，才是真正地做自己。</p><h3 id="真如常在"><a href="#真如常在" class="headerlink" title="真如常在"></a>真如常在</h3><p>不要管他是谁，且看他如何与你相处。</p><p>去年看的书了，现在写的时候好多东西都忘了…</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于《神游》</title>
      <link href="2021/03/29/guan-yu-shen-you/"/>
      <url>2021/03/29/guan-yu-shen-you/</url>
      
        <content type="html"><![CDATA[<p>最近刚刚读完了《神游》，记录一些笔记和自己的想法。<br>自己是读完《灵山》之后，被徐公子构建的仙侠世界所震撼，才开始继续读他的书《神游》的。<br>神游与其说是一本修仙小说，更像是一本都市小说，在神游的世界里，徐公子展示了世俗人与修行人是如何共同生活在现代化的世界里的。<br>尽管神游中有很多修行的方式和境界描写，但抛开这些修仙的外衣，神游更像是在讲为人处世的方式，人在世间的言行举止，才是最大的修行。</p><h3 id="妄心"><a href="#妄心" class="headerlink" title="妄心"></a>妄心</h3><p>妄心劫，徐公子世界中修行人必经的一大劫。<br>人人皆有妄心，有妄心，即有痛苦。<br>金钱，名利，权利，这是世俗众生每个人都有的妄心，得不到，就有了巨大的痛苦。<br>破妄，方成真人，只有破妄，才能变得更加强大。<br>破妄的关键不在于善或恶，而在于真如常在，以真实的方法应对每一件事，做到对自己真诚，修得一颗真心。<br>破妄有两种方式，以真破妄，或是以妄修真。<br>第一种是在妄境中做现实人，也就是刚刚谈到的真心，用真心面对每一件事情。<br>第二种是在现实中做妄境人，努力地把妄境变成现实，这是堕入魔道，真心被妄境所驱使，哪怕拥有再强的手段，也只不过是欲望的奴隶。</p><h3 id="真空"><a href="#真空" class="headerlink" title="真空"></a>真空</h3><p>所谓真空，个人觉得是一种无我的状态。<br>进入真空劫，世间再无这个我，法力尽失，神通皆无，只能以心渡劫，再造自我。<br>接地气一点来说，就是假如你没有了自己所依赖的各种超越平常人的能力，比如说过人的智商，情商，强健的身体，美丽的外貌，巨大的财富与名利等等，接下来你该怎么面对自己的生活，怎么在无我的状态下生活，想通了这一点并平静地面对，才能度过真空天劫。<br>《金刚经》中有一句话叫做“心无所住，而生其心”，我觉得也是对真空的一种阐述，不着迷与一切相，方能度过真空。</p><h3 id="苦海"><a href="#苦海" class="headerlink" title="苦海"></a>苦海</h3><p>苦海劫，照见前世今生，历经人间种种。<br>经历人间的种种修行，在苦海中历练，最终成就真我。</p><h3 id="一流的性情"><a href="#一流的性情" class="headerlink" title="一流的性情"></a>一流的性情</h3><p>神游中一直在讲石野是一流的性情，什么是一流的性情呢？<br>在我看来，所谓一流的性情，就是一种无怨无悔的状态，不论做什么事，最终都无怨无悔，不因选择的结果而怨天尤人，顾影自怜，而是坦然面对，哪怕有机会再相同的情况下再选一次，也仍然坚定自己的选择。</p><h3 id="修行的目的"><a href="#修行的目的" class="headerlink" title="修行的目的"></a>修行的目的</h3><p>修行是为了长生久视，不是为了纵横人间。<br>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于博客的搭建</title>
      <link href="2021/03/29/guan-yu-bo-ke-de-da-jian/"/>
      <url>2021/03/29/guan-yu-bo-ke-de-da-jian/</url>
      
        <content type="html"><![CDATA[<p>记录一些hexo博客搭建过程中遇到的问题和各种bug</p><h3 id="node命令找不到"><a href="#node命令找不到" class="headerlink" title="node命令找不到"></a>node命令找不到</h3><p>安装node.js后，无法使用node命令，好像是安装路径的问题，导致了环境变量产生了问题，最后重新使用默认路径安装了一次，解决了这个问题。</p><h3 id="配置主题时产生问题"><a href="#配置主题时产生问题" class="headerlink" title="配置主题时产生问题"></a>配置主题时产生问题</h3><p>配置icarus主题时，样式产生了问题，后来发现yml文件非常注重空格和缩进，关键位置少一个空格都会报错。</p><h3 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h3><p>试过了next,icarus,最后还是觉得matery比较好看。</p><h3 id="评论功能的选择"><a href="#评论功能的选择" class="headerlink" title="评论功能的选择"></a>评论功能的选择</h3><p>使用了matery中内置的valine评论系统，不需要后台，只要注册账号，实名认证，创建应用，配置-config.yml文件即可使用。<br>不过valine也有个缺点，就是会显示评论者的ip地址，这一点可能会涉及到隐私问题，以后有时间了，我也会看看有没有更好的评论系统。</p><h3 id="gitee第一次进入首页部分图标不显示"><a href="#gitee第一次进入首页部分图标不显示" class="headerlink" title="gitee第一次进入首页部分图标不显示"></a>gitee第一次进入首页部分图标不显示</h3><p>查资料，在github上跟开发者交流后发现，好像是gitee配置目录的问题，gitee的默认配置路径是“/+仓库名”。<br>在config.yml中添加“root: yeyuwenxi(我的仓库名)”后，成功地解决了这一问题。</p><h3 id="gitee和github双部署产生的问题"><a href="#gitee和github双部署产生的问题" class="headerlink" title="gitee和github双部署产生的问题"></a>gitee和github双部署产生的问题</h3><p>github上部署目录是“root:/”,与gitee的“root :/+仓库名”上不一样，因此部署在两个位置的同一个博客产生了样式差异。<br>以我的博客为例，不添加“root: /yeyuwenxi”时，github完全正常，gitee上的博客第一次进入首页图标不显示。<br>添加“root: /yeyuwexni”时，gitee完全正常，github上的博客完全没有样式。<br>这一问题暂未解决。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>在腾讯云添加域名解析<br>在sourse中添加CNAME文件，文件中写明要绑定的域名</p><h3 id="友情链接图标不显示"><a href="#友情链接图标不显示" class="headerlink" title="友情链接图标不显示"></a>友情链接图标不显示</h3><p>好像是图片过大造成的不显示<br>更换图片后，可以正常显示<br>图标的两种调用方式：<br>1.在线图标<br>设置图片链接即可<br>我自己在github中搭建了一个图床，用来存放图片<br>2.本地图片<br>将要使用的图片存放到主题文件下的source文件中即可，使用时直接用图片名调用</p><h3 id="修改文章的默认模板"><a href="#修改文章的默认模板" class="headerlink" title="修改文章的默认模板"></a>修改文章的默认模板</h3><p>在scaffolds文件夹下的post.md中进行修改</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>作为开始</title>
      <link href="2021/03/28/zuo-wei-kai-shi/"/>
      <url>2021/03/28/zuo-wei-kai-shi/</url>
      
        <content type="html"><![CDATA[<p>2021年3月28日，第0天。</p><p>写一些纷繁杂乱的念头，作为一个简单的开始。</p><h4 id="为什么开始这个博客"><a href="#为什么开始这个博客" class="headerlink" title="为什么开始这个博客"></a>为什么开始这个博客</h4><p>最近的生活相比之前悠闲了很多，但悠闲之后自己并没有把那些当初想做的事情做好。<br>自己并没有成为理想中的那个样子，反而因为悠闲而显得有些堕落，整天无所事事，面对生活不知所措。<br>那些当初忙碌时想做却没有去做的事情，闲下来之后自己同样也没有去做，有些事情，永远会因为各种原因而被拖延。<br>我想，这并不是当初的那个自己想要成为的模样吧。<br>在某种程度上，这就是背叛了初心吧，当初那个自己如果看到今天的模样，应该会很失望吧。<br>所以，我开始了这个博客，写一些东西，做一些改变，为了成为自己想要成为的模样而努力。<br>生而为人，不可避免地会有自身的局限性，人并不一定能成为自己想要成为的模样，但起码，人应该好好活，应该认真地去做一些有价值，有意义的事情。</p><h4 id="我要写些什么"><a href="#我要写些什么" class="headerlink" title="我要写些什么"></a>我要写些什么</h4><p>记录一些日常生活里的念头和事件，或者是感触和随笔，写一些自己的碎碎念，总结每一天的生活，作为反思，也作为勉励。<br>我不知道自己能坚持多久，也不敢确定这个过程是否真正的有价值。<br>但不管怎样，我开始了，我也希望能把这件事情坚持下去，并在这个过程中收获成长。<br>坚持从来都不是一件容易的事情，尤其是对我来说，自己好像总是会有一些各种各样，天马行空的念头和想法，但是往往又很少去实现这些想法，只是在想，却很少去做，我想这就是大家所说的执行力差吧，我一直以来好像都是一个执行力很差的人。<br>所以，我希望能够通过这件事情做一些改变，让自己静下心来，踏踏实实地做一些事情，去经历，去记录，去反思，去成长。</p><h4 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h4><p>毕竟这是一个博客，不是个人日记，所以接下来会尽可能地多写一些系统化的文章，少涉及自己个人的一些情绪。<br>希望自己能坚持每天开一篇新的文章，不一定要当天写完，但一定要每天写点有意义的话题。</p>]]></content>
      
      
      <categories>
          
          <category> 心情日记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
